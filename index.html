<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FaceAnon Pro</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#09090b">

    <!-- Apple PWA Meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FaceAnon">
    <link rel="apple-touch-icon" href="logo.jpg">

    <!-- Local Fonts -->
    <link rel="stylesheet" href="css/fonts.css">

    <!-- Face-API Library -->
    <script src="js/face-api.js"></script>

    <!-- TensorFlow.js core handles WebGL for BlazeFace -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.15.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.15.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7"></script>


    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --primary-glow: rgba(99, 102, 241, 0.4);
            --bg-dark: #09090b;
            --bg-card: #18181b;
            --bg-hover: #27272a;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --border: #27272a;
            --border-hover: #3f3f46;
            --success: #10b981;
            --warning: #f59e0b;
            --glass: rgba(24, 24, 27, 0.8);
        }

        html {
            height: 100%;
            height: 100dvh;
            /* Mobile override */
            width: 100%;
            overflow: hidden !important;
            overscroll-behavior: none !important;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100%;
            height: 100dvh;
            /* Mobile override */
            width: 100%;
            overflow: hidden !important;
            /* Force no scroll */
            overscroll-behavior: none !important;
            letter-spacing: -0.01em;
            position: fixed;
            /* Nuclear option for iOS Safari bounce */
            inset: 0;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover);
        }

        /* Header */
        header {
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 2000;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 38px;
            height: 38px;
            background: linear-gradient(135deg, var(--primary), #a855f7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 0 15px var(--primary-glow);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
        }

        .logo-icon:hover {
            transform: scale(1.05) rotate(5deg);
        }

        .menu-toggle {
            display: none;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: white;
            padding: 8px;
            min-width: 44px;
            /* Touch target */
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-toggle:hover {
            background: var(--border-hover);
        }

        .logo h1 {
            font-family: 'Outfit', sans-serif;
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(to bottom, #fff, #94a3b8);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            box-shadow: 0 0 8px var(--warning);
            position: relative;
        }

        .status-dot.ready {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .status-dot.ready::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 50%;
            border: 2px solid var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }

            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }

        /* Main Layout */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            /* Mobile viewport fix */
            overflow: hidden;
            background: var(--bg-dark);
        }

        /* Immersive Fullscreen Mobile/Tablet Mode (Active when video is loaded) */
        @media (max-width: 1024px) {
            body.video-active header {
                display: none !important;
            }

            body.video-active .app {
                height: 100dvh !important;
                height: -webkit-fill-available !important;
                overflow: hidden !important;
                position: fixed !important;
                inset: 0 !important;
                width: 100vw !important;
            }

            body.video-active .workspace {
                position: fixed !important;
                inset: 0 !important;
                width: 100vw !important;
                height: 100dvh !important;
                height: -webkit-fill-available !important;
                padding: 0 !important;
                margin: 0 !important;
                z-index: 10000 !important;
                background: #000 !important;
                display: flex !important;
                flex-direction: column !important;
            }

            body.video-active .video-card {
                border-radius: 0 !important;
                margin: 0 !important;
                border: none !important;
                background: #000 !important;
                flex: 1 !important;
                height: 100% !important;
                width: 100vw !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: center !important;
            }

            body.video-active .video-controls {
                position: absolute !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                border-radius: 0 !important;
                padding: 12px 16px !important;
                padding-bottom: calc(12px + env(safe-area-inset-bottom)) !important;
                background: rgba(0, 0, 0, 0.9) !important;
                backdrop-filter: blur(20px);
                z-index: 10001 !important;
                border-top: none !important;
                /* Removed grey profile */
            }

            body.video-active .video-canvas-wrapper {
                flex: 1 !important;
                height: 100% !important;
                width: 100% !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                background: #000;
            }

            body.video-active #renderCanvas {
                max-height: 100% !important;
                max-width: 100% !important;
                object-fit: contain !important;
            }
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-card);
            padding: 20px 16px;
            border-bottom: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 100%;
        }

        @media (max-width: 767px) {
            .sidebar {
                padding: 12px;
            }
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section:last-child {
            margin-bottom: 0;
        }

        @media (max-width: 767px) {
            .sidebar-section {
                margin-bottom: 12px;
            }
        }

        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Crucial: contain children */
            position: relative;
            padding: 24px;
        }

        @media (max-width: 767px) {
            .section-title {
                font-size: 10px;
                margin-bottom: 6px;
            }
        }

        /* Buttons */
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
        }

        @media (max-width: 767px) {
            .btn {
                padding: 8px 12px;
                font-size: 13px;
                border-radius: 10px;
            }
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            width: 100%;
            box-shadow: 0 4px 12px var(--primary-glow);
        }

        .btn-primary:not(:disabled):hover {
            background: var(--primary-light);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px var(--primary-glow);
        }

        .btn-secondary {
            background: var(--bg-hover);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.5);
        }

        /* Desktop Overlay (Bottom Left) */
        .video-overlay-status {
            position: absolute;
            bottom: 24px;
            left: 24px;
            background: rgba(0, 0, 0, 0.50);
            /* 50% Translucent */
            backdrop-filter: blur(12px);
            padding: 16px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 5;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            width: 280px;
        }

        @media (max-width: 767px) {
            .effect-grid {
                gap: 8px;
            }
        }

        .effect-option {
            padding: 16px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        @media (max-width: 767px) {
            .effect-option {
                padding: 10px 8px;
                border-radius: 8px;
            }
        }

        .effect-option.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.08);
            box-shadow: inset 0 0 0 1px var(--primary);
        }

        .effect-option:hover {
            border-color: var(--border-hover);
            transform: translateY(-2px);
            background: var(--bg-hover);
        }

        .effect-icon {
            font-size: 26px;
            display: block;
            margin-bottom: 6px;
            transition: transform 0.3s;
        }

        .effect-option:hover .effect-icon {
            transform: scale(1.1);
        }

        .effect-name {
            font-size: 13px;
            font-weight: 500;
        }

        /* Slider */
        .slider-wrapper {
            background: rgba(0, 0, 0, 0.1);
            padding: 4px;
            border-radius: 8px;
        }

        @media (max-width: 767px) {
            .slider-wrapper {
                padding: 3px;
                border-radius: 6px;
            }
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
            color: var(--text-muted);
            font-weight: 500;
        }

        @media (max-width: 767px) {
            .slider-header {
                margin-bottom: 6px;
                font-size: 11px;
            }
        }

        #intensityVal,
        #paddingVal {
            color: var(--primary-light);
            font-weight: 700;
            font-family: monospace;
        }

        .slider {
            width: 100%;
            height: 6px;
            background: var(--bg-dark);
            border-radius: 6px;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border: 3px solid var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            background: var(--primary);
        }

        /* Detection/Tracking */
        .mode-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mode-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-option:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);
        }

        .mode-option.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.08);
            box-shadow: inset 0 0 0 1px var(--primary);
        }

        .mode-icon {
            font-size: 18px;
            opacity: 0.8;
        }

        .mode-name {
            font-size: 14px;
            font-weight: 500;
            flex: 1;
        }

        .mode-check {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            transition: all 0.2s;
            opacity: 0.5;
        }

        .mode-option.active .mode-check {
            background: var(--primary);
            border-color: var(--primary);
            opacity: 1;
        }

        /* Preview Toggle */
        .preview-toggle {
            display: flex;
            gap: 8px;
        }

        @media (max-width: 767px) {
            .preview-toggle {
                gap: 6px;
            }
        }

        .preview-btn {
            flex: 1;
            padding: 8px 6px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        @media (max-width: 767px) {
            .preview-btn {
                padding: 6px 4px;
                font-size: 11px;
                border-radius: 6px;
            }
        }

        .preview-btn:hover {
            border-color: var(--primary);
        }

        .preview-btn.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
            color: var(--text);
        }

        /* Workspace */
        .workspace {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
            background-image:
                radial-gradient(circle at 2px 2px, rgba(255, 255, 255, 0.03) 1px, transparent 0);
            background-size: 40px 40px;
            position: relative;
            overflow: hidden;
            /* No scroll */
        }

        /* Upload Area */
        .upload-area {
            width: 100%;
            max-width: 440px;
            padding: 60px 40px;
            border: 2px dashed var(--border);
            border-radius: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-card);
            box-shadow: var(--shadow-lg);
        }

        @media (max-width: 767px) {
            .upload-area {
                padding: 40px 20px;
                max-width: 100%;
                border-radius: 16px;
            }
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.03);
            transform: scale(1.01);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .upload-title {
            font-family: 'Outfit', sans-serif;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .upload-subtitle {
            color: var(--text-muted);
            font-size: 15px;
            margin-bottom: 28px;
            line-height: 1.5;
        }

        .upload-btn {
            display: inline-block;
            padding: 14px 32px;
            background: var(--primary);
            border-radius: 12px;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px var(--primary-glow);
        }

        /* Mobile Upload Area Styles */
        .mobile-upload-area {
            display: none;
            /* Componente flex */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        .mobile-upload-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            border: none;
            border-radius: 20px;
            padding: 24px 40px;
            width: 100%;
            max-width: 300px;
            color: white;
            font-weight: 700;
            font-size: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
            transition: transform 0.2s;
        }

        .mobile-upload-btn:active {
            transform: scale(0.96);
        }

        /* Switching Logic */
        .desktop-only {
            display: block;
        }

        .mobile-only {
            display: none;
        }

        @media (max-width: 768px) {
            .desktop-only {
                display: none !important;
            }

            .mobile-only {
                display: flex !important;
            }

            .upload-area {
                display: none;
            }

            /* Override classic */

            /* Expand Wrapper */
            #uploadArea {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Drag Over Handlers on Wrapper */
        #uploadArea.dragover .desktop-only {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
            transform: scale(1.02);
        }

        /* Video Container */
        #videoContainer {
            display: none;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #videoContainer.active {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            /* Prevent container itself from scrolling */
        }

        .video-card {
            background: var(--bg-card);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid var(--border);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            flex: 1;
            /* Grow to fill space */
            position: relative;
            margin-bottom: 0;
            /* Attach to controls */
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .video-loader {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .video-loader.active {
            opacity: 1;
            pointer-events: all;
        }

        .loader-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }

        .loader-text {
            color: var(--text-muted);
            font-size: 14px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .video-canvas-wrapper {
            position: relative;
            width: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            /* Fill remaining card space */
            min-height: 0;
            /* Crucial for flex nested scrolling */
            overflow: hidden;
        }

        #renderCanvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: block;
            object-fit: contain;
            /* Scale down preserving aspect ratio */
        }

        /* Video Controls */
        .video-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 24px;
            background: rgba(24, 24, 27, 0.50);
            /* 50% Translucent */
            backdrop-filter: blur(8px);
            border: none;
            /* Removed grey profile */
            border-top: none;
            border-bottom-left-radius: 20px;
            border-bottom-right-radius: 20px;
            /* Ensure it sits at bottom naturally in flex */
        }

        .play-btn,
        .ctrl-btn {
            width: 44px;
            height: 44px;
            background: var(--primary);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .play-btn:hover,
        .ctrl-btn:hover {
            transform: scale(1.05);
            background: var(--primary-light);
        }

        .ctrl-btn {
            background: rgba(255, 255, 255, 0.05);
            /* Very subtle to detect touch area but no grey profile */
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
            padding: 0 10px;
        }

        .time-display {
            font-family: 'Inter', monospace;
            font-size: 13px;
            color: var(--text-muted);
            min-width: 100px;
            letter-spacing: 0.05em;
        }

        .progress-track {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: height 0.2s;
        }

        .progress-track:hover {
            height: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            width: 0%;
            border-radius: 4px;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .progress-track:hover .progress-fill::after {
            opacity: 1;
        }

        /* Header Actions */
        .header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            padding: 8px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
        }

        /* Modal Redesign */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 24px;
        }

        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            max-width: 420px;
            width: 100%;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .modal-spinner {
            width: 56px;
            height: 56px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .modal-title {
            font-family: 'Outfit', sans-serif;
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .modal-subtitle {
            color: var(--text-muted);
            font-size: 15px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .modal-progress {
            height: 10px;
            background: var(--bg-dark);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 16px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .modal-progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--primary-light), #a855f7);
            background-size: 200% 100%;
            animation: moveGradient 2s linear infinite;
            width: 0%;
            transition: width 0.3s ease;
        }

        @keyframes moveGradient {
            0% {
                background-position: 100% 0;
            }

            100% {
                background-position: -100% 0;
            }
        }

        .modal-percent {
            font-family: 'Inter', monospace;
            font-size: 18px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 24px;
        }

        .modal-cancel {
            display: block;
            margin: 0 auto;
            padding: 10px 24px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 10px;
            color: #ef4444;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-cancel:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }

        #fileInput {
            display: none;
        }

        /* Responsive Layouts */
        @media (min-width: 1024px) {
            .app {
                flex-direction: row;
            }

            .sidebar {
                width: 320px;
                height: calc(100vh - 55px);
                border-bottom: none;
                border-right: 1px solid var(--border);
                overflow-y: auto;
                flex-shrink: 0;
            }

            .workspace {
                padding: 48px;
            }
        }

        @media (max-width: 1023px) {
            .sidebar {
                padding: 20px;
            }

            .sidebar-section {
                margin-bottom: 24px;
            }
        }

        @media (max-width: 767px) {
            header {
                padding: 12px 16px;
            }

            .logo h1 {
                display: none;
            }

            .menu-toggle {
                display: block;
            }

            .sidebar {
                display: none;
                position: fixed;
                top: 55px;
                left: 0;
                width: 100%;
                height: calc(100vh - 55px);
                z-index: 90;
                background: var(--bg-card);
                border-top: 1px solid var(--border);
                overflow-y: auto;
                padding: 16px;
            }

            .sidebar.active {
                display: block !important;
                z-index: 1050;
                /* Above regular content */
                animation: slideInFromLeft 0.3s ease-out;
            }

            @keyframes slideInFromLeft {
                from {
                    transform: translateX(-20px);
                    opacity: 0;
                }

                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            .workspace {
                padding: 12px;
                overflow-y: auto;
            }

            .upload-area {
                padding: 40px 24px;
            }

            .video-canvas-wrapper {
                min-height: 200px;
            }

            #renderCanvas {
                max-height: calc(100vh - 55px - 70px - 24px);
            }

            .video-controls {
                padding: 10px 12px;
                gap: 8px;
            }

            .play-btn,
            .ctrl-btn {
                width: 38px;
                height: 38px;
                font-size: 14px;
                border: none !important;
            }

            .time-display {
                font-size: 11px;
                min-width: 70px;
            }

            .sidebar-section {
                margin-bottom: 16px;
                padding-bottom: 16px;
                border-bottom: 1px solid var(--border);
            }

            .sidebar-section:last-child {
                border-bottom: none;
            }

            /* Modal Mobile */
            .modal {
                padding: 24px 16px;
                border-radius: 20px;
                width: 90%;
            }

            .modal-title {
                font-size: 20px;
            }

            .modal-subtitle {
                font-size: 13px;
                margin-bottom: 20px;
            }

            .modal-spinner {
                width: 40px;
                height: 40px;
                border-width: 3px;
                margin-bottom: 16px;
            }
        }

        @media (max-width: 480px) {
            .effect-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .logo-icon {
                width: 34px;
                height: 34px;
                font-size: 18px;
            }

            .header-status {
                padding: 6px 10px;
            }

            .header-status span {
                font-size: 11px;
            }
        }

        /* People List */
        .people-list {
            max-height: 120px;
        }

        @media (max-width: 767px) {
            .people-list {
                max-height: 60px;
            }

            /* Resize video viewer on mobile to 80% screen height */
            .video-card {
                height: 80vh;
                aspect-ratio: auto;
                /* Allow height to dictate size */
                max-height: 80vh;
            }

            .video-container {
                height: 100%;
                /* Fill the card */
            }
        }

        /* Loading Progress Bar */
        .loading-progress {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
            display: none;
        }

        .loading-progress.active {
            display: block;
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-progress-fill.indeterminate {
            width: 30%;
            animation: indeterminateProgress 1.5s infinite;
        }

        /* AI Status Overlay - Desktop (Bottom Left) */
        .video-overlay-status {
            position: absolute;
            bottom: 24px;
            left: 24px;
            /* transform: translateX(-50%); REMOVED centering */
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            padding: 16px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            width: 280px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            /* Fixed width for consistency on desktop */
        }

        .overlay-params {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            max-height: none;
            overflow: hidden;
        }

        .overlay-slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
        }

        .overlay-slider {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
        }

        .overlay-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            pointer-events: auto;
        }

        .overlay-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            pointer-events: auto;
            border: none;
        }

        .overlay-progress-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .progress-row-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 2px;
        }

        .micro-progress-track {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .video-overlay-status .loading-progress {
            display: none;
            /* Hide old bar */
        }

        .micro-progress-fill {
            height: 100%;
            width: 0%;
            background: var(--primary);
            transition: width 0.3s ease;
        }

        /* Success state */
        .micro-progress-fill.success {
            background: #10b981;
            /* Green */
        }


        @keyframes indeterminateProgress {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(400%);
            }
        }

        .perf-warning {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(234, 179, 8, 0.95);
            color: #000;
            padding: 12px 20px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 700;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: toastIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes toastIn {
            from {
                transform: translate(-50%, -100%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        /* Overlay Controls Styles */
        .overlay-row {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: center;
        }

        .overlay-controls {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 18px;
            padding: 2px;
            gap: 2px;
        }

        /* AI Status Overlay - Default (Desktop: Bottom Left) */
        .video-overlay-status {
            bottom: 24px;
            left: 24px;
            transform: none;
            width: 280px;
            max-width: none;
            padding: 16px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.85);
            /* Overlay styles continue... */
        }

        /* Mobile Adjustments (Centering only on mobile) */
        @media (max-width: 768px) {
            .video-overlay-status {
                bottom: 12px;
                left: 50%;
                transform: translateX(-50%);
                width: 94%;
                max-width: 400px;
                padding: 12px;
                border-radius: 24px;
                background: rgba(0, 0, 0, 0.50) !important;
                /* 50% Translucent */
            }
        }

        .overlay-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .overlay-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .video-overlay-status .status-dot {
            width: 6px;
            height: 6px;
            flex-shrink: 0;
            box-shadow: none;
        }

        .video-overlay-status span {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            margin-left: 6px;
        }

        /* Adjust loading progress inside overlay */
        .video-overlay-status .loading-progress {
            display: none;
        }

        /* Mobile / Responsive Overrides */
        @media (max-width: 768px) {
            .branding-large h1 {
                font-size: 24px !important;
            }

            .branding-large .logo-icon {
                font-size: 36px !important;
            }

            .workspace {
                padding: 0;
            }

            .upload-area {
                padding: 24px;
                margin: 20px;
                max-width: calc(100% - 40px);
                border-width: 1px;
            }

            .video-overlay-status {
                /* Mobile: Centered Bottom "Module" */
                bottom: 12px;
                left: 50%;
                transform: translateX(-50%);
                /* Re-apply centering for mobile */
                width: 94%;
                max-width: 400px;
                padding: 12px;
                gap: 10px;
                border-radius: 24px;
                background: rgba(0, 0, 0, 0.9);
                /* Slightly darker for mobile readability */
            }


            .overlay-controls {
                flex-wrap: wrap;
                /* Allow wrapping if tight */
            }

            .overlay-btn {
                padding: 6px 10px;
                font-size: 10px;
            }

            .video-controls {
                padding: 12px 16px;
                gap: 12px;
            }

            .play-btn,
            .ctrl-btn {
                width: 40px;
                height: 40px;
            }
        }

        /* Overlay collapsed state */
        .video-overlay-status.collapsed .overlay-params,
        .video-overlay-status.collapsed .overlay-progress-container,
        .video-overlay-status.collapsed .overlay-row,
        .video-overlay-status.collapsed .overlay-controls:not(#overlayToggle) {
            display: none !important;
        }

        .video-overlay-status.collapsed {
            padding: 8px;
        }
    </style>
</head>

<body>


    <div class="app">


        <main class="workspace">
            <div id="uploadArea">
                <!-- Desktop Version -->
                <div class="upload-area desktop-only" id="desktopUploadArea">
                    <div class="branding-large"
                        style="margin-bottom: 24px; display: flex; flex-direction: column; align-items: center;">
                        <img src="logo.jpg" alt="Logo" class="logo-icon"
                            style="width: 80px; height: 80px; margin-bottom: 12px; border-radius: 16px; object-fit: cover; box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);">
                        <h1
                            style="font-family: 'Outfit', sans-serif; font-size: 32px; font-weight: 800; background: linear-gradient(to bottom, #fff, #94a3b8); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin: 0;">
                            FaceAnon <span
                                style="font-size: 14px; background: var(--primary) !important; color: #ffffff !important; -webkit-text-fill-color: #ffffff !important; background-clip: initial !important; -webkit-background-clip: initial !important; padding: 4px 8px; border-radius: 6px; vertical-align: middle; margin-left: 6px; font-weight: 800; display: inline-block; line-height: 1;">PRO</span>
                        </h1>
                        <p
                            style="text-align: center; margin: 8px 0 0 0; font-size: 14px; letter-spacing: 2px; text-transform: uppercase; color: var(--text-muted); opacity: 0.8;">
                            for Police</p>
                    </div>
                    <!-- <div class="upload-icon">âœ¨</div> -->
                    <h2 class="upload-title">Empieza con tu Video</h2>
                    <p class="upload-subtitle">
                        Arrastra tu archivo aquÃ­ o usa el botÃ³n para explorar.<br>
                        Formatos soportados: MP4, MOV, WebM.
                    </p>
                    <div class="upload-btn">Abrir Archivo</div>
                </div>

                <!-- Mobile Version -->
                <div class="mobile-upload-area mobile-only" id="mobileUploadArea">
                    <div class="branding-large" style="margin-bottom: 20px; text-align: center;">
                        <img src="logo.jpg" alt="Logo"
                            style="width: 100px; height: 100px; border-radius: 20px; margin-bottom: 16px; box-shadow: 0 8px 30px rgba(99, 102, 241, 0.4);">
                        <h1 style="font-size: 28px; font-weight: 800; margin: 0; color: white;">FaceAnon PRO</h1>
                        <p
                            style="text-align: center; margin: 8px 0 0 0; font-size: 12px; letter-spacing: 2px; text-transform: uppercase; color: rgba(255,255,255,0.6);">
                            for Police</p>
                    </div>

                    <button class="mobile-upload-btn">
                        <span style="font-size: 24px;">ðŸ“‚</span>
                        <span>Tocar para Abrir Video</span>
                    </button>

                    <button id="pwaInstallBtnMobile" class="action-btn"
                        style="margin-top: 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: white; padding: 12px 20px; border-radius: 12px; font-size: 13px; display: none; align-items: center; gap: 8px; width: 100%; max-width: 300px; justify-content: center;">
                        <span>ðŸ“²</span> Instalar como aplicaciÃ³n
                    </button>

                    <p style="margin-top: 24px; font-size: 12px; color: rgba(255,255,255,0.3);">
                        Procesamiento 100% Local y Seguro
                    </p>
                </div>
            </div>

            <div id="videoContainer">
                <div class="video-card">
                    <div class="video-loader" id="videoLoader">
                        <div class="loader-spinner"></div>
                        <div class="loader-text">Cargando video...</div>
                        <div class="loader-progress-track">
                            <div class="loader-progress-fill" id="loaderFill"></div>
                        </div>
                    </div>
                    <div class="video-canvas-wrapper">
                        <canvas id="renderCanvas"></canvas>
                    </div>

                    <!-- AI Status Overlay -->
                    <div class="video-overlay-status" id="aiStatus">
                        <!-- Toggle Button -->
                        <button id="overlayToggle" class="overlay-btn"
                            style="width: 100%; margin-bottom: 8px; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; padding: 6px 14px; position: relative;">
                            <span id="overlayToggleText"
                                style="display: flex; align-items: center; gap: 8px; font-weight: 700;">âš™ï¸
                                Controles</span>
                            <span id="toggleIcon"
                                style="font-size: 14px; opacity: 0.7; position: absolute; right: 14px; top: 50%; transform: translateY(-50%);">âŒ„</span>
                        </button>

                        <!-- Model Selection -->
                        <div id="modelSelection">
                            <div
                                style="display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 4px;">
                                <div style="font-size: 10px; color: rgba(255,255,255,0.8);">Modelo de Inteligencia
                                    Artificial de DetecciÃ³n de Rostros:</div>
                                <div class="overlay-controls" style="padding: 1px;">
                                    <button class="overlay-btn active" data-model="auto"
                                        style="margin: 0; padding: 2px 10px; font-size: 9px; min-width: auto; height: auto;">Auto</button>
                                </div>
                            </div>
                            <div class="overlay-controls" style="flex-wrap: wrap; justify-content: center;">
                                <button class="overlay-btn" data-model="ssd">SSD</button>
                                <button class="overlay-btn" data-model="tiny">Tiny</button>
                                <button class="overlay-btn" data-model="mobile">Mobile</button>
                            </div>
                        </div>

                        <!-- Model Description -->
                        <div id="modelDescription"
                            style="font-size: 9px; color: rgba(255,255,255,0.7); text-align: left; margin-top: 6px; min-height: 48px; line-height: 1.4; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                            SelecciÃ³n automÃ¡tica inteligente segÃºn tu dispositivo.
                        </div>

                        <!-- Status Info -->
                        <div class="overlay-row">
                            <div class="status-dot"></div>
                            <span id="mainStatusText">Iniciando...</span>
                        </div>

                        <!-- Dual Progress Bars -->
                        <div class="overlay-progress-container">
                            <!-- Detector -->
                            <div>
                                <div class="progress-row-label">
                                    <span>Detector</span>
                                    <span id="detStatusText">0%</span>
                                </div>
                                <div class="micro-progress-track">
                                    <div class="micro-progress-fill" id="detFill"></div>
                                </div>
                            </div>
                            <!-- Recognition -->
                            <div>
                                <div class="progress-row-label">
                                    <span>Reconocimiento</span>
                                    <span id="recStatusText">Pendiente</span>
                                </div>
                                <div class="micro-progress-track">
                                    <div class="micro-progress-fill" id="recFill"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Parameters (Moved from Sidebar) -->
                        <div class="overlay-params">
                            <div style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px;">Efecto:
                            </div>
                            <div class="overlay-controls" id="effectSelection" style="justify-content: center;">
                                <button class="overlay-btn active" data-effect="pixelate">Pixel</button>
                                <button class="overlay-btn" data-effect="blur">Blur</button>
                                <button class="overlay-btn" data-effect="solid">Solid</button>
                            </div>

                            <div
                                style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px; margin-top: 8px;">
                                Intensidad:</div>
                            <div class="overlay-slider-row">
                                <input type="range" class="overlay-slider" id="intensity" min="5" max="50" value="15"
                                    style="flex: 1;">
                                <span id="intensityVal">15</span>
                            </div>
                            <div
                                style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px; margin-top: 8px;">
                                Margen:</div>
                            <div class="overlay-slider-row">
                                <input type="range" class="overlay-slider" id="paddingSlider" min="0" max="100"
                                    value="10" style="flex: 1;">
                                <span id="paddingVal">10%</span>
                            </div>

                            <!-- Trim Controls - Dual Range Slider -->
                            <div
                                style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px; margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                                Rango de Tiempo:</div>
                            <div style="position: relative; padding: 0 8px; margin: 8px 0;">
                                <!-- Track background -->
                                <div
                                    style="position: relative; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px;">
                                    <!-- Active range highlight -->
                                    <div id="trimRangeHighlight"
                                        style="position: absolute; height: 100%; background: var(--primary); border-radius: 2px; left: 0%; width: 100%;">
                                    </div>
                                </div>
                                <!-- Dual sliders overlapped -->
                                <input type="range" class="overlay-slider" id="trimStartSlider" min="0" max="100"
                                    value="0" step="0.1"
                                    style="position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; background: transparent;">
                                <input type="range" class="overlay-slider" id="trimEndSlider" min="0" max="100"
                                    value="100" step="0.1"
                                    style="position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; background: transparent;">
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; font-size: 9px; color: rgba(255,255,255,0.6); padding: 0 8px;">
                                <span id="trimStartVal">0.0s</span>
                                <span id="trimEndVal">Fin</span>
                            </div>

                            <!-- Action Buttons (New) -->
                            <div class="overlay-actions" style="display: flex; gap: 8px; margin-top: 4px;">
                                <button class="action-btn" id="processBtn" disabled
                                    style="flex: 1; background: var(--primary); color: white; padding: 6px; border-radius: 8px; font-size: 11px; font-weight: 600; border: none; cursor: pointer;">
                                    âš¡ Procesar
                                </button>
                                <button class="action-btn" id="exportBtn" disabled
                                    style="flex: 1; background: var(--bg-hover); color: white; padding: 6px; border-radius: 8px; font-size: 11px; font-weight: 600; border: 1px solid var(--border); cursor: pointer;">
                                    ðŸ’¾ Guardar
                                </button>
                            </div>

                            <!-- New Video (Moved from Sidebar) -->
                            <button id="newBtn"
                                style="width: 100%; background: transparent; border: 1px solid rgba(255,255,255,0.1); color: rgba(255,255,255,0.7); padding: 6px; border-radius: 8px; font-size: 11px; cursor: pointer; margin-top: 4px;">
                                ðŸ“ Abrir Otro Video
                            </button>

                            <!-- PWA Install inside settings -->
                            <button id="pwaInstallBtnSettings"
                                style="width: 100%; background: rgba(99, 102, 241, 0.1); border: 1px solid var(--primary); color: var(--primary-light); padding: 8px; border-radius: 8px; font-size: 10px; cursor: pointer; margin-top: 12px; display: none; align-items: center; justify-content: center; gap: 6px; font-weight: 700;">
                                ðŸ“² INSTALAR APP (SÃ­n Barras)
                            </button>
                        </div>
                    </div>
                </div>

                <div class="video-controls">
                    <button class="ctrl-btn" id="rewindBtn" title="AtrÃ¡s 1s">âˆ’1s</button>
                    <button class="play-btn" id="playBtn">â–¶</button>
                    <button class="ctrl-btn" id="forwardBtn" title="Adelante 1s">+1s</button>
                    <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
                    <div class="progress-track" id="progressTrack">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
            </div>
    </div>
    </main>
    </div>

    <input type="file" id="fileInput" accept="video/*">

    <div class="modal-overlay" id="modal">
        <div class="modal">
            <div class="modal-spinner"></div>
            <div class="modal-title" id="modalTitle">Procesando</div>
            <div class="modal-subtitle" id="modalSubtitle">Preparando...</div>
            <div class="modal-progress">
                <div class="modal-progress-fill" id="modalFill"></div>
            </div>
            <div class="modal-percent" id="modalPercent">0%</div>

            <!-- Success Keys -->
            <div class="modal-actions" id="modalActions"
                style="display: none; flex-direction: row; gap: 12px; margin-top: 8px;">
                <button class="upload-btn" id="btnDownload" style="flex: 1; border: none; cursor: pointer;">
                    ðŸ’¾ Guardar
                </button>
                <button class="upload-btn" id="btnShare"
                    style="flex: 1; background: var(--bg-hover); border: 1px solid var(--border); cursor: pointer;">
                    ðŸ“¤ Compartir
                </button>
            </div>

            <button class="modal-cancel" id="cancelBtn">Cancelar</button>
        </div>
    </div>

    <script>
        // App State
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

        const state = {
            effect: 'pixelate',
            intensity: 15,
            padding: 0.1, // 10% por defecto
            detectionMode: 'all',
            trimStart: 0,
            trimEnd: null, // null means end of video
            previewMode: 'effects', // ALWAYS effects
            processedBlob: null,
            videoBlobUrl: null,
            isPlaying: false,
            isProcessing: false,
            processingCanceled: false,
            modelReady: false,
            recognitionReady: false,
            detectorType: null,
            modelPreference: 'auto', // Use Auto by default
            videoWidth: 0,
            videoHeight: 0,
            lastKnownFaces: [],
            knownFaces: [], // { id, descriptor, name, excluded }
            trackingEnabled: true,
            highlightedPersonId: null,
            previewPersistenceCount: 0,
            isLoadingModel: false,
            perfWarningShown: false
        };

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW Registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('SW Registration failed:', error);
                    });
            });
        }

        // PWA Installation Handler
        let deferredPrompt;
        const installBtnMobile = document.getElementById('pwaInstallBtnMobile');
        const installBtnSettings = document.getElementById('pwaInstallBtnSettings');

        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later.
            deferredPrompt = e;
            // Update UI to notify the user they can add to home screen
            if (installBtnMobile) installBtnMobile.style.display = 'flex';
            if (installBtnSettings) installBtnSettings.style.display = 'flex';
        });

        async function handleInstallClick() {
            if (!deferredPrompt) {
                // FALLBACK for iOS: Inform user how to add manually
                if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    alert('ðŸ“² Para instalar FaceAnon en tu iPhone:\n\n1. Pulsa el botÃ³n "Compartir" (el cuadrado con flecha abajo).\n2. Selecciona "AÃ±adir a pantalla de inicio".\n\nÂ¡Listo! PodrÃ¡s usarla sin barras de navegaciÃ³n.');
                }
                return;
            }
            // Show the prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`User responded to the install prompt: ${outcome}`);
            // We've used the prompt, and can't use it again, throw it away
            deferredPrompt = null;
            // Hide the buttons
            if (installBtnMobile) installBtnMobile.style.display = 'none';
            if (installBtnSettings) installBtnSettings.style.display = 'none';
        }

        if (installBtnMobile) installBtnMobile.addEventListener('click', handleInstallClick);
        if (installBtnSettings) installBtnSettings.addEventListener('click', handleInstallClick);

        // Show install button for iOS users specifically (since they don't trigger beforeinstallprompt)
        if (/iPhone|iPad|iPod/.test(navigator.userAgent) && !window.navigator.standalone) {
            if (installBtnMobile) installBtnMobile.style.display = 'flex';
            if (installBtnSettings) installBtnSettings.style.display = 'flex';
        }

        // DOM Elements
        const elements = {
            uploadArea: document.getElementById('uploadArea'),
            fileInput: document.getElementById('fileInput'),
            videoContainer: document.getElementById('videoContainer'),
            renderCanvas: document.getElementById('renderCanvas'),
            renderCtx: document.getElementById('renderCanvas').getContext('2d'),
            playBtn: document.getElementById('playBtn'),
            progressFill: document.getElementById('progressFill'),
            progressTrack: document.getElementById('progressTrack'),
            timeDisplay: document.getElementById('timeDisplay'),
            intensitySlider: document.getElementById('intensity'),
            intensityVal: document.getElementById('intensityVal'),
            paddingSlider: document.getElementById('paddingSlider'),
            paddingVal: document.getElementById('paddingVal'),
            processBtn: document.getElementById('processBtn'),
            exportBtn: document.getElementById('exportBtn'),
            newBtn: document.getElementById('newBtn'),
            modal: document.getElementById('modal'),
            modalFill: document.getElementById('modalFill'),
            modalPercent: document.getElementById('modalPercent'),
            modalTitle: document.getElementById('modalTitle'),
            modalSubtitle: document.getElementById('modalSubtitle'),
            aiStatus: document.getElementById('aiStatus'),
            cancelBtn: document.getElementById('cancelBtn'),
            effectOptions: document.querySelectorAll('#effectSelection button'),
            modelBtns: document.querySelectorAll('#modelSelection button'),
            menuToggle: document.getElementById('menuToggle'),
            sidebar: document.querySelector('.sidebar'),
            peopleList: document.getElementById('peopleList'),
            rewindBtn: document.getElementById('rewindBtn'),
            forwardBtn: document.getElementById('forwardBtn')
        };

        const FACE_RECOGNITION_THRESHOLD = 0.5; // Distancia para considerar la misma persona

        // Video element (created dynamically)
        const video = document.createElement('video');
        video.muted = true;
        video.playsInline = true;
        // Optimization for mobile: "In-View" strategy.
        // We make it 1x1, nearly transparent, and fixed at top-left.
        // This forces the OS to treat it as "visible" and render frames, preventing hangs during seek/detection.
        video.style.position = 'fixed';
        video.style.top = '0';
        video.style.left = '0';
        video.style.width = '10px';
        video.style.height = '10px';
        video.style.opacity = '0.001';
        video.style.pointerEvents = 'none';
        video.style.zIndex = '-1000';
        video.style.visibility = 'visible'; // Important!

        // Critical Attributes for iOS
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.setAttribute('preload', 'auto');

        document.body.appendChild(video);

        // Processing canvas
        const processCanvas = document.createElement('canvas');
        document.body.appendChild(processCanvas);

        // Initialize
        async function init() {
            // Register Service Worker for offline support
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(reg => console.log('SW Registered!', reg))
                        .catch(err => console.log('SW Registration failed:', err));
                });
            }

            setupEventListeners();
            await loadAI();
        }

        // Load AI Model with local files priority
        // Progress Helpers
        function updateModelStatus(type, percent, text) {
            const fill = document.getElementById(`${type}Fill`);
            const status = document.getElementById(`${type}StatusText`);
            if (fill) {
                fill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
                if (percent >= 100) fill.classList.add('success');
            }
            if (status) status.textContent = text;
        }

        async function downloadWithProgress(url, onProgress) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const contentLength = +response.headers.get('Content-Length');
                const reader = response.body.getReader();
                let receivedLength = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    receivedLength += value.length;

                    if (contentLength) {
                        onProgress((receivedLength / contentLength) * 100);
                    }
                }
            } catch (e) {
                // Ignore errors here
            }
        }

        async function prefetchFiles(baseUrl, files, updateFn) {
            let completed = 0;
            const total = files.length;

            for (const file of files) {
                updateFn((completed / total) * 100, `Descargando ${file.split('_')[0]}...`);
                await downloadWithProgress(`${baseUrl}${file}`, (pct) => {
                    const totalPct = ((completed + (pct / 100)) / total) * 100;
                    updateFn(totalPct, `Cargando ${Math.round(pct)}%`);
                });
                completed++;
            }
            updateFn(100, 'Procesando...');
        }

        // Load AI Model with local files priority
        async function loadAI() {
            // 1. Load Face-API Script
            if (typeof faceapi === 'undefined') {
                try {
                    const script = document.createElement('script');
                    script.src = './js/face-api.js';
                    document.head.appendChild(script);
                    await new Promise(r => script.onload = r);
                    await new Promise(r => setTimeout(r, 500));
                } catch (e) {
                    console.error('Failed to load face-api source');
                }
            }

            if (typeof faceapi === 'undefined') {
                document.getElementById('mainStatusText').innerText = 'Error: Face-API no cargÃ³';
                return;
            }

            const modelUrls = [
                './models/',
                'https://justadudewhohacks.github.io/face-api.js/models/'
            ];

            let loadedModel = null;

            if (state.isLoadingModel) return;
            state.isLoadingModel = true;

            // Desactivar botones durante la carga
            if (elements.modelBtns) elements.modelBtns.forEach(b => b.disabled = true);

            const statusEl = document.getElementById('mainStatusText');
            if (statusEl) statusEl.innerText = 'Iniciando Motores IA...';

            // --- STAGE 1: DETECTOR ---
            const modelPref = state.modelPreference;
            const useAuto = modelPref === 'auto';

            let detectorType = modelPref;
            if (useAuto) {
                detectorType = isMobile ? 'tiny' : 'ssd';
            }

            updateModelStatus('det', 0, 'Iniciando...');

            // Load based on selected model
            try {
                if (detectorType === 'mobile') {
                    // BlazeFace (Ultra Light for Mobile)
                    updateModelStatus('det', 30, 'Cargando Mobile...');
                    if (typeof blazeface !== 'undefined') {
                        window.blazeDetector = await blazeface.load();
                        loadedModel = 'mobile';
                        updateModelStatus('det', 100, 'Mobile Listo');
                    } else {
                        throw new Error('Script Mobile no cargado');
                    }
                } else if (detectorType === 'tiny') {
                    // Tiny Face Detector
                    const tinyFiles = ['tiny_face_detector_model-weights_manifest.json', 'tiny_face_detector_model-shard1'];
                    for (const modelUrl of modelUrls) {
                        try {
                            await prefetchFiles(modelUrl, tinyFiles, (pct, text) => updateModelStatus('det', pct, text));
                            await faceapi.nets.tinyFaceDetector.loadFromUri(modelUrl);
                            loadedModel = 'tiny';
                            updateModelStatus('det', 100, 'Tiny Listo');
                            break;
                        } catch (e) {
                            console.warn('Tiny fallback', e);
                        }
                    }
                } else {
                    // SSD MobileNet (default)
                    const ssdFiles = ['ssd_mobilenetv1_model-weights_manifest.json', 'ssd_mobilenetv1_model-shard1', 'ssd_mobilenetv1_model-shard2'];
                    for (const modelUrl of modelUrls) {
                        try {
                            await prefetchFiles(modelUrl, ssdFiles, (pct, text) => updateModelStatus('det', pct, text));
                            await faceapi.nets.ssdMobilenetv1.loadFromUri(modelUrl);
                            loadedModel = 'ssd';
                            updateModelStatus('det', 100, 'SSD Listo');
                            break;
                        } catch (e) {
                            console.warn('SSD fallback', e);
                        }
                    }
                }

                if (!loadedModel) {
                    updateModelStatus('det', 0, 'Fallo CrÃ­tico');
                    throw new Error('No detector loaded');
                }

                // Configure Detector
                if (loadedModel === 'ssd') {
                    // OPTIMIZED: Faster SSD with reduced false positives
                    // Higher confidence (0.5) = fewer false detections + faster processing
                    // Lower maxResults (50) = less computation overhead
                    window.faceDetector = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5, maxResults: 50 });
                } else if (loadedModel === 'tiny') {
                    // Optimized input size for mobile performance vs accuracy
                    const tSize = isMobile ? 320 : 512;
                    window.faceDetector = new faceapi.TinyFaceDetectorOptions({ inputSize: tSize, scoreThreshold: 0.3 });
                } else if (loadedModel === 'mobile') {
                    window.faceDetector = null; // Uses blazeDetector
                }
                state.detectorType = loadedModel;

                // --- STAGE 2: RECOGNITION ---
                const recogFiles = [
                    'face_landmark_68_model-weights_manifest.json', 'face_landmark_68_model-shard1',
                    'face_recognition_model-weights_manifest.json', 'face_recognition_model-shard1', 'face_recognition_model-shard2'
                ];

                updateModelStatus('rec', 0, 'Pendiente...');
                state.recognitionReady = false;

                for (const modelUrl of modelUrls) {
                    try {
                        await prefetchFiles(modelUrl, recogFiles, (pct, text) => updateModelStatus('rec', pct, text));

                        await faceapi.nets.faceLandmark68Net.loadFromUri(modelUrl);
                        await faceapi.nets.faceRecognitionNet.loadFromUri(modelUrl);

                        state.recognitionReady = true;
                        updateModelStatus('rec', 100, 'Reconocimiento Listo');
                        break;
                    } catch (e) {
                        console.warn('Recog fallback', e);
                    }
                }

                if (!state.recognitionReady) {
                    updateModelStatus('rec', 0, 'No Disponible');
                }

                // Finalize
                state.modelReady = true;
                const modelNames = {
                    'ssd': 'SSD Precision',
                    'tiny': 'Tiny Fast',
                    'mobile': 'Mobile Ultra'
                };
                const modelName = modelNames[state.detectorType] || state.detectorType || 'Cargando...';
                const statusStr = `IA Lista (${modelName})`;
                if (statusEl) statusEl.innerText = statusStr;
                updateAIStatus(true);

            } catch (err) {
                console.error('loadAI failed:', err);
                updateAIStatus(false);
                const statusEl = document.getElementById('mainStatusText');
                if (statusEl) statusEl.innerText = 'Error al cargar IA';
            } finally {
                state.isLoadingModel = false;
                if (elements.modelBtns) elements.modelBtns.forEach(b => b.disabled = false);
            }
        }

        function updateAIStatus(ready) {
            const dot = elements.aiStatus.querySelector('.status-dot');
            const span = document.getElementById('mainStatusText');
            const progress = document.getElementById('aiProgress');

            if (ready) {
                dot.classList.add('ready');
                const modelNames = {
                    'ssd': 'SSD Precision',
                    'tiny': 'Tiny Fast',
                    'mobile': 'Mobile Ultra'
                };
                const modelName = modelNames[state.detectorType] || state.detectorType || 'Cargando...';
                span.textContent = `IA Lista (${modelName})`;
                // Hide progress bar when ready
                if (progress) progress.classList.remove('active');
                if (state.videoWidth > 0) {
                    elements.processBtn.disabled = false;
                }
            } else {
                dot.classList.remove('ready');
                span.textContent = 'IA No disp.';
                if (progress) progress.classList.remove('active');
            }
        }

        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('aiProgressFill');
            if (progressBar) {
                progressBar.classList.remove('indeterminate');
                progressBar.style.width = percent + '%';
            }
        }

        // File Handling
        function handleFileSelect(e) {
            const file = e.target.files ? e.target.files[0] : null;
            if (file) loadVideo(file);
        }

        function handleDrop(e) {
            e.preventDefault();
            if (elements.uploadArea) elements.uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) loadVideo(file);
        }

        function loadVideo(file) {
            // Validate type
            if (file.type.indexOf('video') === -1) {
                alert('Por favor selecciona un archivo de video vÃ¡lido.');
                return;
            }

            // Show loader
            if (elements.uploadArea) elements.uploadArea.style.display = 'none';
            if (elements.videoLoader) elements.videoLoader.classList.add('active');

            // Reset App
            if (typeof resetAppState === 'function') resetAppState();

            // Load
            const url = URL.createObjectURL(file);
            video.src = url;
            video.muted = false; // Enable audio for preview
            video.volume = 1.0;
            video.load();

            video.onloadeddata = () => {
                state.videoWidth = video.videoWidth;
                state.videoHeight = video.videoHeight;

                if (elements.renderCanvas) {
                    elements.renderCanvas.width = state.videoWidth;
                    elements.renderCanvas.height = state.videoHeight;
                }
                processCanvas.width = state.videoWidth;
                processCanvas.height = state.videoHeight;

                console.log(`Video loaded: ${state.videoWidth}x${state.videoHeight}`);

                if (elements.videoContainer) elements.videoContainer.classList.add('active');

                // Force multiple renders to ensure frame is captured
                const forceRender = () => {
                    if (typeof renderFrame === 'function') renderFrame();
                };

                requestAnimationFrame(forceRender);
                setTimeout(forceRender, 100);
                setTimeout(forceRender, 500);

                setTimeout(() => {
                    if (elements.videoLoader) elements.videoLoader.classList.remove('active');
                }, 600);

                if (typeof updateTimeDisplay === 'function') updateTimeDisplay();

                if (elements.processBtn) elements.processBtn.disabled = !state.modelReady;
            };

            video.onerror = () => {
                alert('Error al cargar el video.');
                if (elements.uploadArea) elements.uploadArea.style.display = 'block';
                if (elements.videoLoader) elements.videoLoader.classList.remove('active');
            };
        }

        // Event Listeners
        function setupEventListeners() {
            console.log('Setting up event listeners...');

            // Menu Toggle
            if (elements.menuToggle && elements.sidebar) {
                elements.menuToggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    elements.sidebar.classList.toggle('active');
                });
            }

            // Upload
            if (elements.uploadArea && elements.fileInput) {
                elements.uploadArea.addEventListener('click', () => elements.fileInput.click());
                elements.fileInput.addEventListener('change', handleFileSelect);
            }

            // Drag and drop
            elements.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.uploadArea.classList.add('dragover');
            });
            elements.uploadArea.addEventListener('dragleave', () => {
                elements.uploadArea.classList.remove('dragover');
            });
            elements.uploadArea.addEventListener('drop', handleDrop);

            // Playback
            elements.playBtn.addEventListener('click', togglePlay);
            elements.progressTrack.addEventListener('click', seek);
            elements.rewindBtn.addEventListener('click', () => {
                video.currentTime = Math.max(0, video.currentTime - 1);
                updateProgress();
            });
            elements.forwardBtn.addEventListener('click', () => {
                video.currentTime = Math.min(video.duration, video.currentTime + 1);
                updateProgress();
            });

            // Intensity
            elements.intensitySlider.addEventListener('input', (e) => {
                state.intensity = parseInt(e.target.value);
                elements.intensityVal.textContent = state.intensity;
            });

            // Effect selection
            elements.effectOptions.forEach(option => {
                option.addEventListener('click', () => {
                    elements.effectOptions.forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    state.effect = option.dataset.effect;
                    renderFrame();
                });
            });



            // Model preference with descriptions
            const modelDescriptions = {
                'auto': '<b>MODO INTELIGENTE:</b> El sistema analiza tu hardware y elige el mejor balance entre velocidad y precisiÃ³n automÃ¡ticamente.',
                'ssd': '<b>MODELO SSD (PRO):</b><br>â€¢ <b>Sirve para:</b> MÃ¡xima precisiÃ³n legal. Caras lejanas, perfiles y condiciones de poca luz.<br>â€¢ <b>No sirve para:</b> MÃ³viles antiguos (mucho calor/lentitud).<br>â€¢ <b>Sugerencia:</b> Ãšsalo para el procesado final antes de descargar.',
                'tiny': '<b>MODELO TINY (RÃPIDO):</b><br>â€¢ <b>Sirve para:</b> Uso diario Ã¡gil. Caras a media distancia y seguimiento estable.<br>â€¢ <b>No sirve para:</b> Vigilancia masiva con caras muy pequeÃ±as al fondo.<br>â€¢ <b>Sugerencia:</b> La mejor opciÃ³n para editar rÃ¡pido en mÃ³viles modernos.',
                'mobile': '<b>MODELO MOBILE (LIGERO):</b><br>â€¢ <b>Sirve para:</b> Ahorro de baterÃ­a y fluidez total en hardware limitado o antiguo.<br>â€¢ <b>No sirve para:</b> Escenas con sujetos lejanos o movimientos muy bruscos.<br>â€¢ <b>Sugerencia:</b> Ãšsalo si solo necesitas tapar caras en planos cercanos.'
            };

            elements.modelBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    elements.modelBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.modelPreference = btn.dataset.model;

                    // Update description
                    const descEl = document.getElementById('modelDescription');
                    if (descEl) descEl.innerHTML = modelDescriptions[state.modelPreference] || '';

                    // Forzar recarga de IA con la nueva preferencia
                    state.modelReady = false;
                    updateAIStatus(false);
                    try {
                        await loadAI();
                    } catch (e) {
                        console.error('Error al cambiar de modelo:', e);
                        state.isLoadingModel = false;
                        elements.modelBtns.forEach(b => b.disabled = false);
                    }
                });
            });

            // Padding slider
            elements.paddingSlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                state.padding = val / 100;
                elements.paddingVal.textContent = val + '%';
                renderFrame();
            });



            // Preview toggle removed - always effects
            // const previewOriginal = document.getElementById('previewOriginal');
            // const previewEffects = document.getElementById('previewEffects');

            // Process video
            elements.processBtn.addEventListener('click', processVideo);

            // Export
            elements.exportBtn.addEventListener('click', exportVideo);

            // New video
            // Nuevo Video button - open file selector
            elements.newBtn.addEventListener('click', () => {
                elements.fileInput.click();
            });

            // Cancel processing / Close Modal
            elements.cancelBtn.addEventListener('click', () => {
                if (state.isProcessing) {
                    console.log('User requested cancellation');
                    state.processingCanceled = true;
                    // Force immediate stop of video and hidden elements
                    video.pause();
                    elements.modal.classList.remove('active');
                    state.isProcessing = false;
                } else {
                    // Close modal if finished
                    elements.modal.classList.remove('active');
                    // Reset text for next time
                    elements.cancelBtn.textContent = 'Cancelar';
                }
            });

            // Overlay Toggle
            const overlayToggle = document.getElementById('overlayToggle');
            if (overlayToggle) {
                overlayToggle.addEventListener('click', () => {
                    const overlay = document.getElementById('aiStatus');
                    overlay.classList.toggle('collapsed');
                    const isCollapsed = overlay.classList.contains('collapsed');
                    const toggleIcon = document.getElementById('toggleIcon');
                    const toggleText = document.getElementById('overlayToggleText');

                    if (toggleIcon) toggleIcon.textContent = isCollapsed ? 'âŒƒ' : 'âŒ„';
                    // Text remains static: 'âš™ï¸ Controles'
                });
            }

            // Trim Controls with Dual Range Slider
            const trimStartSlider = document.getElementById('trimStartSlider');
            const trimEndSlider = document.getElementById('trimEndSlider');
            const trimStartVal = document.getElementById('trimStartVal');
            const trimEndVal = document.getElementById('trimEndVal');
            const trimRangeHighlight = document.getElementById('trimRangeHighlight');

            function updateRangeHighlight() {
                if (!trimStartSlider || !trimEndSlider || !trimRangeHighlight) return;
                const max = parseFloat(trimStartSlider.max);
                const startPercent = (parseFloat(trimStartSlider.value) / max) * 100;
                const endPercent = (parseFloat(trimEndSlider.value) / max) * 100;

                trimRangeHighlight.style.left = startPercent + '%';
                trimRangeHighlight.style.width = (endPercent - startPercent) + '%';
            }

            if (trimStartSlider && trimEndSlider) {
                // Update slider max values when video loads
                video.addEventListener('loadedmetadata', () => {
                    const duration = video.duration;
                    trimStartSlider.max = duration;
                    trimEndSlider.max = duration;
                    trimEndSlider.value = duration;
                    trimEndVal.textContent = duration.toFixed(1) + 's';
                    updateRangeHighlight();
                });

                trimStartSlider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.trimStart = val;
                    trimStartVal.textContent = val.toFixed(1) + 's';

                    // Ensure start doesn't exceed end
                    if (state.trimStart >= state.trimEnd) {
                        state.trimStart = Math.max(0, state.trimEnd - 0.1);
                        trimStartSlider.value = state.trimStart;
                        trimStartVal.textContent = state.trimStart.toFixed(1) + 's';
                    }

                    updateRangeHighlight();
                });

                trimEndSlider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.trimEnd = val;
                    trimEndVal.textContent = val.toFixed(1) + 's';

                    // Ensure end doesn't go below start
                    if (state.trimEnd <= state.trimStart) {
                        state.trimEnd = Math.min(video.duration, state.trimStart + 0.1);
                        trimEndSlider.value = state.trimEnd;
                        trimEndVal.textContent = state.trimEnd.toFixed(1) + 's';
                    }

                    updateRangeHighlight();
                });
            }

            // Reset Trim when loading new video (handled in resetAppState)

            video.addEventListener('timeupdate', updateProgress);

            // Video ended - Stop detection loop
            video.addEventListener('ended', () => {
                state.isPlaying = false;
                elements.playBtn.textContent = 'â–¶';
                stopPreviewLoop();
                console.log('Video ended: Stopped detection loop');
            });

            // Universal Seek Update: Update effect/detection whenever time changes (manual seek)
            video.addEventListener('seeked', () => {
                resetTracking(); // Reset tracking history on seek
                if (video.paused && state.modelReady && !state.isProcessing) {
                    applyEffects();
                }
            });

            // Mobile Menu
            if (elements.menuToggle) {
                elements.menuToggle.addEventListener('click', () => {
                    elements.sidebar.classList.toggle('active');
                    elements.menuToggle.textContent = elements.sidebar.classList.contains('active') ? 'âœ•' : 'â˜°';
                });
            }

            // Cerrar sidebar en mÃ³vil tras seleccionar
            const closeSidebarOnMobile = () => {
                if (window.innerWidth < 768) {
                    elements.sidebar.classList.remove('active');
                    elements.menuToggle.textContent = 'â˜°';
                }
            };

            elements.effectOptions.forEach(opt => opt.addEventListener('click', closeSidebarOnMobile));
            elements.modelBtns.forEach(opt => opt.addEventListener('click', closeSidebarOnMobile));
        }

        // File handling
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) loadVideo(file);
        }

        function handleDrop(e) {
            e.preventDefault();
            elements.uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideo(file);
            }
        }

        function loadVideo(file) {
            // RESET APP STATE when loading new video
            resetAppState();

            // Show loading state
            elements.uploadArea.style.display = 'none';
            elements.videoContainer.classList.add('active');
            document.body.classList.add('video-active');
            const loader = document.getElementById('videoLoader');
            if (loader) loader.classList.add('active');

            if (state.videoBlobUrl) {
                URL.revokeObjectURL(state.videoBlobUrl);
            }

            // Small delay to allow UI to update and show loader if file is large
            setTimeout(() => {
                state.videoBlobUrl = URL.createObjectURL(file);
                video.src = state.videoBlobUrl;
            }, 50);

            video.onloadedmetadata = () => {
                state.videoWidth = video.videoWidth;
                state.videoHeight = video.videoHeight;

                // Setup canvases
                elements.renderCanvas.width = state.videoWidth;
                elements.renderCanvas.height = state.videoHeight;
                processCanvas.width = state.videoWidth;
                processCanvas.height = state.videoHeight;

                console.log('Video cargado:', state.videoWidth, 'x', state.videoHeight);

                // Hide loader with delay
                if (loader) {
                    setTimeout(() => {
                        loader.classList.remove('active');
                    }, 500);
                }

                // Show video container (redundant but safe)
                elements.uploadArea.style.display = 'none';
                elements.videoContainer.classList.add('active');

                // Force canvas visibility
                elements.renderCanvas.style.visibility = 'visible';
                elements.renderCanvas.style.display = 'block';

                // Update UI
                updateTimeDisplay();
                renderFrame();

                // Enable process button if AI is ready
                if (state.modelReady) {
                    elements.processBtn.disabled = false;
                }
            };
        }

        function resetTracking() {
            state.lastKnownFaces = [];
            state.smoothedBoxes = {};
            state.previewPersistenceCount = 0;
            lastDetectionTime = 0; // Ensure next detection runs immediately
            isDetecting = false; // Force unlock detection in case it got stuck
        }

        // Reset app state when loading new video
        function resetAppState() {
            // Stop playback
            if (!video.paused) {
                video.pause();
                stopPreviewLoop();
            }

            // Reset state
            state.isPlaying = false;
            state.isProcessing = false;
            state.processingCanceled = false;
            state.processedBlob = null;
            state.lastKnownFaces = [];
            state.knownFaces = [];
            state.smoothedBoxes = {};
            state.highlightedPersonId = null;
            state.previewPersistenceCount = 0;
            state.highlightedPersonId = null;
            state.previewPersistenceCount = 0;
            state.previewMode = 'effects'; // Always reset to effects

            // Reset Trim
            state.trimStart = 0;
            state.trimEnd = null;
            if (document.getElementById('btnTrimStart')) {
                document.getElementById('btnTrimStart').textContent = 'In: 0.0s';
                document.getElementById('btnTrimStart').classList.remove('active');
                document.getElementById('btnTrimEnd').textContent = 'Out: Fin';
                document.getElementById('btnTrimEnd').classList.remove('active');
            }

            // Reset UI
            elements.playBtn.textContent = 'â–¶';
            elements.processBtn.disabled = true;
            elements.exportBtn.disabled = true;

            // Clear people list
            if (elements.peopleList) {
                elements.peopleList.innerHTML = '<p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">Reproduce el vÃ­deo para listar personas...</p>';
            }

            // Reset preview buttons (Removed)
            /*
            const previewOriginal = document.getElementById('previewOriginal');
            const previewEffects = document.getElementById('previewEffects');
            if (previewOriginal && previewEffects) {
                previewOriginal.classList.add('active');
                previewEffects.classList.remove('active');
            }
            */

            document.body.classList.remove('video-active');
            console.log('App state reset for new video');
        }

        // Playback controls
        function togglePlay() {
            if (video.paused) {
                // If video ended, restart from beginning
                if (video.ended || video.currentTime >= video.duration) {
                    video.currentTime = 0;
                }

                resetTracking(); // Reset tracking on play start
                video.play();
                state.isPlaying = true;
                elements.playBtn.textContent = 'â¸';
                startPreviewLoop();
            } else {
                video.pause();
                state.isPlaying = false;
                elements.playBtn.textContent = 'â–¶';
                stopPreviewLoop();
            }
        }

        function updateProgress() {
            const progress = (video.currentTime / video.duration) * 100;
            elements.progressFill.style.width = progress + '%';
            updateTimeDisplay();
        }

        function updateTimeDisplay() {
            const current = formatTime(video.currentTime);
            const total = formatTime(video.duration || 0);
            elements.timeDisplay.textContent = `${current} / ${total}`;
        }

        function seek(e) {
            const rect = elements.progressTrack.getBoundingClientRect();
            const position = (e.clientX - rect.left) / rect.width;
            video.currentTime = position * video.duration;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Preview loop
        let previewRequestId = null;

        function startPreviewLoop() {
            let lastTime = 0;
            const updateInterval = 0; // Force frame-by-frame update everywhere as requested

            function loop(timestamp) {
                if (!state.isPlaying) return;

                if (!timestamp) timestamp = performance.now();

                if (timestamp - lastTime >= updateInterval) {
                    renderFrame();
                    lastTime = timestamp;
                }
                previewRequestId = requestAnimationFrame(loop);
            }
            previewRequestId = requestAnimationFrame(loop);
        }

        function stopPreviewLoop() {
            if (previewRequestId) {
                cancelAnimationFrame(previewRequestId);
                previewRequestId = null;
            }
        }

        // Render frame
        function renderFrame() {
            if (!state.videoWidth) return;

            try {
                // 1. Draw original video
                elements.renderCtx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);

                // 2. Continuous Background Detection (async, doesn't block rendering)
                // Run detection when playing OR when video is loaded and ready
                if ((state.isPlaying || state.videoWidth > 0) && !state.isProcessing) {
                    runBackgroundDetection();
                }

                // 3. ALWAYS draw effects if we have cached faces and we're in effects mode
                // This ensures NO frames are skipped, even while detection is running
                // 3. ALWAYS draw effects if we have cached faces and we're in effects mode
                // This ensures NO frames are skipped, even while detection is running
                if (!state.isProcessing) {
                    // Always draw effects using last known detections
                    drawCachedEffects(); // Draw everything (effects + highlights)
                }
            } catch (e) {
                console.error('Render error:', e);
            }
        }

        let isDetecting = false;
        let lastDetectionTime = 0;
        let detectStartTime = 0; // Watchdog timer
        const DETECTION_INTERVAL = isMobile ? 60 : 30; // 60ms mobile (~15fps), 30ms desktop (~30fps) for fluid playback

        async function runBackgroundDetection() {
            // Watchdog: If detection takes > 2s, force reset
            if (isDetecting && (Date.now() - detectStartTime > 2000)) {
                console.warn('Watchdog: Force resetting stuck detection');
                isDetecting = false;
            }

            if (isDetecting || !state.modelReady) {
                if (!state.modelReady) {
                    // console.warn('Detection skipped: Model not ready');
                }
                return;
            }

            // Intelligent Throttle: Ensures UI thread has time to render video smoothly
            const now = Date.now();
            if (now - lastDetectionTime < DETECTION_INTERVAL) {
                return;
            }
            lastDetectionTime = now;
            detectStartTime = now; // For watchdog

            isDetecting = true;
            try {
                console.log('Running face detection...');

                // Use full detection if recognition is ready, otherwise basic
                let detections;

                // Handle Mobile / BlazeFace separately
                if (state.detectorType === 'mobile' && window.blazeDetector) {
                    const predictions = await window.blazeDetector.estimateFaces(video, false);
                    detections = predictions.map(pred => ({
                        detection: {
                            box: {
                                x: pred.topLeft[0],
                                y: pred.topLeft[1],
                                width: pred.bottomRight[0] - pred.topLeft[0],
                                height: pred.bottomRight[1] - pred.topLeft[1]
                            },
                            score: pred.probability ? pred.probability[0] : 0.9
                        },
                        identity: null
                    }));
                } else if (!state.recognitionReady) {
                    // Basic detection (faster, no recognition)
                    detections = await faceapi.detectAllFaces(video, window.faceDetector);
                    // Convert to format expected by rest of code
                    detections = detections.map(d => ({
                        detection: d,
                        identity: null
                    }));
                } else {
                    // Full detection with recognition
                    detections = await faceapi.detectAllFaces(video, window.faceDetector)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                    detections = await identifyFaces(detections);
                }

                console.log(`Detected ${detections.length} faces`);

                // Aplicar suavizado de cajas
                const refined = detections.map(d => {
                    const smoothed = smoothBoundingBox(d);
                    return { ...d, smoothedBox: smoothed };
                });

                if (refined.length > 0) {
                    state.lastKnownFaces = filterFaces(refined);
                    // Much longer persistence on mobile/desktop to prevent gaps
                    state.previewPersistenceCount = isMobile ? 60 : 45;
                } else if (state.previewPersistenceCount > 0) {
                    state.previewPersistenceCount--;
                    // Keep using cached faces - this prevents frame gaps
                } else {
                    // Only clear faces after persistence expires
                    state.lastKnownFaces = [];
                }
            } catch (e) {
                console.error('Background detection error:', e);
            } finally {
                const duration = Date.now() - detectStartTime;
                isDetecting = false;

                // PERFORMANCE MONITORING
                if (!state.isProcessing && !state.perfWarningShown && duration > (isMobile ? 1200 : 800)) {
                    if (state.detectorType === 'ssd' || (state.detectorType === 'tiny' && isMobile)) {
                        showPerformanceWarning();
                        state.perfWarningShown = true;
                    }
                }
            }
        }

        function showPerformanceWarning() {
            const warning = document.createElement('div');
            warning.className = 'perf-warning';
            const msg = isMobile ? 'âš ï¸ Sistema lento: Prueba el modelo "Mobile" para mayor fluidez.' : 'âš ï¸ Rendimiento bajo: Prueba el modelo "Tiny" o "Mobile" para ir mÃ¡s rÃ¡pido.';
            warning.innerHTML = msg;
            document.body.appendChild(warning);
            setTimeout(() => {
                warning.style.opacity = '0';
                warning.style.transition = 'opacity 0.8s ease';
                setTimeout(() => warning.remove(), 800);
            }, 6000);
        }

        // EMA Smoothing logic to eliminate jitter for exact tracking
        // ADAPTIVE Smoothing logic for exact tracking
        function smoothBoundingBox(detection) {
            const rawBox = detection.detection.box;
            const personId = detection.identity ? (detection.identity.id || 'unknown') : 'unknown';

            if (!state.smoothedBoxes) state.smoothedBoxes = {};
            const prev = state.smoothedBoxes[personId] || rawBox;

            // Compute velocity/distance to adapt smoothing
            const dist = Math.sqrt(Math.pow(rawBox.x - prev.x, 2) + Math.pow(rawBox.y - prev.y, 2));

            // Dynamic Factor: 
            // - If moving fast (>15px): use high factor (0.95) for zero-lag tracking
            // - If still: use low factor (0.4) for rock-solid stability
            let factor = 0.4;
            if (dist > 15) factor = 0.95;
            else if (dist > 5) factor = 0.7;

            // Apply smoothing for all 4 corners for exact fit
            const smoothed = {
                x: prev.x + (rawBox.x - prev.x) * factor,
                y: prev.y + (rawBox.y - prev.y) * factor,
                width: prev.width + (rawBox.width - prev.width) * factor,
                height: prev.height + (rawBox.height - prev.height) * factor
            };

            state.smoothedBoxes[personId] = smoothed;
            return smoothed;
        }

        function drawTrackingBorders() {
            drawCachedEffects(false);
        }

        function drawCachedEffects(showEffects = true) {
            if (state.lastKnownFaces.length === 0) return;

            const scaleX = state.videoWidth / video.videoWidth;
            const scaleY = state.videoHeight / video.videoHeight;
            const padding = state.padding;

            state.lastKnownFaces.forEach(face => {
                // Priorizar la caja suavizada para un tracking "exacto" y fluido
                const box = face.smoothedBox || (face.detection ? face.detection.box : null);
                if (!box) return;

                const x = Math.max(0, (box.x - (box.width * padding)) * scaleX);
                const y = Math.max(0, (box.y - (box.height * padding)) * scaleY);
                const w = Math.min(state.videoWidth - x, (box.width * (1 + padding * 2)) * scaleX);
                const h = Math.min(state.videoHeight - y, (box.height * (1 + padding * 2)) * scaleY);

                // 1. Aplicar efecto si NO estÃ¡ excluido y estamos en modo efectos
                if (showEffects && !(face.identity && face.identity.excluded)) {
                    if (state.effect === 'pixelate') {
                        pixelateArea(elements.renderCtx, x, y, w, h);
                    } else if (state.effect === 'blur') {
                        blurArea(elements.renderCtx, x, y, w, h);
                    } else {
                        solidArea(elements.renderCtx, x, y, w, h);
                    }
                }

                // 2. Dibujar indicadores visuales de detecciÃ³n
                const ctx = elements.renderCtx;

                // Borde blanco sutil para todos los detectados (Feedback de que la IA los ve)
                ctx.save();
                if (isMobile && !showEffects) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                }
                ctx.strokeRect(x, y, w, h);
                ctx.restore();

                // 3. Dibujar borde rojo fuerte si estÃ¡ destacado (hover/click)
                if (face.identity && face.identity.id === state.highlightedPersonId) {
                    ctx.save();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, w, h);

                    // PequeÃ±a etiqueta
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.fillText(face.identity.name, x, y - 5);
                    ctx.restore();
                }
            });
        }

        // Match detected faces with known identities
        async function identifyFaces(detections) {
            const results = [];

            for (const detection of detections) {
                let bestMatch = null;
                let minDistance = FACE_RECOGNITION_THRESHOLD;

                if (detection.descriptor) {
                    state.knownFaces.forEach(known => {
                        const distance = faceapi.euclideanDistance(detection.descriptor, known.descriptor);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMatch = known;
                        }
                    });
                }

                // Fallback Espacial Estricto: si no hay match por biometrÃ­a, buscamos por posiciÃ³n previa cercana
                if (!bestMatch) {
                    const box = detection.detection.box;
                    // Lowered tolerance to 10% of width for extreme precision
                    let minSpatialDist = video.videoWidth * 0.1;
                    state.knownFaces.forEach(known => {
                        if (known.lastPos) {
                            const dist = Math.sqrt(Math.pow(box.x - known.lastPos.x, 2) + Math.pow(box.y - known.lastPos.y, 2));
                            if (dist < minSpatialDist) {
                                minSpatialDist = dist;
                                bestMatch = known;
                            }
                        }
                    });
                }

                if (!bestMatch && detection.descriptor) {
                    // New identity found
                    const newId = `Persona ${state.knownFaces.length + 1}`;
                    const newPerson = {
                        id: Date.now() + Math.random(),
                        name: newId,
                        descriptor: detection.descriptor,
                        excluded: false,
                        lastPos: detection.detection.box
                    };
                    state.knownFaces.push(newPerson);
                    bestMatch = newPerson;
                    renderPeopleList();
                }

                if (bestMatch) {
                    bestMatch.lastPos = detection.detection.box;
                    // Actualizar descriptor si el nuevo es de mejor calidad? (Omitido por ahora para estabilidad)
                }

                results.push({
                    detection: detection.detection,
                    descriptor: detection.descriptor,
                    identity: bestMatch
                });
            }
            return results;
        }

        // Render People List
        function renderPeopleList() {
            if (!elements.peopleList) return;

            if (state.knownFaces.length === 0) {
                elements.peopleList.innerHTML = '<p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">Reproduce el vÃ­deo para listar personas...</p>';
                return;
            }

            elements.peopleList.innerHTML = state.knownFaces.map(person => `
                <div class="person-item ${person.excluded ? 'excluded' : ''} ${state.highlightedPersonId === person.id ? 'active' : ''}" 
                     data-id="${person.id}">
                    <div class="person-avatar" style="background-image: url('${person.avatar || ''}')">
                        ${!person.avatar ? 'ðŸ‘¤' : ''}
                    </div>
                    <div class="person-info">
                        <div class="person-name">Persona ${person.id.toString().substr(-4)}</div>
                        <div class="person-status">${person.excluded ? 'Ignorado' : 'Detectado'}</div>
                    </div>
                    <div class="person-actions">
                        <button class="action-btn toggle-btn" title="${person.excluded ? 'Incluir' : 'Excluir'}">
                            ${person.excluded ? 'ðŸ‘' : 'ðŸš«'}
                        </button>
                    </div>
                </div>
            `).join('');

            // Add listeners
            document.querySelectorAll('.person-item').forEach(item => {
                item.addEventListener('mouseenter', () => state.highlightedPersonId = parseFloat(item.dataset.id));
                item.addEventListener('mouseleave', () => state.highlightedPersonId = null);

                const toggleBtn = item.querySelector('.toggle-btn');
                toggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseFloat(item.dataset.id);
                    const person = state.knownFaces.find(p => p.id === id);
                    if (person) {
                        person.excluded = !person.excluded;
                        renderPeopleList();
                    }
                });
            });
        }

        // Apply effects (used mainly for paused/immediate updates)
        async function applyEffects() {
            if (isDetecting || !state.modelReady) return;

            // 1. Draw Updated Video Frame First!
            if (state.videoWidth) {
                elements.renderCtx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);
            }

            // 2. Detect & Draw
            await runBackgroundDetection();
            drawCachedEffects();
        }

        function filterFaces(detections) {
            if (!detections) return [];
            return detections.filter(d => {
                const score = (d.detection && d.detection.score) ? d.detection.score : 0.5;
                const box = (d.detection && d.detection.box) ? d.detection.box : null;
                if (!box) return false;
                // Minimum size to avoid noise
                const minDim = Math.min(video.videoWidth, video.videoHeight) * 0.005;
                // Threshold: Ultra precision requires higher confidence for SSD
                const minScore = state.detectorType === 'ssd' ? 0.4 : 0.25;
                return score > minScore && box.width > minDim && box.height > minDim;
            });
        }

        // Dedicated off-screen canvas for effects (re-used to save memory/GC)
        const fxCanvas = document.createElement('canvas');
        const fxCtx = fxCanvas.getContext('2d');

        function pixelateArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;
            const size = Math.max(1, Math.floor(w / state.intensity));

            fxCanvas.width = size;
            fxCanvas.height = size;
            fxCtx.imageSmoothingEnabled = false;

            // Draw downscaled to FX canvas
            fxCtx.drawImage(ctx.canvas, x, y, w, h, 0, 0, size, size);

            // Draw back upscaled
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(fxCanvas, 0, 0, size, size, x, y, w, h);
        }

        function blurArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;

            // Optimization: Use a larger capture area to avoid edge bleeding
            const bleed = Math.round(state.intensity * 2);
            const cx = Math.max(0, x - bleed);
            const cy = Math.max(0, y - bleed);
            const cw = Math.min(ctx.canvas.width - cx, w + bleed * 2);
            const ch = Math.min(ctx.canvas.height - cy, h + bleed * 2);

            fxCanvas.width = cw;
            fxCanvas.height = ch;

            // 1. Capture original (No filter yet)
            fxCtx.drawImage(ctx.canvas, cx, cy, cw, ch, 0, 0, cw, ch);

            // 2. Draw back to main with filter active
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip(); // Keep blur inside the box

            ctx.filter = `blur(${state.intensity}px)`;
            ctx.drawImage(fxCanvas, cx, cy);
            ctx.restore();
        }

        function solidArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;
            ctx.fillStyle = '#000000';
            ctx.fillRect(x, y, w, h);
        }

        // Process video
        // Global for Analysis Data to save memory
        let analysisData = [];

        // SINGLE-PASS VIDEO PROCESSING
        // Combines analysis and rendering in one frame-by-frame loop for mobile stability

        async function analyzeAndRenderVideoPass(startTime, endTime) {
            return new Promise(async (resolve, reject) => {
                // Setup canvas and recorder
                processingChunks = [];
                const canvas = document.createElement('canvas');
                canvas.width = state.videoWidth;
                canvas.height = state.videoHeight;
                const ctx = canvas.getContext('2d', { willReadFrequently: false });

                // Audio Setup - Use 30fps for mobile compatibility
                let stream = canvas.captureStream(30);
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        // Use or create audio context
                        if (!window.audioCtxGlobal) window.audioCtxGlobal = new AudioContext();
                        const audioCtx = window.audioCtxGlobal;
                        if (audioCtx.state === 'suspended') await audioCtx.resume();

                        // Create or reuse audio source
                        let audioSource = video._audioSourceNode;
                        if (!audioSource) {
                            try {
                                audioSource = audioCtx.createMediaElementSource(video);
                                video._audioSourceNode = audioSource;
                                console.log('âœ“ Created new audio source');
                            } catch (e) {
                                console.warn('Could not create audio source:', e);
                            }
                        }

                        // Connect audio to recording stream
                        if (audioSource) {
                            const dest = audioCtx.createMediaStreamDestination();
                            audioSource.connect(dest);
                            audioSource.connect(audioCtx.destination); // Also to speakers

                            if (dest.stream.getAudioTracks().length > 0) {
                                stream.addTrack(dest.stream.getAudioTracks()[0]);
                                console.log('âœ“ Audio track added to stream');
                            }
                        }
                    }
                } catch (e) { console.warn('Audio setup warning:', e); }

                // Setup MediaRecorder
                let mimeType = 'video/webm;codecs=vp9,opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm';
                if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/mp4';

                const recorder = new MediaRecorder(stream, { mimeType: mimeType, videoBitsPerSecond: 8000000 });
                recorder.ondataavailable = e => { if (e.data.size > 0) processingChunks.push(e.data); };

                const finalizeExport = () => {
                    if (state.processedBlob) {
                        console.log('Already finalized, skipping');
                        resolve();
                        return;
                    }

                    console.log(`Creating blob from ${processingChunks.length} chunks`);

                    try {
                        if (processingChunks.length === 0) {
                            reject(new Error('No hay datos de video - la grabaciÃ³n fallÃ³'));
                            return;
                        }

                        const blob = new Blob(processingChunks, { type: recorder.mimeType });
                        console.log(`âœ“ Blob created: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);

                        state.processedBlob = blob;
                        if (stream) stream.getTracks().forEach(t => t.stop());

                        console.log('âœ“ Export finalized successfully');
                        resolve();
                    } catch (e) {
                        console.error('Finalization error:', e);
                        reject(e);
                    }
                };

                recorder.onstop = () => {
                    console.log('Recording stopped');
                    finalizeExport();
                };

                recorder.start(100);

                // Processing variables
                const duration = endTime - startTime;
                const fps = 30; // Fixed 30fps for smooth output
                const frameTime = 1 / fps;
                let currentTime = startTime;
                const startRealTime = performance.now();

                // BLOCK PROCESSING for memory management
                const BLOCK_DURATION = 5.0; // Process in 5-second blocks
                let blockStartTime = startTime;

                // Tracking state
                let activeTracks = [];
                let nextTrackId = 1;
                const MAX_PERSISTENCE = 60;

                // Seek helper
                const seekTo = (t) => new Promise(resolve => {
                    if (Math.abs(video.currentTime - t) < 0.01) {
                        resolve();
                        return;
                    }
                    let resolved = false;
                    const finish = () => {
                        if (resolved) return;
                        resolved = true;
                        video.removeEventListener('seeked', finish);
                        resolve();
                    };
                    setTimeout(finish, 100);
                    video.addEventListener('seeked', finish, { once: true });
                    video.currentTime = t;
                });

                // Main processing loop with block GC
                try {
                    while (currentTime < endTime && !state.processingCanceled) {
                        // Check if we need a GC pause (every 5 seconds)
                        if (currentTime - blockStartTime >= BLOCK_DURATION) {
                            // Yield to main thread for garbage collection (50ms optimization)
                            await new Promise(r => setTimeout(r, 50));
                            blockStartTime = currentTime;
                        }

                        await seekTo(currentTime);

                        // 1. DETECT FACES
                        let detections = [];
                        try {
                            if (state.detectorType === 'mobile' && window.blazeDetector) {
                                const predictions = await window.blazeDetector.estimateFaces(video, false, false, false);
                                detections = predictions.map(pred => ({
                                    detection: {
                                        box: {
                                            x: pred.topLeft[0],
                                            y: pred.topLeft[1],
                                            width: pred.bottomRight[0] - pred.topLeft[0],
                                            height: pred.bottomRight[1] - pred.topLeft[1]
                                        },
                                        score: pred.probability ? pred.probability[0] : 0.9
                                    },
                                    identity: null
                                }));
                            } else if (window.faceDetector) {
                                detections = await faceapi.detectAllFaces(video, window.faceDetector);
                                detections = detections.map(d => ({ detection: d, identity: null }));
                            }
                        } catch (e) {
                            // Silent fail for detection errors to keep video smooth
                        }

                        let faces = filterFaces(detections);

                        // 2. TRACK FACES
                        const usedDetections = new Set();
                        activeTracks.forEach(track => {
                            let bestMatch = null;
                            let maxIoU = 0.3;
                            faces.forEach((face, idx) => {
                                if (usedDetections.has(idx)) return;
                                const dBox = face.detection.box;
                                const xA = Math.max(track.box.x, dBox.x);
                                const yA = Math.max(track.box.y, dBox.y);
                                const xB = Math.min(track.box.x + track.box.width, dBox.x + dBox.width);
                                const yB = Math.min(track.box.y + track.box.height, dBox.y + dBox.height);
                                const interW = Math.max(0, xB - xA);
                                const interH = Math.max(0, yB - yA);
                                const interArea = interW * interH;
                                const unionArea = (track.box.width * track.box.height) + (dBox.width * dBox.height) - interArea;
                                const iou = interArea / unionArea;
                                if (iou > maxIoU) {
                                    maxIoU = iou;
                                    bestMatch = { face, idx };
                                }
                            });
                            if (bestMatch) {
                                track.box = bestMatch.face.detection.box;
                                track.lastSeen = 0;
                                usedDetections.add(bestMatch.idx);
                            } else {
                                track.lastSeen++;
                            }
                        });

                        faces.forEach((face, idx) => {
                            if (!usedDetections.has(idx)) {
                                activeTracks.push({
                                    id: nextTrackId++,
                                    box: face.detection.box,
                                    lastSeen: 0,
                                    excluded: false
                                });
                            }
                        });

                        activeTracks = activeTracks.filter(t => t.lastSeen < MAX_PERSISTENCE);

                        // 3. RENDER WITH EFFECTS
                        // CRITICAL: Always draw video first (even if no faces detected)
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);

                        // Apply effects to detected/tracked faces
                        const padding = state.padding;
                        activeTracks.forEach(track => {
                            if (!track || !track.box) return; // Safety check

                            const box = track.box;
                            // Use box directly if smoothBoundingBox fails
                            let smoothed;
                            try {
                                smoothed = smoothBoundingBox({ detection: { box } }) || box;
                            } catch (e) {
                                smoothed = box;
                            }

                            const x = Math.max(0, smoothed.x - (smoothed.width * padding));
                            const y = Math.max(0, smoothed.y - (smoothed.height * padding));
                            const w = Math.min(state.videoWidth - x, smoothed.width * (1 + padding * 2));
                            const h = Math.min(state.videoHeight - y, smoothed.height * (1 + padding * 2));

                            if (w > 0 && h > 0) {
                                if (state.effect === 'pixelate') pixelateArea(ctx, x, y, w, h);
                                else if (state.effect === 'blur') blurArea(ctx, x, y, w, h);
                                else solidArea(ctx, x, y, w, h);
                            }
                        });

                        // 4. UPDATE UI
                        const elapsedVideo = currentTime - startTime;
                        const progress = Math.round((elapsedVideo / duration) * 100);

                        let etaText = '';
                        if (elapsedVideo > 1) {
                            const elapsedReal = performance.now() - startRealTime;
                            const remaining = duration - elapsedVideo;
                            const eta = (remaining / elapsedVideo) * elapsedReal;
                            if (eta < 60000) {
                                etaText = ` (~${Math.ceil(eta / 1000)}s)`;
                            } else {
                                etaText = ` (~${Math.floor(eta / 60000)}m ${Math.ceil((eta % 60000) / 1000)}s)`;
                            }
                        }

                        const effectName = state.effect === 'pixelate' ? 'Pixelando' : (state.effect === 'blur' ? 'Difuminando' : 'Ocultando');
                        const statusText = activeTracks.length > 0
                            ? `${effectName} ${activeTracks.length} rostro${activeTracks.length > 1 ? 's' : ''}`
                            : 'Codificando';

                        elements.modalFill.style.width = progress + '%';
                        elements.modalPercent.textContent = progress + '%';
                        elements.modalSubtitle.textContent = `${statusText} (${formatTime(currentTime)} / ${formatTime(endTime)})${etaText}`;

                        currentTime += frameTime;
                    }

                    // Log final frame count for verification
                    const expectedFrames = Math.round(duration * fps);
                    const actualFrames = Math.round((currentTime - startTime) / frameTime);
                    console.log(`Processed ${actualFrames} frames (expected ${expectedFrames}) for ${duration.toFixed(1)}s video at ${fps}fps`);

                    // Finalize
                    if (!state.processingCanceled) {
                        console.log('Finalization starting...');
                        elements.modalSubtitle.textContent = 'Finalizando archivo...';

                        // Request final data from recorder
                        if (recorder.state === 'recording') {
                            recorder.requestData(); // Force flush of buffered data
                            recorder.stop();
                        }

                        // Aggressive fallback - shorter timeout for faster completion
                        setTimeout(() => {
                            if (!state.processedBlob) {
                                console.log('Forcing finalization via timeout');
                                finalizeExport();
                            }
                        }, 500);
                    } else {
                        if (recorder.state === 'recording') recorder.stop();
                        reject(new Error('Cancelado por usuario'));
                    }
                } catch (e) {
                    console.error('Processing error:', e);
                    if (recorder.state === 'recording') recorder.stop();
                    reject(e);
                }
            });
        }


        // Main Process Function - Two Pass System (Analyze -> Render)
        // Main Process Function - Two Pass System (Analyze -> Render)
        // Main Process Function - Two Pass System (Analyze -> Render)
        // NEW VIDEO PROCESSING SYSTEM (v2.0)
        // Robust, Object-Oriented, Mobile-First
        class VideoExportManager {
            constructor(videoElement, state, uiElements) {
                this.video = videoElement;
                this.state = state;
                this.ui = uiElements;
                this.recorder = null;
                this.stream = null;
                this.audioCtx = null;
                this.audioSource = null;
                this.chunks = [];
                this.isProcessing = false;
                this.canceled = false;
            }

            async start() {
                if (this.isProcessing) return;
                this.isProcessing = true;
                this.canceled = false;
                this.chunks = [];

                try {
                    console.log('ðŸŽ¬ Starting Video Export (v2.0)...');

                    // 1. Setup UI
                    this.video.pause();
                    this.ui.modal.classList.add('active');
                    this.ui.processBtn.disabled = true;
                    this.ui.exportBtn.disabled = true;

                    // 2. Setup Resources (Canvas & Audio)
                    const { canvas, ctx, stream } = await this.setupRecordingStream();
                    this.stream = stream;

                    // 3. Setup Recorder
                    await this.setupRecorder(stream);

                    // 4. Processing Loop (The Core)
                    await this.processFrames(canvas, ctx);

                    // 5. Finalize
                    await this.stopRecording();
                    this.showSuccess();

                } catch (error) {
                    if (this.canceled) {
                        console.log('Process canceled by user');
                        this.resetUI('Proceso cancelado');
                    } else {
                        console.error('Export Fatal Error:', error);
                        alert(`Error crÃ­tico durante el procesamiento: ${error.message}`);
                        this.resetUI('Error en procesamiento');
                    }
                } finally {
                    this.cleanup();
                }
            }

            cancel() {
                this.canceled = true;
                if (this.recorder && this.recorder.state === 'recording') {
                    this.recorder.stop();
                }
            }

            async setupRecordingStream() {
                // Determine dimensions
                const width = this.state.videoWidth;
                const height = this.state.videoHeight;

                // Create offline processing canvas
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: false });

                // Create Stream - 30fps fixed for stability
                const stream = canvas.captureStream(30);

                // Audio Setup (Robust)
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.audioCtx = new AudioContext();
                        if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();

                        // Force simple reliable audio
                        this.audioSource = this.audioCtx.createMediaElementSource(this.video);
                        const dest = this.audioCtx.createMediaStreamDestination();

                        this.audioSource.connect(dest);
                        this.audioSource.connect(this.audioCtx.destination); // Let user hear it while processing

                        if (dest.stream.getAudioTracks().length > 0) {
                            stream.addTrack(dest.stream.getAudioTracks()[0]);
                            console.log('âœ“ Audio track attached successfully');
                        }
                    }
                } catch (e) {
                    console.warn('Audio setup warning (continuing without audio):', e);
                }

                return { canvas, ctx, stream };
            }

            async setupRecorder(stream) {
                let options = { mimeType: 'video/webm;codecs=vp9,opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'video/webm' }; // Fallback
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'video/mp4' }; // Safari fallback
                }

                console.log(`Using Recorder MimeType: ${options.mimeType}`);

                this.recorder = new MediaRecorder(stream, {
                    ...options,
                    videoBitsPerSecond: 8000000 // High quality 8Mbps
                });

                this.recorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) {
                        this.chunks.push(e.data);
                    }
                };

                // Start recording
                this.recorder.start(100); // Small slices for memory safety
            }

            async processFrames(canvas, ctx) {
                const duration = this.video.duration;
                // Fixed step 30fps
                const fps = 30;
                const frameTime = 1 / fps;
                let currentTime = 0;

                // Trackers
                this.video.currentTime = 0;
                let activeTracks = [];
                let nextTrackId = 1;

                console.log(`Starting loop: ${duration}s @ ${fps}fps`);

                while (currentTime < duration) {
                    if (this.canceled) throw new Error('Canceled');

                    // 1. Seek
                    await this.seekVideo(currentTime);

                    // 2. Draw base frame
                    ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);

                    // 3. Detect & Track (Only if model ready)
                    if (window.faceDetector || (this.state.detectorType === 'mobile' && window.blazeDetector)) {
                        try {
                            const faces = await this.detectFaces(canvas);
                            activeTracks = this.updateTracks(activeTracks, faces, nextTrackId);
                            // Update ID counter if needed (logic simplified for brevity)
                            if (activeTracks.length > 0) nextTrackId = Math.max(...activeTracks.map(t => t.id)) + 1;
                        } catch (e) { console.warn('Detection error:', e); }
                    }

                    // 4. Render Effects
                    this.renderEffects(ctx, activeTracks);

                    // 5. Update UI
                    this.updateProgress(currentTime, duration, activeTracks.length);

                    // 6. Memory & Loop Control
                    currentTime += frameTime;

                    // GC Pause every 3 seconds
                    if (Math.floor(currentTime) % 3 === 0 && Math.abs(currentTime % 1) < 0.1) {
                        await new Promise(r => setTimeout(r, 20));
                    }
                }
            }

            seekVideo(time) {
                return new Promise(resolve => {
                    const onSeek = () => {
                        this.video.removeEventListener('seeked', onSeek);
                        resolve();
                    };
                    // Timeout safety for mobile
                    setTimeout(onSeek, 800);

                    this.video.addEventListener('seeked', onSeek, { once: true });
                    this.video.currentTime = time;
                });
            }

            async detectFaces(input) {
                // Simplified detection router
                if (this.state.detectorType === 'mobile' && window.blazeDetector) {
                    const preds = await window.blazeDetector.estimateFaces(input, false, false, false);
                    return preds.map(p => ({
                        box: { x: p.topLeft[0], y: p.topLeft[1], width: p.bottomRight[0] - p.topLeft[0], height: p.bottomRight[1] - p.topLeft[1] }
                    }));
                } else if (window.faceDetector) {
                    const detections = await faceapi.detectAllFaces(input, window.faceDetector);
                    return detections.map(d => ({ box: d.box }));
                }
                return [];
            }

            updateTracks(tracks, newDetections, nextId) {
                // Simplified tracker for reliability
                const matched = new Set();
                const updatedTracks = tracks.map(track => {
                    // Find best IoU match
                    let bestMatch = null;
                    let maxIoU = 0.3;

                    newDetections.forEach((det, idx) => {
                        if (matched.has(idx)) return;
                        const iou = getIoU(track.box, det.box);
                        if (iou > maxIoU) {
                            maxIoU = iou;
                            bestMatch = { det, idx };
                        }
                    });

                    if (bestMatch) {
                        matched.add(bestMatch.idx);
                        // Smooth update
                        return {
                            ...track,
                            box: {
                                x: track.box.x * 0.7 + bestMatch.det.box.x * 0.3,
                                y: track.box.y * 0.7 + bestMatch.det.box.y * 0.3,
                                width: track.box.width * 0.7 + bestMatch.det.box.width * 0.3,
                                height: track.box.height * 0.7 + bestMatch.det.box.height * 0.3
                            },
                            lastSeen: 0
                        };
                    } else {
                        return { ...track, lastSeen: track.lastSeen + 1 };
                    }
                });

                // Add new tracks
                newDetections.forEach((det, idx) => {
                    if (!matched.has(idx)) {
                        updatedTracks.push({
                            id: nextId + idx,
                            box: det.box,
                            lastSeen: 0
                        });
                    }
                });

                // Filter dead tracks
                return updatedTracks.filter(t => t.lastSeen < 30); // 1s persistence
            }

            renderEffects(ctx, tracks) {
                const padding = this.state.padding;
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;

                tracks.forEach(track => {
                    const box = track.box;
                    const x = Math.max(0, box.x - (box.width * padding));
                    const y = Math.max(0, box.y - (box.height * padding));
                    const w = Math.min(width - x, box.width * (1 + padding * 2));
                    const h = Math.min(height - y, box.height * (1 + padding * 2));

                    if (w > 0 && h > 0) {
                        if (this.state.effect === 'pixelate') pixelateArea(ctx, x, y, w, h);
                        else if (this.state.effect === 'blur') blurArea(ctx, x, y, w, h);
                        else solidArea(ctx, x, y, w, h);
                    }
                });
            }

            updateProgress(currentTime, duration, facesCount) {
                const pct = Math.round((currentTime / duration) * 100);
                this.ui.modalFill.style.width = `${pct}%`;
                this.ui.modalPercent.textContent = `${pct}%`;
                this.ui.modalSubtitle.textContent = `Procesando: ${formatTime(currentTime)} / ${formatTime(duration)} (${facesCount} caras)`;
            }

            stopRecording() {
                return new Promise((resolve) => {
                    this.ui.modalSubtitle.textContent = 'Finalizando codificaciÃ³n...';
                    console.log('Stopping recorder...');

                    // Handler for stop event
                    this.recorder.onstop = () => {
                        console.log('Recorder stopped. Generating blob...');
                        const blob = new Blob(this.chunks, { type: this.recorder.mimeType });
                        this.state.processedBlob = blob;
                        resolve();
                    };

                    // Validate state and stop
                    if (this.recorder.state === 'recording') {
                        this.recorder.requestData(); // Flush last chunk
                        this.recorder.stop();
                    } else {
                        // Already stopped? resolve immediately
                        resolve();
                    }
                });
            }

            showSuccess() {
                // Trigger global success function if exists, or handle here
                if (typeof showExportSuccess === 'function') {
                    showExportSuccess();
                } else {
                    alert('Video procesado correctamente!');
                    this.ui.modal.classList.remove('active');
                }
            }

            resetUI(msg) {
                this.ui.modalSubtitle.textContent = msg;
                setTimeout(() => {
                    this.ui.modal.classList.remove('active');
                    this.ui.processBtn.disabled = false;
                }, 2000);
            }

            cleanup() {
                this.isProcessing = false;
                this.state.isProcessing = false;

                // Cleanup streams
                if (this.stream) {
                    this.stream.getTracks().forEach(t => t.stop());
                }

                // Restore Video
                this.video.muted = false;
                this.video.volume = 1.0;

                // Re-enable global checks
                window.videoProcessorInstance = null;
            }
        }

        // Global Processor Instance
        let videoProcessor = null;

        async function processVideo() {
            if (state.isProcessing) return;

            // Validate ready state
            if (!state.modelReady) {
                alert('Espere a que carguen los modelos de IA');
                return;
            }

            // Init new processor
            videoProcessor = new VideoExportManager(video, state, elements);

            // Hook Cancel Button
            elements.cancelBtn.onclick = () => {
                if (videoProcessor) videoProcessor.cancel();
            };

            // Start
            await videoProcessor.start();
        }






        // Helper: Intersection over Union
        function getIoU(boxA, boxB) {
            const xA = Math.max(boxA.x, boxB.x);
            const yA = Math.max(boxA.y, boxB.y);
            const xB = Math.min(boxA.x + boxA.width, boxB.x + boxB.width);
            const yB = Math.min(boxA.y + boxA.height, boxB.y + boxB.height);

            const interW = Math.max(0, xB - xA);
            const interH = Math.max(0, yB - yA);
            const interArea = interW * interH;
            const boxAArea = boxA.width * boxA.height;
            const boxBArea = boxB.width * boxB.height;
            return interArea / (boxAArea + boxBArea - interArea);
        }

        // Helper to check if PWA is already installed
        function isPwaInstalled() {
            return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
        }

        // Export Success UI
        function showExportSuccess() {
            try {
                if (!state.processedBlob) {
                    throw new Error('No video blob available');
                }
                elements.modalTitle.textContent = 'Â¡Video Listo!';
                elements.modalSubtitle.textContent = 'Selecciona una opciÃ³n:';

                const fillParent = elements.modalFill.parentElement;
                if (fillParent) fillParent.style.display = 'none';
                if (elements.modalPercent) elements.modalPercent.style.display = 'none';

                const spinner = document.querySelector('.modal-spinner');
                if (spinner) spinner.style.display = 'none';

                elements.cancelBtn.textContent = 'Cerrar';

                const actions = document.getElementById('modalActions');
                if (actions) actions.style.display = 'flex';

                const blobType = state.processedBlob.type || 'video/webm';
                const ext = blobType.includes('mp4') ? 'mp4' : 'webm';

                // Bind Download
                const dlBtn = document.getElementById('btnDownload');
                if (dlBtn) {
                    dlBtn.onclick = () => {
                        const url = URL.createObjectURL(state.processedBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `faceanon_pro_${Date.now()}.${ext}`;
                        a.click();
                        setTimeout(() => URL.revokeObjectURL(url), 10000);
                    };
                }

                // Bind Share
                const shareBtn = document.getElementById('btnShare');
                if (shareBtn) {
                    shareBtn.onclick = async () => {
                        if (navigator.share) {
                            const file = new File([state.processedBlob], `faceanon_${Date.now()}.${ext}`, { type: blobType });
                            try { await navigator.share({ files: [file], title: 'FaceAnon Export' }); } catch (e) { }
                        } else {
                            alert('Compartir no soportado en este dispositivo.');
                        }
                    };
                }

                elements.processBtn.disabled = false;
                elements.exportBtn.disabled = false;

                // Reset Audio/Video for user
                video.muted = false;
                video.volume = 1.0;

            } catch (e) {
                console.error('Error showing export success UI:', e);
                alert('El video se generÃ³ correctamente, pero hubo un error mostrando la interfaz de guardado.');
            }
        }


        // Export video
        function exportVideo() {
            if (!state.processedBlob) {
                alert('Primero procesa un video');
                return;
            }
            const url = URL.createObjectURL(state.processedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `faceanon_${Date.now()}.webm`;
            a.click();
        }

        // Reset app
        function resetApp() {
            video.pause();
            stopPreviewLoop();

            if (state.videoBlobUrl) {
                URL.revokeObjectURL(state.videoBlobUrl);
            }

            state.videoBlobUrl = null;
            state.processedBlob = null;
            state.isPlaying = false;
            state.videoWidth = 0;
            state.videoHeight = 0;
            state.knownFaces = [];
            state.lastKnownFaces = [];
            state.smoothedBoxes = {};
            if (elements.peopleList) {
                elements.peopleList.innerHTML = '<p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">Reproduce el vÃ­deo para listar personas...</p>';
            }

            elements.uploadArea.style.display = 'block';
            elements.videoContainer.classList.remove('active');
            elements.exportBtn.disabled = true;
            elements.processBtn.disabled = true;
            elements.fileInput.value = '';
            elements.progressFill.style.width = '0%';
            elements.timeDisplay.textContent = '0:00 / 0:00';
            elements.playBtn.textContent = 'â–¶';
        }

        // Start app
        init();
    </script>
</body>

</html>