<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FaceAnon Pro</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6366f1">

    <!-- Local Fonts -->
    <link rel="stylesheet" href="css/fonts.css">

    <!-- Face-API Library -->
    <script src="js/face-api.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --primary-glow: rgba(99, 102, 241, 0.4);
            --bg-dark: #09090b;
            --bg-card: #18181b;
            --bg-hover: #27272a;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --border: #27272a;
            --border-hover: #3f3f46;
            --success: #10b981;
            --warning: #f59e0b;
            --glass: rgba(24, 24, 27, 0.8);
        }

        html {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100%;
            overflow-x: hidden;
            letter-spacing: -0.01em;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover);
        }

        /* Header */
        header {
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 38px;
            height: 38px;
            background: linear-gradient(135deg, var(--primary), #a855f7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 0 15px var(--primary-glow);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
        }

        .logo-icon:hover {
            transform: scale(1.05) rotate(5deg);
        }

        .menu-toggle {
            display: none;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            color: white;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .menu-toggle:hover {
            background: var(--border-hover);
        }

        .logo h1 {
            font-family: 'Outfit', sans-serif;
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(to bottom, #fff, #94a3b8);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 14px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            box-shadow: 0 0 8px var(--warning);
            position: relative;
        }

        .status-dot.ready {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .status-dot.ready::after {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 50%;
            border: 2px solid var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }

            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }

        /* Main Layout */
        .app {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 55px);
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-card);
            padding: 20px 16px;
            border-bottom: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 100%;
        }

        @media (max-width: 767px) {
            .sidebar {
                padding: 12px;
            }
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section:last-child {
            margin-bottom: 0;
        }

        @media (max-width: 767px) {
            .sidebar-section {
                margin-bottom: 12px;
            }
        }

        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
            font-weight: 700;
            letter-spacing: 0.05em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        @media (max-width: 767px) {
            .section-title {
                font-size: 10px;
                margin-bottom: 6px;
            }
        }

        /* Buttons */
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
        }

        @media (max-width: 767px) {
            .btn {
                padding: 8px 12px;
                font-size: 13px;
                border-radius: 10px;
            }
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            width: 100%;
            box-shadow: 0 4px 12px var(--primary-glow);
        }

        .btn-primary:not(:disabled):hover {
            background: var(--primary-light);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px var(--primary-glow);
        }

        .btn-secondary {
            background: var(--bg-hover);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(0.5);
        }

        /* Effect Options */
        .effect-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        @media (max-width: 767px) {
            .effect-grid {
                gap: 8px;
            }
        }

        .effect-option {
            padding: 16px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        @media (max-width: 767px) {
            .effect-option {
                padding: 10px 8px;
                border-radius: 8px;
            }
        }

        .effect-option.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.08);
            box-shadow: inset 0 0 0 1px var(--primary);
        }

        .effect-option:hover {
            border-color: var(--border-hover);
            transform: translateY(-2px);
            background: var(--bg-hover);
        }

        .effect-icon {
            font-size: 26px;
            display: block;
            margin-bottom: 6px;
            transition: transform 0.3s;
        }

        .effect-option:hover .effect-icon {
            transform: scale(1.1);
        }

        .effect-name {
            font-size: 13px;
            font-weight: 500;
        }

        /* Slider */
        .slider-wrapper {
            background: rgba(0, 0, 0, 0.1);
            padding: 4px;
            border-radius: 8px;
        }

        @media (max-width: 767px) {
            .slider-wrapper {
                padding: 3px;
                border-radius: 6px;
            }
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
            color: var(--text-muted);
            font-weight: 500;
        }

        @media (max-width: 767px) {
            .slider-header {
                margin-bottom: 6px;
                font-size: 11px;
            }
        }

        #intensityVal,
        #paddingVal {
            color: var(--primary-light);
            font-weight: 700;
            font-family: monospace;
        }

        .slider {
            width: 100%;
            height: 6px;
            background: var(--bg-dark);
            border-radius: 6px;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border: 3px solid var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            background: var(--primary);
        }

        /* Detection/Tracking */
        .mode-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mode-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-option:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);
        }

        .mode-option.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.08);
            box-shadow: inset 0 0 0 1px var(--primary);
        }

        .mode-icon {
            font-size: 18px;
            opacity: 0.8;
        }

        .mode-name {
            font-size: 14px;
            font-weight: 500;
            flex: 1;
        }

        .mode-check {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            transition: all 0.2s;
            opacity: 0.5;
        }

        .mode-option.active .mode-check {
            background: var(--primary);
            border-color: var(--primary);
            opacity: 1;
        }

        /* Preview Toggle */
        .preview-toggle {
            display: flex;
            gap: 8px;
        }

        @media (max-width: 767px) {
            .preview-toggle {
                gap: 6px;
            }
        }

        .preview-btn {
            flex: 1;
            padding: 8px 6px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        @media (max-width: 767px) {
            .preview-btn {
                padding: 6px 4px;
                font-size: 11px;
                border-radius: 6px;
            }
        }

        .preview-btn:hover {
            border-color: var(--primary);
        }

        .preview-btn.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
            color: var(--text);
        }

        /* Workspace */
        .workspace {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
            background-image:
                radial-gradient(circle at 2px 2px, rgba(255, 255, 255, 0.03) 1px, transparent 0);
            background-size: 40px 40px;
            position: relative;
            overflow: hidden;
            /* No scroll */
        }

        /* Upload Area */
        .upload-area {
            width: 100%;
            max-width: 440px;
            padding: 60px 40px;
            border: 2px dashed var(--border);
            border-radius: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-card);
            box-shadow: var(--shadow-lg);
        }

        @media (max-width: 767px) {
            .upload-area {
                padding: 40px 20px;
                max-width: 100%;
                border-radius: 16px;
            }
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.03);
            transform: scale(1.01);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .upload-title {
            font-family: 'Outfit', sans-serif;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .upload-subtitle {
            color: var(--text-muted);
            font-size: 15px;
            margin-bottom: 28px;
            line-height: 1.5;
        }

        .upload-btn {
            display: inline-block;
            padding: 14px 32px;
            background: var(--primary);
            color: white;
            border-radius: 12px;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px var(--primary-glow);
        }

        /* Video Container */
        #videoContainer {
            display: none;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #videoContainer.active {
            display: block;
        }

        .video-card {
            background: var(--bg-card);
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid var(--border);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            max-height: 100%;
            position: relative;
            /* For loader overlay */
        }

        .video-loader {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .video-loader.active {
            opacity: 1;
            pointer-events: all;
        }

        .loader-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }

        .loader-text {
            color: var(--text-muted);
            font-size: 14px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .video-canvas-wrapper {
            position: relative;
            width: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            max-height: calc(100vh - 55px - 70px - 60px);
            /* viewport - header - controls - padding */
            overflow: hidden;
        }

        #renderCanvas {
            max-width: 100%;
            height: auto;
            max-height: 70vh;
            display: block;
            object-fit: contain;
        }

        /* Video Controls */
        .video-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 24px;
            background: rgba(24, 24, 27, 0.95);
            backdrop-filter: blur(8px);
            border-top: 1px solid var(--border);
        }

        .play-btn,
        .ctrl-btn {
            width: 44px;
            height: 44px;
            background: var(--primary);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .play-btn:hover,
        .ctrl-btn:hover {
            transform: scale(1.05);
            background: var(--primary-light);
        }

        .ctrl-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
            padding: 0 10px;
        }

        .time-display {
            font-family: 'Inter', monospace;
            font-size: 13px;
            color: var(--text-muted);
            min-width: 100px;
            letter-spacing: 0.05em;
        }

        .progress-track {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: height 0.2s;
        }

        .progress-track:hover {
            height: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            width: 0%;
            border-radius: 4px;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .progress-track:hover .progress-fill::after {
            opacity: 1;
        }

        /* Header Actions */
        .header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            padding: 8px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
        }

        /* Modal Redesign */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 24px;
        }

        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            max-width: 420px;
            width: 100%;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .modal-spinner {
            width: 56px;
            height: 56px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .modal-title {
            font-family: 'Outfit', sans-serif;
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .modal-subtitle {
            color: var(--text-muted);
            font-size: 15px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .modal-progress {
            height: 10px;
            background: var(--bg-dark);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 16px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .modal-progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--primary-light), #a855f7);
            background-size: 200% 100%;
            animation: moveGradient 2s linear infinite;
            width: 0%;
            transition: width 0.3s ease;
        }

        @keyframes moveGradient {
            0% {
                background-position: 100% 0;
            }

            100% {
                background-position: -100% 0;
            }
        }

        .modal-percent {
            font-family: 'Inter', monospace;
            font-size: 18px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 24px;
        }

        .modal-cancel {
            padding: 10px 24px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 10px;
            color: #ef4444;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-cancel:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }

        #fileInput {
            display: none;
        }

        /* Responsive Layouts */
        @media (min-width: 1024px) {
            .app {
                flex-direction: row;
            }

            .sidebar {
                width: 320px;
                height: calc(100vh - 55px);
                border-bottom: none;
                border-right: 1px solid var(--border);
                overflow-y: auto;
                flex-shrink: 0;
            }

            .workspace {
                padding: 48px;
            }
        }

        @media (max-width: 1023px) {
            .sidebar {
                padding: 20px;
            }

            .sidebar-section {
                margin-bottom: 24px;
            }
        }

        @media (max-width: 767px) {
            header {
                padding: 12px 16px;
            }

            .logo h1 {
                display: none;
            }

            .menu-toggle {
                display: block;
            }

            .sidebar {
                display: none;
                position: fixed;
                top: 55px;
                left: 0;
                width: 100%;
                height: calc(100vh - 55px);
                z-index: 90;
                background: var(--bg-card);
                border-top: 1px solid var(--border);
                overflow-y: auto;
                padding: 16px;
            }

            .sidebar.active {
                display: block;
                animation: slideInFromLeft 0.3s ease-out;
            }

            @keyframes slideInFromLeft {
                from {
                    transform: translateX(-20px);
                    opacity: 0;
                }

                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            .workspace {
                padding: 12px;
                overflow-y: auto;
            }

            .upload-area {
                padding: 40px 24px;
            }

            .video-canvas-wrapper {
                min-height: 200px;
            }

            #renderCanvas {
                max-height: calc(100vh - 55px - 70px - 24px);
            }

            .video-controls {
                padding: 10px 12px;
                gap: 8px;
            }

            .play-btn,
            .ctrl-btn {
                width: 38px;
                height: 38px;
                font-size: 14px;
            }

            .time-display {
                font-size: 11px;
                min-width: 70px;
            }

            .sidebar-section {
                margin-bottom: 16px;
                padding-bottom: 16px;
                border-bottom: 1px solid var(--border);
            }

            .sidebar-section:last-child {
                border-bottom: none;
            }
        }

        @media (max-width: 480px) {
            .effect-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .logo-icon {
                width: 34px;
                height: 34px;
                font-size: 18px;
            }

            .header-status {
                padding: 6px 10px;
            }

            .header-status span {
                font-size: 11px;
            }
        }

        /* People List */
        .people-list {
            max-height: 120px;
        }

        @media (max-width: 767px) {
            .people-list {
                max-height: 60px;
            }
        }

        /* Loading Progress Bar */
        .loading-progress {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
            display: none;
        }

        .loading-progress.active {
            display: block;
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-progress-fill.indeterminate {
            width: 30%;
            animation: indeterminateProgress 1.5s infinite;
        }

        /* AI Status Overlay */
        .video-overlay-status {
            position: absolute;
            bottom: 80px;
            /* Above controls */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            padding: 8px 16px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 5;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            max-width: 90%;
            white-space: nowrap;
        }

        .video-overlay-status .status-dot {
            width: 8px;
            height: 8px;
            flex-shrink: 0;
            box-shadow: none;
            /* Simplificado para overlay */
        }

        .video-overlay-status span {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        /* Adjust loading progress inside overlay */
        .video-overlay-status .loading-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            margin: 0;
            height: 2px;
            border-radius: 0 0 20px 20px;
            width: 100%;
        }

        @keyframes indeterminateProgress {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(400%);
            }
        }

        /* Overlay Controls Styles */
        .overlay-row {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: center;
        }

        .overlay-controls {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 18px;
            padding: 2px;
            gap: 2px;
        }

        .overlay-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .overlay-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .video-overlay-status .status-dot {
            width: 6px;
            height: 6px;
            flex-shrink: 0;
            box-shadow: none;
        }

        .video-overlay-status span {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            margin-left: 6px;
        }

        /* Adjust loading progress inside overlay */
        .video-overlay-status .loading-progress {
            display: none;
            /* Hide old bar */
        }
    </style>
</head>

<body>
    <header>
        <div class="logo">
            <button class="menu-toggle" id="menuToggle">‚ò∞</button>
            <div class="logo-icon">üé≠</div>
            <h1>FaceAnon <span
                    style="font-size: 10px; background: var(--primary) !important; color: #ffffff !important; -webkit-text-fill-color: #ffffff !important; background-clip: initial !important; -webkit-background-clip: initial !important; padding: 2px 6px; border-radius: 4px; vertical-align: middle; margin-left: 4px; font-weight: 800; display: inline-block; line-height: 1; opacity: 1 !important; visibility: visible !important;">PRO</span>
            </h1>
        </div>
    </header>

    <div class="app">
        <aside class="sidebar">
            <div class="sidebar-section">
                <button class="btn btn-primary" id="newBtn" style="margin-bottom: 0;">üìÅ Nuevo Video</button>
            </div>





            <div class="sidebar-section">
                <div class="section-title">Efecto</div>
                <div class="preview-toggle" id="effectSelection" style="margin-bottom: 12px;">
                    <button class="preview-btn active" data-effect="pixelate">Pixelado</button>
                    <button class="preview-btn" data-effect="blur">Desenfoque</button>
                    <button class="preview-btn" data-effect="solid">Censura</button>
                </div>

                <div class="section-title" style="margin-top: 16px;">Personas Detectadas</div>
                <div id="peopleList" class="people-list"
                    style="display: flex; flex-direction: column; gap: 8px; overflow-y: auto; padding-right: 4px;">
                    <p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">
                        Reproduce el v√≠deo para listar personas...
                    </p>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Ajustes de √Årea</div>
                <div class="slider-wrapper" style="margin-bottom: 8px;">
                    <div class="slider-header">
                        <span>Intensidad</span>
                        <span id="intensityVal">15</span>
                    </div>
                    <input type="range" class="slider" id="intensity" min="5" max="50" value="15">
                </div>
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <span>Margen/Padding</span>
                        <span id="paddingVal">10%</span>
                    </div>
                    <input type="range" class="slider" id="paddingSlider" min="0" max="100" value="10">
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-title">Preview</div>
                <div class="preview-toggle">
                    <button class="preview-btn active" id="previewOriginal">Original</button>
                    <button class="preview-btn" id="previewEffects">Con Efectos</button>
                </div>
            </div>

            <div class="sidebar-section" style="margin-bottom: 0;">
                <button class="btn btn-primary" id="processBtn" disabled style="margin-bottom: 8px;">
                    ‚ö° Procesar Video
                </button>
                <button class="btn btn-secondary" id="exportBtn" disabled style="width: 100%;">üíæ Guardar</button>
                <div
                    style="margin-top: 24px; text-align: center; border-top: 1px solid var(--border); padding-top: 16px;">
                    <p
                        style="font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.1em; font-weight: 700;">
                        FaceAnon Pro v2.0
                    </p>
                </div>
            </div>
        </aside>

        <main class="workspace">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">‚ú®</div>
                <h2 class="upload-title">Empieza con tu Video</h2>
                <p class="upload-subtitle">
                    Arrastra tu archivo aqu√≠ o usa el bot√≥n para explorar.<br>
                    Formatos soportados: MP4, MOV, WebM.
                </p>
                <div class="upload-btn">Abrir Archivo</div>
            </div>

            <div id="videoContainer">
                <div class="video-card">
                    <div class="video-loader" id="videoLoader">
                        <div class="loader-spinner"></div>
                        <div class="loader-text">Cargando video...</div>
                    </div>
                    <div class="video-canvas-wrapper">
                        <canvas id="renderCanvas"></canvas>
                    </div>

                    <!-- AI Status Overlay -->
                    <div class="video-overlay-status" id="aiStatus">
                        <!-- Model Selection -->
                        <div class="overlay-controls" id="modelSelection">
                            <button class="overlay-btn active" data-model="auto">Auto</button>
                            <button class="overlay-btn" data-model="ssd">SSD</button>
                            <button class="overlay-btn" data-model="tiny">Tiny</button>
                        </div>

                        <!-- Status Info -->
                        <div class="overlay-row">
                            <div class="status-dot"></div>
                            <span>Cargando IA...</span>
                        </div>

                        <!-- Progress Bar -->
                        <div class="loading-progress active" id="aiProgress">
                            <div class="loading-progress-fill indeterminate" id="aiProgressFill"></div>
                        </div>
                    </div>

                    <div class="video-controls">
                        <button class="ctrl-btn" id="rewindBtn" title="Atr√°s 10s">‚àí10s</button>
                        <button class="play-btn" id="playBtn">‚ñ∂</button>
                        <button class="ctrl-btn" id="forwardBtn" title="Adelante 10s">+10s</button>
                        <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
                        <div class="progress-track" id="progressTrack">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <input type="file" id="fileInput" accept="video/*">

    <div class="modal-overlay" id="modal">
        <div class="modal">
            <div class="modal-spinner"></div>
            <div class="modal-title" id="modalTitle">Procesando</div>
            <div class="modal-subtitle" id="modalSubtitle">Preparando...</div>
            <div class="modal-progress">
                <div class="modal-progress-fill" id="modalFill"></div>
            </div>
            <div class="modal-percent" id="modalPercent">0%</div>
            <button class="modal-cancel" id="cancelBtn">Cancelar</button>
        </div>
    </div>

    <script>
        // App State
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

        const state = {
            effect: 'pixelate',
            intensity: 15,
            padding: 0.1, // 10% por defecto
            detectionMode: 'all',
            previewMode: 'original',
            processedBlob: null,
            videoBlobUrl: null,
            isPlaying: false,
            isProcessing: false,
            processingCanceled: false,
            isProcessing: false,
            processingCanceled: false,
            modelReady: false,
            recognitionReady: false,
            detectorType: null,
            modelPreference: isMobile ? 'tiny' : 'ssd', // Use Tiny on mobile for better performance
            videoWidth: 0,
            videoHeight: 0,
            lastKnownFaces: [],
            knownFaces: [], // { id, descriptor, name, excluded }
            trackingEnabled: true,
            highlightedPersonId: null,
            previewPersistenceCount: 0
        };

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW Registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('SW Registration failed:', error);
                    });
            });
        }

        // DOM Elements
        const elements = {
            uploadArea: document.getElementById('uploadArea'),
            fileInput: document.getElementById('fileInput'),
            videoContainer: document.getElementById('videoContainer'),
            renderCanvas: document.getElementById('renderCanvas'),
            renderCtx: document.getElementById('renderCanvas').getContext('2d'),
            playBtn: document.getElementById('playBtn'),
            progressFill: document.getElementById('progressFill'),
            progressTrack: document.getElementById('progressTrack'),
            timeDisplay: document.getElementById('timeDisplay'),
            intensitySlider: document.getElementById('intensity'),
            intensityVal: document.getElementById('intensityVal'),
            paddingSlider: document.getElementById('paddingSlider'),
            paddingVal: document.getElementById('paddingVal'),
            processBtn: document.getElementById('processBtn'),
            exportBtn: document.getElementById('exportBtn'),
            newBtn: document.getElementById('newBtn'),
            modal: document.getElementById('modal'),
            modalFill: document.getElementById('modalFill'),
            modalPercent: document.getElementById('modalPercent'),
            modalTitle: document.getElementById('modalTitle'),
            modalSubtitle: document.getElementById('modalSubtitle'),
            aiStatus: document.getElementById('aiStatus'),
            cancelBtn: document.getElementById('cancelBtn'),
            effectOptions: document.querySelectorAll('#effectSelection button'),
            modelBtns: document.querySelectorAll('#modelSelection button'),
            menuToggle: document.getElementById('menuToggle'),
            sidebar: document.querySelector('.sidebar'),
            peopleList: document.getElementById('peopleList'),
            rewindBtn: document.getElementById('rewindBtn'),
            forwardBtn: document.getElementById('forwardBtn')
        };

        const FACE_RECOGNITION_THRESHOLD = 0.5; // Distancia para considerar la misma persona

        // Video element (created dynamically)
        const video = document.createElement('video');
        video.muted = true;
        video.playsInline = true;
        video.style.display = 'none';
        document.body.appendChild(video);

        // Processing canvas
        const processCanvas = document.createElement('canvas');
        document.body.appendChild(processCanvas);

        // Initialize
        async function init() {
            // Register Service Worker for offline support
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(reg => console.log('SW Registered!', reg))
                        .catch(err => console.log('SW Registration failed:', err));
                });
            }

            setupEventListeners();
            await loadAI();
        }

        // Load AI Model with local files priority
        async function loadAI() {
            const sources = [
                './js/face-api.js'
            ];

            for (const source of sources) {
                try {
                    console.log('Intentando cargar Face-API desde:', source);

                    // Check if already loaded
                    if (typeof faceapi !== 'undefined') {
                        break;
                    }

                    // Load the script
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = source;
                        script.onload = resolve;
                        script.onerror = () => reject(new Error('Script load failed'));
                        document.head.appendChild(script);
                    });

                    console.log('Script cargado desde:', source);

                    // Wait a moment for the library to initialize
                    await new Promise(r => setTimeout(r, 500));

                    if (typeof faceapi !== 'undefined') {
                        break;
                    }
                } catch (e) {
                    console.warn('No se pudo cargar desde', source, ':', e.message);
                }
            }

            // Try to load models
            if (typeof faceapi === 'undefined') {
                console.error('Face-API no disponible');
                updateAIStatus(false);
                return;
            }

            try {
                const modelUrls = [
                    './models/',
                    'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/',
                    'https://justadudewhohacks.github.io/face-api.js/models/'
                ];

                let loadedModel = null;

                // Stage 1: Try Precision Model (SSD Mobilenet V1)
                if (state.modelPreference === 'auto' || state.modelPreference === 'ssd') {
                    console.log('--- Intentando cargar Modelo de Precisi√≥n (SSD) ---');
                    elements.aiStatus.querySelector('span').textContent = 'Cargando SSD...';
                    updateLoadingProgress(20);
                    for (const modelUrl of modelUrls) {
                        try {
                            console.log('Cargando SSD desde:', modelUrl);
                            await faceapi.nets.ssdMobilenetv1.loadFromUri(modelUrl);
                            loadedModel = 'ssd';
                            console.log('‚úÖ SSD Mobilenet V1 cargado correctamente');
                            break;
                        } catch (e) {
                            console.warn('Fallo SSD en:', modelUrl);
                        }
                    }
                }

                // Stage 2: Fallback to Light Model (Tiny Face Detector)
                if (!loadedModel && (state.modelPreference === 'auto' || state.modelPreference === 'tiny')) {
                    console.log('--- Intentando cargar Modelo Ligero (Tiny) ---');
                    elements.aiStatus.querySelector('span').textContent = 'Cargando Tiny...';
                    updateLoadingProgress(20);
                    for (const modelUrl of modelUrls) {
                        try {
                            console.log('Cargando Tiny desde:', modelUrl);
                            await faceapi.nets.tinyFaceDetector.loadFromUri(modelUrl);
                            loadedModel = 'tiny';
                            console.log('‚úÖ Tiny Face Detector cargado');
                            break;
                        } catch (e) {
                            console.warn('Fallo Tiny en:', modelUrl);
                        }
                    }
                }

                if (!loadedModel) {
                    throw new Error('No se pudo cargar ning√∫n modelo de detecci√≥n');
                }

                // Create detector options based on what was loaded
                if (loadedModel === 'ssd') {
                    window.faceDetector = new faceapi.SsdMobilenetv1Options({
                        minConfidence: 0.35 // Mayor sensibilidad para detectar caras de inmediato
                    });
                } else {
                    // Optimized for mobile devices
                    window.faceDetector = new faceapi.TinyFaceDetectorOptions({
                        inputSize: isMobile ? 416 : 512, // Reduced input size on mobile for speed
                        scoreThreshold: isMobile ? 0.3 : 0.25 // Slightly higher threshold on mobile for accuracy
                    });
                }

                state.detectorType = loadedModel;

                // Load additional models for recognition/tracking
                elements.aiStatus.querySelector('span').textContent = 'Cargando Reconocimiento...';
                updateLoadingProgress(50);
                for (const modelUrl of modelUrls) {
                    try {
                        await faceapi.nets.faceLandmark68Net.loadFromUri(modelUrl);
                        await faceapi.nets.faceRecognitionNet.loadFromUri(modelUrl);
                        console.log('‚úÖ Modelos de reconocimiento cargados');
                        break;
                    } catch (e) {
                        console.warn(`Fallo reconocimiento en ${modelUrl}:`, e.message);
                    }
                }

                state.modelReady = true;

                // Load additional models for recognition/tracking
                elements.aiStatus.querySelector('span').textContent = 'Cargando Reconocimiento...';
                updateLoadingProgress(50);

                state.recognitionReady = false;
                for (const modelUrl of modelUrls) {
                    try {
                        await faceapi.nets.faceLandmark68Net.loadFromUri(modelUrl);
                        await faceapi.nets.faceRecognitionNet.loadFromUri(modelUrl);
                        console.log('‚úÖ Modelos de reconocimiento cargados');
                        state.recognitionReady = true;
                        break;
                    } catch (e) {
                        console.warn(`Fallo reconocimiento en ${modelUrl}:`, e.message);
                    }
                }
                updateAIStatus(true);
                console.log(`‚úÖ IA lista usando detector: ${loadedModel} + Recognition`);

            } catch (error) {
                console.error('Error cr√≠tico cargando modelos:', error);
                updateAIStatus(false);
            }
        }

        function updateAIStatus(ready) {
            const dot = elements.aiStatus.querySelector('.status-dot');
            const span = elements.aiStatus.querySelector('span');
            const progress = document.getElementById('aiProgress');

            if (ready) {
                dot.classList.add('ready');
                const modelName = state.detectorType === 'ssd' ? 'SSD Precision' : 'Tiny Fast';
                span.textContent = `IA Lista (${modelName})`;
                // Hide progress bar when ready
                if (progress) progress.classList.remove('active');
                if (state.videoWidth > 0) {
                    elements.processBtn.disabled = false;
                }
            } else {
                dot.classList.remove('ready');
                span.textContent = 'IA No disp.';
                if (progress) progress.classList.remove('active');
            }
        }

        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('aiProgressFill');
            if (progressBar) {
                progressBar.classList.remove('indeterminate');
                progressBar.style.width = percent + '%';
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // Upload
            elements.uploadArea.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', handleFileSelect);

            // Drag and drop
            elements.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.uploadArea.classList.add('dragover');
            });
            elements.uploadArea.addEventListener('dragleave', () => {
                elements.uploadArea.classList.remove('dragover');
            });
            elements.uploadArea.addEventListener('drop', handleDrop);

            // Playback
            elements.playBtn.addEventListener('click', togglePlay);
            elements.progressTrack.addEventListener('click', seek);
            elements.rewindBtn.addEventListener('click', () => {
                video.currentTime = Math.max(0, video.currentTime - 10);
                updateProgress();
            });
            elements.forwardBtn.addEventListener('click', () => {
                video.currentTime = Math.min(video.duration, video.currentTime + 10);
                updateProgress();
            });

            // Intensity
            elements.intensitySlider.addEventListener('input', (e) => {
                state.intensity = parseInt(e.target.value);
                elements.intensityVal.textContent = state.intensity;
            });

            // Effect selection
            elements.effectOptions.forEach(option => {
                option.addEventListener('click', () => {
                    elements.effectOptions.forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    state.effect = option.dataset.effect;
                    renderFrame();
                });
            });



            // Model preference
            elements.modelBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    elements.modelBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.modelPreference = btn.dataset.model;
                    // Forzar recarga de IA con la nueva preferencia
                    state.modelReady = false;
                    updateAIStatus(false);
                    await loadAI();
                });
            });

            // Padding slider
            elements.paddingSlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                state.padding = val / 100;
                elements.paddingVal.textContent = val + '%';
                renderFrame();
            });

            // Preview toggle
            const previewOriginal = document.getElementById('previewOriginal');
            const previewEffects = document.getElementById('previewEffects');

            if (previewOriginal && previewEffects) {
                previewOriginal.addEventListener('click', () => {
                    state.previewMode = 'original';
                    previewOriginal.classList.add('active');
                    previewEffects.classList.remove('active');
                    renderFrame();
                });

                previewEffects.addEventListener('click', () => {
                    if (!state.modelReady) {
                        alert('La IA no est√° lista a√∫n');
                        return;
                    }
                    state.previewMode = 'effects';
                    previewOriginal.classList.remove('active');
                    previewEffects.classList.add('active');
                    renderFrame();
                });
            }

            // Process video
            elements.processBtn.addEventListener('click', processVideo);

            // Export
            elements.exportBtn.addEventListener('click', exportVideo);

            // New video
            // Nuevo Video button - open file selector
            elements.newBtn.addEventListener('click', () => {
                elements.fileInput.click();
            });

            // Cancel processing
            elements.cancelBtn.addEventListener('click', () => {
                state.processingCanceled = true;
            });

            // Time update
            video.addEventListener('timeupdate', updateProgress);

            // Mobile Menu
            if (elements.menuToggle) {
                elements.menuToggle.addEventListener('click', () => {
                    elements.sidebar.classList.toggle('active');
                    elements.menuToggle.textContent = elements.sidebar.classList.contains('active') ? '‚úï' : '‚ò∞';
                });
            }

            // Cerrar sidebar en m√≥vil tras seleccionar
            const closeSidebarOnMobile = () => {
                if (window.innerWidth < 768) {
                    elements.sidebar.classList.remove('active');
                    elements.menuToggle.textContent = '‚ò∞';
                }
            };

            elements.effectOptions.forEach(opt => opt.addEventListener('click', closeSidebarOnMobile));
            elements.modelBtns.forEach(opt => opt.addEventListener('click', closeSidebarOnMobile));
        }

        // File handling
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) loadVideo(file);
        }

        function handleDrop(e) {
            e.preventDefault();
            elements.uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideo(file);
            }
        }

        function loadVideo(file) {
            // RESET APP STATE when loading new video
            resetAppState();

            // Show loading state
            elements.uploadArea.style.display = 'none';
            elements.videoContainer.classList.add('active');
            const loader = document.getElementById('videoLoader');
            if (loader) loader.classList.add('active');

            if (state.videoBlobUrl) {
                URL.revokeObjectURL(state.videoBlobUrl);
            }

            // Small delay to allow UI to update and show loader if file is large
            setTimeout(() => {
                state.videoBlobUrl = URL.createObjectURL(file);
                video.src = state.videoBlobUrl;
            }, 50);

            video.onloadedmetadata = () => {
                state.videoWidth = video.videoWidth;
                state.videoHeight = video.videoHeight;

                // Setup canvases
                elements.renderCanvas.width = state.videoWidth;
                elements.renderCanvas.height = state.videoHeight;
                processCanvas.width = state.videoWidth;
                processCanvas.height = state.videoHeight;

                console.log('Video cargado:', state.videoWidth, 'x', state.videoHeight);

                // Hide loader with delay
                if (loader) {
                    setTimeout(() => {
                        loader.classList.remove('active');
                    }, 500);
                }

                // Show video container (redundant but safe)
                elements.uploadArea.style.display = 'none';
                elements.videoContainer.classList.add('active');

                // Force canvas visibility
                elements.renderCanvas.style.visibility = 'visible';
                elements.renderCanvas.style.display = 'block';

                // Update UI
                updateTimeDisplay();
                renderFrame();

                // Enable process button if AI is ready
                if (state.modelReady) {
                    elements.processBtn.disabled = false;
                }
            };
        }

        // Reset app state when loading new video
        function resetAppState() {
            // Stop playback
            if (!video.paused) {
                video.pause();
                stopPreviewLoop();
            }

            // Reset state
            state.isPlaying = false;
            state.isProcessing = false;
            state.processingCanceled = false;
            state.processedBlob = null;
            state.lastKnownFaces = [];
            state.knownFaces = [];
            state.smoothedBoxes = {};
            state.highlightedPersonId = null;
            state.previewPersistenceCount = 0;
            state.previewMode = 'original';

            // Reset UI
            elements.playBtn.textContent = '‚ñ∂';
            elements.processBtn.disabled = true;
            elements.exportBtn.disabled = true;

            // Clear people list
            elements.peopleList.innerHTML = '<p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">Reproduce el v√≠deo para listar personas...</p>';

            // Reset preview buttons
            const previewOriginal = document.getElementById('previewOriginal');
            const previewEffects = document.getElementById('previewEffects');
            if (previewOriginal && previewEffects) {
                previewOriginal.classList.add('active');
                previewEffects.classList.remove('active');
            }

            console.log('App state reset for new video');
        }

        // Playback controls
        function togglePlay() {
            if (video.paused) {
                video.play();
                state.isPlaying = true;
                elements.playBtn.textContent = '‚è∏';
                startPreviewLoop();
            } else {
                video.pause();
                state.isPlaying = false;
                elements.playBtn.textContent = '‚ñ∂';
                stopPreviewLoop();
            }
        }

        function updateProgress() {
            const progress = (video.currentTime / video.duration) * 100;
            elements.progressFill.style.width = progress + '%';
            updateTimeDisplay();
        }

        function updateTimeDisplay() {
            const current = formatTime(video.currentTime);
            const total = formatTime(video.duration || 0);
            elements.timeDisplay.textContent = `${current} / ${total}`;
        }

        function seek(e) {
            const rect = elements.progressTrack.getBoundingClientRect();
            const position = (e.clientX - rect.left) / rect.width;
            video.currentTime = position * video.duration;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Preview loop
        let previewRequestId = null;

        function startPreviewLoop() {
            function loop() {
                if (!state.isPlaying) return;
                renderFrame();
                previewRequestId = requestAnimationFrame(loop);
            }
            loop();
        }

        function stopPreviewLoop() {
            if (previewRequestId) {
                cancelAnimationFrame(previewRequestId);
                previewRequestId = null;
            }
        }

        // Render frame
        function renderFrame() {
            if (!state.videoWidth) return;

            try {
                // 1. Draw original video
                elements.renderCtx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);

                // 2. Continuous Background Detection (async, doesn't block rendering)
                // Run detection when playing OR when video is loaded and ready
                if ((state.isPlaying || state.videoWidth > 0) && !state.isProcessing) {
                    runBackgroundDetection();
                }

                // 3. ALWAYS draw effects if we have cached faces and we're in effects mode
                // This ensures NO frames are skipped, even while detection is running
                if (state.previewMode === 'effects' && !state.isProcessing) {
                    // Always draw effects using last known detections
                    drawCachedEffects(); // Draw everything (effects + highlights)
                } else if (state.previewMode === 'original' && !state.isProcessing) {
                    drawTrackingBorders(); // Draw only diagnostic borders
                }
            } catch (e) {
                console.error('Render error:', e);
            }
        }

        let isDetecting = false;
        let lastDetectionTime = 0;
        const DETECTION_INTERVAL = isMobile ? 150 : 100; // Throttle detection on mobile (ms)

        async function runBackgroundDetection() {
            if (isDetecting || !state.modelReady) {
                if (!state.modelReady) {
                    console.warn('Detection skipped: Model not ready');
                }
                return;
            }

            // Throttle detection on mobile for better performance
            const now = Date.now();
            if (isMobile && now - lastDetectionTime < DETECTION_INTERVAL) {
                return;
            }
            lastDetectionTime = now;

            isDetecting = true;
            try {
                console.log('Running face detection...');

                // Use full detection if recognition is ready, otherwise basic
                let detections;
                if (!state.recognitionReady) {
                    // Basic detection (faster, no recognition)
                    detections = await faceapi.detectAllFaces(video, window.faceDetector);
                    // Convert to format expected by rest of code
                    detections = detections.map(d => ({
                        detection: d,
                        identity: null
                    }));
                } else {
                    // Full detection with recognition
                    detections = await faceapi.detectAllFaces(video, window.faceDetector)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                    detections = await identifyFaces(detections);
                }

                console.log(`Detected ${detections.length} faces`);

                // Aplicar suavizado de cajas
                const refined = detections.map(d => {
                    const smoothed = smoothBoundingBox(d);
                    return { ...d, smoothedBox: smoothed };
                });

                if (refined.length > 0) {
                    state.lastKnownFaces = filterFaces(refined);
                    // Much longer persistence on mobile to prevent gaps
                    state.previewPersistenceCount = isMobile ? 30 : 20;
                } else if (state.previewPersistenceCount > 0) {
                    state.previewPersistenceCount--;
                    // Keep using cached faces - this prevents frame gaps
                } else {
                    // Only clear faces after persistence expires
                    state.lastKnownFaces = [];
                }
            } catch (e) {
                console.error('Background detection error:', e);
            } finally {
                isDetecting = false;
            }
        }

        // EMA Smoothing logic to eliminate jitter for exact tracking
        const SMOOTHING_FACTOR = isMobile ? 0.7 : 0.8; // Slightly more smoothing on mobile for stability
        function smoothBoundingBox(detection) {
            const rawBox = detection.detection.box;
            const personId = detection.identity ? detection.identity.id : 'unknown';

            if (!state.smoothedBoxes) state.smoothedBoxes = {};
            const prev = state.smoothedBoxes[personId] || rawBox;

            const smoothed = {
                x: prev.x + (rawBox.x - prev.x) * SMOOTHING_FACTOR,
                y: prev.y + (rawBox.y - prev.y) * SMOOTHING_FACTOR,
                width: prev.width + (rawBox.width - prev.width) * SMOOTHING_FACTOR,
                height: prev.height + (rawBox.height - prev.height) * SMOOTHING_FACTOR
            };

            state.smoothedBoxes[personId] = smoothed;
            return smoothed;
        }

        function drawTrackingBorders() {
            drawCachedEffects(false);
        }

        function drawCachedEffects(showEffects = true) {
            if (state.lastKnownFaces.length === 0) return;

            const scaleX = state.videoWidth / video.videoWidth;
            const scaleY = state.videoHeight / video.videoHeight;
            const padding = state.padding;

            state.lastKnownFaces.forEach(face => {
                // Priorizar la caja suavizada para un tracking "exacto" y fluido
                const box = face.smoothedBox || (face.detection ? face.detection.box : null);
                if (!box) return;

                const x = Math.max(0, (box.x - (box.width * padding)) * scaleX);
                const y = Math.max(0, (box.y - (box.height * padding)) * scaleY);
                const w = Math.min(state.videoWidth - x, (box.width * (1 + padding * 2)) * scaleX);
                const h = Math.min(state.videoHeight - y, (box.height * (1 + padding * 2)) * scaleY);

                // 1. Aplicar efecto si NO est√° excluido y estamos en modo efectos
                if (showEffects && !(face.identity && face.identity.excluded)) {
                    if (state.effect === 'pixelate') {
                        pixelateArea(elements.renderCtx, x, y, w, h);
                    } else if (state.effect === 'blur') {
                        blurArea(elements.renderCtx, x, y, w, h);
                    } else {
                        solidArea(elements.renderCtx, x, y, w, h);
                    }
                }

                // 2. Dibujar indicadores visuales de detecci√≥n
                const ctx = elements.renderCtx;

                // Borde blanco sutil para todos los detectados (Feedback de que la IA los ve)
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(x, y, w, h);
                ctx.restore();

                // 3. Dibujar borde rojo fuerte si est√° destacado (hover/click)
                if (face.identity && face.identity.id === state.highlightedPersonId) {
                    ctx.save();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, w, h);

                    // Peque√±a etiqueta
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.fillText(face.identity.name, x, y - 5);
                    ctx.restore();
                }
            });
        }

        // Match detected faces with known identities
        async function identifyFaces(detections) {
            const results = [];

            for (const detection of detections) {
                let bestMatch = null;
                let minDistance = FACE_RECOGNITION_THRESHOLD;

                if (detection.descriptor) {
                    state.knownFaces.forEach(known => {
                        const distance = faceapi.euclideanDistance(detection.descriptor, known.descriptor);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMatch = known;
                        }
                    });
                }

                // Fallback Espacial: si no hay match por biometr√≠a, buscamos por posici√≥n previa
                if (!bestMatch) {
                    const box = detection.detection.box;
                    let minSpatialDist = video.videoWidth * 0.2; // 20% del ancho para ser independiente de resoluci√≥n
                    state.knownFaces.forEach(known => {
                        if (known.lastPos) {
                            const dist = Math.sqrt(Math.pow(box.x - known.lastPos.x, 2) + Math.pow(box.y - known.lastPos.y, 2));
                            if (dist < minSpatialDist) {
                                minSpatialDist = dist;
                                bestMatch = known;
                            }
                        }
                    });
                }

                if (!bestMatch && detection.descriptor) {
                    // New identity found
                    const newId = `Persona ${state.knownFaces.length + 1}`;
                    const newPerson = {
                        id: Date.now() + Math.random(),
                        name: newId,
                        descriptor: detection.descriptor,
                        excluded: false,
                        lastPos: detection.detection.box
                    };
                    state.knownFaces.push(newPerson);
                    bestMatch = newPerson;
                    renderPeopleList();
                }

                if (bestMatch) {
                    bestMatch.lastPos = detection.detection.box;
                    // Actualizar descriptor si el nuevo es de mejor calidad? (Omitido por ahora para estabilidad)
                }

                results.push({
                    ...detection,
                    identity: bestMatch
                });
            }
            return results;
        }

        function renderPeopleList() {
            if (state.knownFaces.length === 0) return;

            elements.peopleList.innerHTML = '';
            state.knownFaces.forEach(person => {
                const item = document.createElement('div');
                item.className = `btn btn-secondary ${person.excluded ? '' : 'active'}`;
                item.style.fontSize = '12px';
                item.style.padding = '8px 12px';
                item.style.display = 'flex';
                item.style.justifyContent = 'space-between';
                item.style.alignItems = 'center';
                item.style.border = person.excluded ? '1px solid var(--border)' : '1px solid var(--primary)';
                item.style.background = person.excluded ? 'transparent' : 'rgba(99, 102, 241, 0.1)';

                item.innerHTML = `
                    <span>${person.name}</span>
                    <span style="font-size: 10px; opacity: 0.7;">${person.excluded ? 'üôà Libre' : 'üé≠ Anon'}</span>
                `;

                item.onmouseenter = () => {
                    state.highlightedPersonId = person.id;
                    if (!state.isPlaying) renderFrame();
                };

                item.onmouseleave = () => {
                    state.highlightedPersonId = null;
                    if (!state.isPlaying) renderFrame();
                };

                item.onclick = () => {
                    person.excluded = !person.excluded;
                    state.highlightedPersonId = person.id;
                    renderPeopleList();
                    if (!state.isPlaying) renderFrame();
                };

                elements.peopleList.appendChild(item);
            });
        }

        // Apply effects (used mainly for paused/immediate updates)
        async function applyEffects() {
            if (isDetecting || !state.modelReady) return;
            await runBackgroundDetection();
            drawCachedEffects();
        }

        function filterFaces(detections) {
            return detections;
        }

        function pixelateArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;
            ctx.imageSmoothingEnabled = false;
            const size = Math.max(1, Math.floor(w / state.intensity));
            ctx.drawImage(ctx.canvas, x, y, w, h, x, y, size, size);
            ctx.drawImage(ctx.canvas, x, y, size, size, x, y, w, h);
        }

        function blurArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip();
            ctx.filter = `blur(${state.intensity}px)`;
            ctx.drawImage(ctx.canvas, 0, 0);
            ctx.restore();
        }

        function solidArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;
            ctx.fillStyle = '#000000';
            ctx.fillRect(x, y, w, h);
        }

        // Process video
        async function processVideo() {
            if (state.isProcessing || !state.modelReady) return;

            state.isProcessing = true;
            state.processingCanceled = false;

            video.pause();
            stopPreviewLoop();

            elements.processBtn.disabled = true;
            elements.exportBtn.disabled = true;
            elements.modal.classList.add('active');
            elements.modalFill.style.width = '0%';
            elements.modalPercent.textContent = '0%';
            elements.modalTitle.textContent = 'Procesando Video';
            elements.modalSubtitle.textContent = 'Analizando frames con alta precisi√≥n...';

            const duration = video.duration;
            // Estimar FPS o usar 30 por defecto. Face-API funciona mejor con un ritmo constante.
            const fps = 30;
            const frameTime = 1 / fps;
            const ctx = processCanvas.getContext('2d', { willReadFrequently: true });

            const frames = [];
            video.currentTime = 0;

            // Wait for video to be stable
            await new Promise(r => setTimeout(r, 1000));

            const totalFrames = Math.ceil(duration / frameTime);
            let currentFrame = 0;

            async function seekTo(time) {
                return new Promise(resolve => {
                    const onSeeked = () => {
                        video.removeEventListener('seeked', onSeeked);
                        setTimeout(resolve, 30);
                    };
                    video.addEventListener('seeked', onSeeked);
                    video.currentTime = time;
                    setTimeout(() => {
                        video.removeEventListener('seeked', onSeeked);
                        resolve();
                    }, 2000);
                });
            }

            let lastKnownFaces = [];
            let persistenceCounter = 0;
            const MAX_PERSISTENCE = 6; // Mantener detecciones durante 6 frames si se pierden

            for (let time = 0; time < duration; time += frameTime) {
                if (state.processingCanceled) {
                    state.isProcessing = false;
                    elements.processBtn.disabled = false;
                    elements.modal.classList.remove('active');
                    return;
                }

                await seekTo(time);

                // Dibujar el frame original
                ctx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);

                // Detecci√≥n exhaustiva con reconocimiento
                try {
                    let detections;

                    // Use full detection if recognition is ready, otherwise basic
                    if (!state.recognitionReady) {
                        detections = await faceapi.detectAllFaces(video, window.faceDetector);
                        // Convert to format expected by rest of code
                        detections = detections.map(d => ({
                            detection: d,
                            identity: null
                        }));
                    } else {
                        detections = await faceapi.detectAllFaces(video, window.faceDetector)
                            .withFaceLandmarks()
                            .withFaceDescriptors();
                        detections = await identifyFaces(detections);
                    }

                    let facesToProcess = filterFaces(detections);

                    // Persistencia Temporal Mejorada: Evita frames "limpios" por fallos moment√°neos de la IA
                    if (facesToProcess.length === 0 && persistenceCounter > 0) {
                        facesToProcess = lastKnownFaces;
                        persistenceCounter--;
                    } else if (facesToProcess.length > 0) {
                        lastKnownFaces = facesToProcess;
                        persistenceCounter = MAX_PERSISTENCE;
                    } else {
                        lastKnownFaces = [];
                    }

                    // Suavizado para un tracking "exacto" y fluido
                    const refined = facesToProcess.map(d => {
                        return { ...d, smoothedBox: smoothBoundingBox(d) };
                    });

                    const scaleX = state.videoWidth / video.videoWidth;
                    const scaleY = state.videoHeight / video.videoHeight;

                    refined.forEach(detection => {
                        // Skip if person is excluded
                        if (detection.identity && detection.identity.excluded) return;

                        const box = detection.smoothedBox || (detection.detection ? detection.detection.box : null);
                        if (!box) return;

                        const padding = state.padding;
                        const x = Math.max(0, (box.x - (box.width * padding)) * scaleX);
                        const y = Math.max(0, (box.y - (box.height * padding)) * scaleY);
                        const w = Math.min(state.videoWidth - x, (box.width * (1 + padding * 2)) * scaleX);
                        const h = Math.min(state.videoHeight - y, (box.height * (1 + padding * 2)) * scaleY);

                        if (state.effect === 'pixelate') {
                            pixelateArea(ctx, x, y, w, h);
                        } else if (state.effect === 'blur') {
                            blurArea(ctx, x, y, w, h);
                        } else {
                            solidArea(ctx, x, y, w, h);
                        }
                    });
                } catch (e) {
                    console.error('Frame detection error:', e);
                    // Si hay error, intentar usar las √∫ltimas conocidas para no dejar el frame "limpio"
                    if (lastKnownFaces.length > 0) {
                        lastKnownFaces.forEach(detection => {
                            if (detection.identity && detection.identity.excluded) return;

                            const box = detection.box || (detection.detection ? detection.detection.box : null);
                            if (!box) return;

                            const scaleX = state.videoWidth / video.videoWidth;
                            const scaleY = state.videoHeight / video.videoHeight;
                            const padding = state.padding;
                            const x = Math.max(0, (box.x - (box.width * padding)) * scaleX);
                            const y = Math.max(0, (box.y - (box.height * padding)) * scaleY);
                            const w = Math.min(state.videoWidth - x, (box.width * (1 + padding * 2)) * scaleX);
                            const h = Math.min(state.videoHeight - y, (box.height * (1 + padding * 2)) * scaleY);

                            if (state.effect === 'pixelate') pixelateArea(ctx, x, y, w, h);
                            else if (state.effect === 'blur') blurArea(ctx, x, y, w, h);
                            else solidArea(ctx, x, y, w, h);
                        });
                    }
                }

                // Guardar frame procesado con alta calidad
                frames.push(processCanvas.toDataURL('image/jpeg', 0.95));
                currentFrame++;

                // Update progress UI
                const progress = (currentFrame / totalFrames) * 100;
                elements.modalFill.style.width = progress + '%';
                elements.modalPercent.textContent = Math.round(progress) + '%';
                elements.modalSubtitle.textContent = `Frame ${currentFrame} de ${totalFrames} (${Math.round(time * 10) / 10}s)`;
            }

            // Create final video
            createFinalVideo(frames, fps);
        }

        function createFinalVideo(frames, fps) {
            elements.modalTitle.textContent = 'Generando Video';
            elements.modalSubtitle.textContent = 'Compilando resultados con fluidez...';
            elements.modalFill.style.width = '100%';

            const canvas = document.createElement('canvas');
            canvas.width = state.videoWidth;
            canvas.height = state.videoHeight;
            const ctx = canvas.getContext('2d');

            // 0 indica que capturamos frames manualmente v√≠a requestFrame()
            const stream = canvas.captureStream(0);

            let mimeType = 'video/webm;codecs=vp9';
            if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm;codecs=vp8';
            if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'video/webm';

            const recorder = new MediaRecorder(stream, {
                mimeType: mimeType,
                videoBitsPerSecond: 8000000 // 8 Mbps para excelente calidad
            });

            const chunks = [];
            recorder.ondataavailable = e => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            recorder.onstop = () => {
                state.processedBlob = new Blob(chunks, { type: 'video/webm' });
                state.isProcessing = false;
                elements.processBtn.disabled = false;
                elements.exportBtn.disabled = false;
                elements.modal.classList.remove('active');
                alert('‚úÖ Video procesado correctamente!\n\nLa duraci√≥n y fluidez coinciden con el original.');
            };

            recorder.start();

            const img = new Image();
            let frameIndex = 0;
            const frameDuration = 1000 / fps; // Duraci√≥n exacta de cada frame en ms

            function drawNext() {
                if (frameIndex >= frames.length) {
                    // Dar tiempo al encoder para finalizar
                    setTimeout(() => recorder.stop(), 500);
                    return;
                }

                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    // Forzar la grabaci√≥n de este frame exacto en el stream
                    const track = stream.getVideoTracks()[0];
                    if (track && track.requestFrame) {
                        track.requestFrame();
                    }

                    frameIndex++;
                    // Usamos el intervalo correspondiente al FPS para mantener la duraci√≥n original
                    setTimeout(drawNext, frameDuration);
                };
                img.src = frames[frameIndex];
            }

            drawNext();
        }

        // Export video
        function exportVideo() {
            if (!state.processedBlob) {
                alert('Primero procesa un video');
                return;
            }
            const url = URL.createObjectURL(state.processedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `faceanon_${Date.now()}.webm`;
            a.click();
        }

        // Reset app
        function resetApp() {
            video.pause();
            stopPreviewLoop();

            if (state.videoBlobUrl) {
                URL.revokeObjectURL(state.videoBlobUrl);
            }

            state.videoBlobUrl = null;
            state.processedBlob = null;
            state.isPlaying = false;
            state.videoWidth = 0;
            state.videoHeight = 0;
            state.knownFaces = [];
            state.lastKnownFaces = [];
            state.smoothedBoxes = {};
            elements.peopleList.innerHTML = '<p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">Reproduce el v√≠deo para listar personas...</p>';

            elements.uploadArea.style.display = 'block';
            elements.videoContainer.classList.remove('active');
            elements.exportBtn.disabled = true;
            elements.processBtn.disabled = true;
            elements.fileInput.value = '';
            elements.progressFill.style.width = '0%';
            elements.timeDisplay.textContent = '0:00 / 0:00';
            elements.playBtn.textContent = '‚ñ∂';
        }

        // Start app
        init();
    </script>
</body>

</html>