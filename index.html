<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FaceAnon Pro</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#09090b">

    <!-- Apple PWA Meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FaceAnon">
    <link rel="apple-touch-icon" href="logo.jpg">

    <!-- Local Fonts -->
    <link rel="stylesheet" href="css/fonts.css">

    <!-- Face-API Library (Includes TensorFlow.js) -->
    <script src="js/face-api.js"></script>
    <script>
        // Expose face-api's internal TensorFlow instance for other models (BlazeFace)
        // This prevents double-loading TFJS and fixes backend registration warnings
        window.tf = faceapi.tf;
    </script>

    <!-- BlazeFace (Uses the shared tf instance) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7"></script>


    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --primary-glow: rgba(99, 102, 241, 0.4);
            --bg-dark: #09090b;
            --bg-card: #18181b;
            --bg-hover: #27272a;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --border: #27272a;
            --border-hover: #3f3f46;
            --success: #10b981;
            --warning: #f59e0b;
            --glass: rgba(24, 24, 27, 0.8);
        }

        html {
            height: 100%;
            height: 100dvh;
            /* Mobile override */
            width: 100%;
            overflow: hidden !important;
            overscroll-behavior: none !important;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            height: 100%;
            height: 100dvh;
            /* Mobile override */
            width: 100%;
            overflow: hidden !important;
            /* Force no scroll */
            overscroll-behavior: none !important;
            letter-spacing: -0.01em;
            position: fixed;
            /* Nuclear option for iOS Safari bounce */
            inset: 0;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-hover);
        }

        /* Header */
        header {
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: none;
            /* Removed border */
            position: sticky;
            top: 0;
            z-index: 2000;
        }

        /* ... (logo styles) ... */

        .menu-toggle {
            /* ... */
            border: none;
            /* Removed border */
            /* ... */
        }

        /* ... (header-status) ... */
        .header-status {
            /* ... */
            border: none;
            /* Removed border */
            background: rgba(0, 0, 0, 0.4);
            /* ... */
        }

        /* Sidebar */
        .sidebar {
            background: var(--bg-card);
            padding: 20px 16px;
            border-bottom: none;
            /* Removed border */
            overflow-y: auto;
            overflow-x: hidden;
            max-height: 100%;
        }

        /* ... */

        .section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255, 255, 255, 0.05);
            /* Very subtle separator or remove */
        }

        /* Just remove the separator line entirely if desired, but 0.05 is barely visible */
        .section-title::after {
            display: none;
        }

        /* Buttons */
        .btn-secondary {
            background: var(--bg-hover);
            color: var(--text);
            border: none;
            /* Removed border */
        }

        /* Effects */
        .effect-option {
            padding: 16px 12px;
            background: var(--bg-dark);
            border: none;
            /* Removed border */
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .effect-option.active {
            /* border-color: var(--primary); Removed border color */
            background: rgba(99, 102, 241, 0.2);
            /* Stronger background to indicate active */
            box-shadow: none;
            /* Removed inset border */
            outline: 2px solid var(--primary);
            /* Use outline or just background */
        }

        .effect-option:hover {
            /* border-color: var(--border-hover); Removed */
            transform: translateY(-2px);
            background: var(--bg-hover);
        }

        .effect-icon {
            font-size: 26px;
            display: block;
            margin-bottom: 6px;
            transition: transform 0.3s;
        }

        .effect-option:hover .effect-icon {
            transform: scale(1.1);
        }

        .effect-name {
            font-size: 13px;
            font-weight: 500;
        }

        /* Slider */
        .slider-wrapper {
            background: rgba(0, 0, 0, 0.1);
            padding: 4px;
            border-radius: 8px;
        }

        @media (max-width: 767px) {
            .slider-wrapper {
                padding: 3px;
                border-radius: 6px;
            }
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
            color: var(--text-muted);
            font-weight: 500;
        }

        @media (max-width: 767px) {
            .slider-header {
                margin-bottom: 6px;
                font-size: 11px;
            }
        }

        #intensityVal,
        #paddingVal {
            color: var(--primary-light);
            font-weight: 700;
            font-family: monospace;
        }

        .slider {
            width: 100%;
            height: 6px;
            background: var(--bg-dark);
            border-radius: 6px;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: white;
            border: 3px solid var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            background: var(--primary);
        }

        /* Detection/Tracking */
        .mode-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mode-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-dark);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }


        .mode-option:hover {
            background: var(--bg-hover);
            border-color: var(--border-hover);

            /* Detection/Tracking */
            .mode-option {
                /* ... */
                border: none;
                /* Removed border */
                /* ... */
            }

            .mode-option.active {
                /* border-color: var(--primary); Removed */
                /* box-shadow: inset 0 0 0 1px var(--primary); Removed border shadow */
                outline: 2px solid var(--primary);
            }

            /* Preview Toggle */
            .preview-btn {
                flex: 1;
                padding: 8px 6px;
                background: var(--bg-dark);
                border: none;
                /* Removed border */
                border-radius: 8px;
                color: var(--text-muted);
                font-size: 12px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .preview-btn:hover {
                background: var(--bg-hover);
                /* Instead of border color */
            }

            .preview-btn.active {
                border: none;
                /* Ensure no border */
                outline: 2px solid var(--primary);
                /* Outline for active state */
                background: rgba(99, 102, 241, 0.1);
                color: var(--text);
            }

            /* Upload Area */
            .upload-area {
                width: 100%;
                max-width: 440px;
                padding: 60px 40px;
                border: none;
                /* Removed border dashed */
                /* Use a subtle background diff or shadow instead? Or just keep it clean */
                background: var(--bg-card);
                border-radius: 24px;
                text-align: center;
                cursor: pointer;
                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: var(--shadow-lg);
                /* Optional: Add an outline for structure without "border" look */
                outline: 2px dashed var(--border);
            }

            .upload-area:hover,
            .upload-area.dragover {
                outline-color: var(--primary);
                background: rgba(99, 102, 241, 0.03);
                transform: scale(1.01);
            }

            border-radius: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-card);
            box-shadow: var(--shadow-lg);
        }

        @media (max-width: 767px) {
            .upload-area {
                padding: 40px 20px;
                max-width: 100%;
                border-radius: 16px;
            }
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.03);
            transform: scale(1.01);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .upload-title {
            font-family: 'Outfit', sans-serif;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .upload-subtitle {
            color: var(--text-muted);
            font-size: 15px;
            margin-bottom: 28px;
            line-height: 1.5;
        }

        .upload-btn {
            display: inline-block;
            padding: 14px 32px;
            background: var(--primary);
            border-radius: 12px;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px var(--primary-glow);
        }

        /* Mobile Upload Area Styles */
        .mobile-upload-area {
            display: none;
            /* Componente flex */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        .mobile-upload-btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            border: none;
            border-radius: 20px;
            padding: 24px 40px;
            width: 100%;
            max-width: 300px;
            color: white;
            font-weight: 700;
            font-size: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
            transition: transform 0.2s;
        }

        .mobile-upload-btn:active {
            transform: scale(0.96);
        }

        /* Switching Logic */
        .desktop-only {
            display: block;
        }

        .mobile-only {
            display: none;
        }

        @media (max-width: 768px) {
            .desktop-only {
                display: none !important;
            }

            .mobile-only {
                display: flex !important;
            }

            .upload-area {
                display: none;
            }

            /* Override classic */

            /* Expand Wrapper */
            #uploadArea {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Drag Over Handlers on Wrapper */
        #uploadArea.dragover .desktop-only {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
            transform: scale(1.02);
        }

        /* Video Container */
        #videoContainer {
            display: none;
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #videoContainer.active {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            /* Prevent container itself from scrolling */
        }

        .video-card {
            background: var(--bg-card);
            border-radius: 20px;
            overflow: hidden;
            border: none;
            /* Removed border */
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            flex: 1;
            /* Grow to fill space */
            position: relative;
            margin-bottom: 0;
            /* Attach to controls */
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .video-loader {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .video-loader.active {
            opacity: 1;
            pointer-events: all;
        }

        .loader-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }

        .loader-text {
            color: var(--text-muted);
            font-size: 14px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .video-canvas-wrapper {
            position: relative;
            width: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            /* Fill remaining card space */
            min-height: 0;
            /* Crucial for flex nested scrolling */
            overflow: hidden;
        }

        #renderCanvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: block;
            object-fit: contain;
            /* Scale down preserving aspect ratio */
        }

        /* Video Controls */
        .video-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 24px;
            background: rgba(24, 24, 27, 0.50);
            /* 50% Translucent */
            backdrop-filter: blur(8px);
            border: none;
            /* Removed grey profile */
            border-top: none;
            border-bottom-left-radius: 20px;
            border-bottom-right-radius: 20px;
            /* Ensure it sits at bottom naturally in flex */
        }

        .play-btn,
        .ctrl-btn {
            width: 44px;
            height: 44px;
            background: var(--primary);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .play-btn:hover,
        .ctrl-btn:hover {
            transform: scale(1.05);
            background: var(--primary-light);
        }

        .ctrl-btn {
            background: rgba(255, 255, 255, 0.05);
            /* Very subtle to detect touch area but no grey profile */
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
            padding: 0 10px;
        }

        .time-display {
            font-family: 'Inter', monospace;
            font-size: 13px;
            color: var(--text-muted);
            min-width: 100px;
            letter-spacing: 0.05em;
        }

        .progress-track {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: height 0.2s;
        }

        .progress-track:hover {
            height: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--primary-light));
            width: 0%;
            border-radius: 4px;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .progress-track:hover .progress-fill::after {
            opacity: 1;
        }

        /* Header Actions */
        .header-actions {
            display: flex;
            gap: 8px;
        }

        .header-btn {
            padding: 8px 12px;
            background: var(--bg-dark);
            border: none;
            /* Removed border */
            border-radius: 6px;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
        }

        /* Modal Redesign */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 24px;
        }

        .modal-overlay.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .modal {
            background: var(--bg-card);
            border: none;
            border-radius: 24px;
            padding: 40px;
            text-align: center;
            max-width: 420px;
            width: 100%;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }


        .modal-spinner {
            width: 56px;
            height: 56px;
            border: 4px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .modal-title {
            font-family: 'Outfit', sans-serif;
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .modal-subtitle {
            color: var(--text-muted);
            font-size: 15px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .modal-progress {
            height: 10px;
            background: var(--bg-dark);
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 16px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .modal-progress-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--primary-light), #a855f7);
            background-size: 200% 100%;
            animation: moveGradient 2s linear infinite;
            width: 0%;
            transition: width 0.3s ease;
        }

        @keyframes moveGradient {
            0% {
                background-position: 100% 0;
            }

            100% {
                background-position: -100% 0;
            }
        }

        .modal-percent {
            font-family: 'Inter', monospace;
            font-size: 18px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 24px;
        }

        .modal-cancel {
            display: block;
            margin: 0 auto;
            padding: 10px 24px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 10px;
            color: #ef4444;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-cancel:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
        }

        #fileInput {
            display: none;
        }

        /* Responsive Layouts */
        @media (min-width: 1024px) {
            .app {
                flex-direction: row;
            }

            .sidebar {
                width: 320px;
                height: calc(100vh - 55px);
                border-right: none;
                overflow-y: auto;
                flex-shrink: 0;
            }


            .workspace {
                padding: 48px;
            }
        }

        @media (max-width: 1023px) {
            .sidebar {
                padding: 20px;
            }

            .sidebar-section {
                margin-bottom: 24px;
            }
        }

        @media (max-width: 767px) {
            header {
                padding: 12px 16px;
            }

            .logo h1 {
                display: none;
            }

            .menu-toggle {
                display: block;
            }

            .sidebar {
                display: none;
                position: fixed;
                top: 55px;
                left: 0;
                width: 100%;
                height: calc(100vh - 55px);
                z-index: 90;
                background: var(--bg-card);
                border-top: 1px solid var(--border);
                overflow-y: auto;
                padding: 16px;
            }

            .sidebar.active {
                display: block !important;
                z-index: 1050;
                /* Above regular content */
                animation: slideInFromLeft 0.3s ease-out;
            }

            @keyframes slideInFromLeft {
                from {
                    transform: translateX(-20px);
                    opacity: 0;
                }

                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            .workspace {
                padding: 12px;
                overflow-y: auto;
            }

            .upload-area {
                padding: 40px 24px;
            }

            .video-canvas-wrapper {
                min-height: 200px;
            }

            #renderCanvas {
                max-height: calc(100vh - 55px - 70px - 24px);
            }

            .video-controls {
                padding: 10px 12px;
                gap: 8px;
            }

            .play-btn,
            .ctrl-btn {
                width: 38px;
                height: 38px;
                font-size: 14px;
                border: none !important;
            }

            .time-display {
                font-size: 11px;
                min-width: 70px;
            }

            .sidebar-section {
                margin-bottom: 16px;
                padding-bottom: 16px;
                border-bottom: 1px solid var(--border);
            }

            .sidebar-section:last-child {
                border-bottom: none;
            }

            /* Modal Mobile */
            .modal {
                padding: 24px 16px;
                border-radius: 20px;
                width: 90%;
            }

            .modal-title {
                font-size: 20px;
            }

            .modal-subtitle {
                font-size: 13px;
                margin-bottom: 20px;
            }

            .modal-spinner {
                width: 40px;
                height: 40px;
                border-width: 3px;
                margin-bottom: 16px;
            }
        }

        @media (max-width: 480px) {
            .effect-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .logo-icon {
                width: 34px;
                height: 34px;
                font-size: 18px;
            }

            .header-status {
                padding: 6px 10px;
            }

            .header-status span {
                font-size: 11px;
            }
        }

        /* People List */
        .people-list {
            max-height: 120px;
        }

        @media (max-width: 767px) {
            .people-list {
                max-height: 60px;
            }

            /* Resize video viewer on mobile to 80% screen height */
            .video-card {
                height: 100%;
                max-height: 100%;
                border-radius: 0;
            }


            .video-container {
                height: 100%;
                /* Fill the card */
            }
        }

        /* Loading Progress Bar */
        .loading-progress {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
            display: none;
        }

        .loading-progress.active {
            display: block;
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-progress-fill.indeterminate {
            width: 30%;
            animation: indeterminateProgress 1.5s infinite;
        }

        /* AI Status Overlay - Desktop (Bottom Left) */
        .video-overlay-status {
            position: absolute;
            bottom: 24px;
            left: 24px;
            /* transform: translateX(-50%); REMOVED centering */
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            padding: 16px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            width: 280px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            /* Fixed width for consistency on desktop */
        }

        .overlay-params {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            max-height: none;
            overflow: hidden;
        }

        .overlay-slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
        }

        .overlay-slider {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
        }

        .overlay-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            pointer-events: auto;
        }

        .overlay-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            pointer-events: auto;
            border: none;
        }

        .overlay-progress-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .progress-row-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 2px;
        }

        .micro-progress-track {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .video-overlay-status .loading-progress {
            display: none;
            /* Hide old bar */
        }

        .micro-progress-fill {
            height: 100%;
            width: 0%;
            background: var(--primary);
            transition: width 0.3s ease;
        }

        /* Success state */
        .micro-progress-fill.success {
            background: #10b981;
            /* Green */
        }


        @keyframes indeterminateProgress {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(400%);
            }
        }

        .perf-warning {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(234, 179, 8, 0.95);
            color: #000;
            padding: 12px 20px;
            border-radius: 16px;
            font-size: 13px;
            font-weight: 700;
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: toastIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes toastIn {
            from {
                transform: translate(-50%, -100%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        /* Overlay Controls Styles */
        .overlay-row {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: center;
        }

        .overlay-controls {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 18px;
            padding: 2px;
            gap: 2px;
        }

        /* AI Status Overlay - Default (Desktop: Bottom Left) */
        .video-overlay-status {
            bottom: 24px;
            left: 24px;
            transform: none;
            width: 280px;
            max-width: none;
            padding: 16px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.85);
            /* Overlay styles continue... */
        }



        .overlay-btn {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        .overlay-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .video-overlay-status .status-dot {
            width: 6px;
            height: 6px;
            flex-shrink: 0;
            box-shadow: none;
        }

        .video-overlay-status span {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            margin-left: 6px;
        }

        /* Adjust loading progress inside overlay */
        .video-overlay-status .loading-progress {
            display: none;
        }

        /* Mobile / Responsive Overrides */
        @media (max-width: 768px) {
            .branding-large h1 {
                font-size: 24px !important;
            }

            .branding-large .logo-icon {
                font-size: 36px !important;
            }

            .workspace {
                padding: 0;
                margin: 0;
                height: 100vh;
                height: 100dvh;
                overflow: hidden;
            }

            .upload-area {
                padding: 24px;
                margin: 20px;
                max-width: calc(100% - 40px);
                border-width: 1px;
            }

            /* Force video container to absolute full screen */
            #videoContainer.active {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1000;
                background: #000;
            }

            .video-card {
                height: 100%;
                width: 100%;
                max-height: none;
                border-radius: 0;
                margin: 0;
                background: #000;
            }

            .video-canvas-wrapper {
                height: 100%;
                width: 100%;
                background: #000;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                object-fit: contain;
                /* Ensures video is fully visible but maximized */
            }


            .video-overlay-status {
                /* Mobile: Fixed above controls - 20% smaller */
                position: fixed;
                bottom: calc(82px + env(safe-area-inset-bottom));
                left: 50%;
                transform: translateX(-50%);
                width: 85%;
                max-width: 320px;
                padding: 10px;
                gap: 8px;
                border-radius: 20px;
                background: rgba(0, 0, 0, 0.85) !important;
                z-index: 1100;
            }




            .overlay-controls {
                flex-wrap: wrap;
                /* Allow wrapping if tight */
            }

            .overlay-btn {
                padding: 5px 8px;
                font-size: 9px;
            }


            .video-controls {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                padding: 12px 16px;
                padding-bottom: calc(12px + env(safe-area-inset-bottom));
                gap: 12px;
                background: rgba(10, 10, 10, 0.95) !important;
                backdrop-filter: blur(12px);
                border-radius: 0;
                z-index: 1200;
            }


            .play-btn,
            .ctrl-btn {
                width: 40px;
                height: 40px;
            }
        }

        /* Overlay collapsed state */
        .video-overlay-status.collapsed .overlay-params,
        .video-overlay-status.collapsed .overlay-progress-container,
        .video-overlay-status.collapsed .overlay-row,
        .video-overlay-status.collapsed .overlay-controls:not(#overlayToggle) {
            display: none !important;
        }

        .video-overlay-status.collapsed {
            padding: 8px;
        }
    </style>
</head>

<body>


    <div class="app">


        <main class="workspace">
            <div id="uploadArea">
                <!-- Desktop Version -->
                <div class="upload-area desktop-only" id="desktopUploadArea">
                    <div class="branding-large"
                        style="margin-bottom: 24px; display: flex; flex-direction: column; align-items: center;">
                        <img src="logo.jpg" alt="Logo" class="logo-icon"
                            style="width: 80px; height: 80px; margin-bottom: 12px; border-radius: 16px; object-fit: cover; box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);">
                        <h1
                            style="font-family: 'Outfit', sans-serif; font-size: 32px; font-weight: 800; background: linear-gradient(to bottom, #fff, #94a3b8); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin: 0;">
                            FaceAnon <span
                                style="font-size: 14px; background: var(--primary) !important; color: #ffffff !important; -webkit-text-fill-color: #ffffff !important; background-clip: initial !important; -webkit-background-clip: initial !important; padding: 4px 8px; border-radius: 6px; vertical-align: middle; margin-left: 6px; font-weight: 800; display: inline-block; line-height: 1;">PRO</span>
                        </h1>
                        <p
                            style="text-align: center; margin: 8px 0 0 0; font-size: 14px; letter-spacing: 2px; text-transform: uppercase; color: var(--text-muted); opacity: 0.8;">
                            for Police</p>
                    </div>
                    <!-- <div class="upload-icon">‚ú®</div> -->
                    <h2 class="upload-title">Empieza con tu Video</h2>
                    <p class="upload-subtitle">
                        Arrastra tu archivo aqu√≠ o usa el bot√≥n para explorar.<br>
                        Formatos soportados: MP4, MOV, WebM.
                    </p>
                    <div class="upload-btn">Abrir Archivo</div>
                </div>

                <!-- Mobile Version -->
                <div class="mobile-upload-area mobile-only" id="mobileUploadArea">
                    <div class="branding-large" style="margin-bottom: 20px; text-align: center;">
                        <img src="logo.jpg" alt="Logo"
                            style="width: 100px; height: 100px; border-radius: 20px; margin-bottom: 16px; box-shadow: 0 8px 30px rgba(99, 102, 241, 0.4);">
                        <h1 style="font-size: 28px; font-weight: 800; margin: 0; color: white;">FaceAnon PRO</h1>
                        <p
                            style="text-align: center; margin: 8px 0 0 0; font-size: 12px; letter-spacing: 2px; text-transform: uppercase; color: rgba(255,255,255,0.6);">
                            for Police</p>
                    </div>

                    <button class="mobile-upload-btn">
                        <span style="font-size: 24px;">üìÇ</span>
                        <span>Tocar para Abrir Video</span>
                    </button>

                    <button id="pwaInstallBtnMobile" class="action-btn"
                        style="margin-top: 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: white; padding: 12px 20px; border-radius: 12px; font-size: 13px; display: none; align-items: center; gap: 8px; width: 100%; max-width: 300px; justify-content: center;">
                        <span>üì≤</span> Instalar como aplicaci√≥n
                    </button>

                    <p style="margin-top: 24px; font-size: 12px; color: rgba(255,255,255,0.3);">
                        Procesamiento 100% Local y Seguro
                    </p>
                </div>
            </div>

            <div id="videoContainer">
                <div class="video-card">
                    <div class="video-loader" id="videoLoader">
                        <div class="loader-spinner"></div>
                        <div class="loader-text">Cargando video...</div>
                        <div class="loader-progress-track">
                            <div class="loader-progress-fill" id="loaderFill"></div>
                        </div>
                    </div>
                    <div class="video-canvas-wrapper">
                        <canvas id="renderCanvas"></canvas>
                    </div>

                    <!-- AI Status Overlay -->
                    <div class="video-overlay-status" id="aiStatus">
                        <!-- Toggle Button -->
                        <button id="overlayToggle" class="overlay-btn"
                            style="width: 100%; margin-bottom: 8px; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center; padding: 6px 14px; position: relative;">
                            <span id="overlayToggleText"
                                style="display: flex; align-items: center; gap: 8px; font-weight: 700;">‚öôÔ∏è
                                Controles</span>
                            <span id="toggleIcon"
                                style="font-size: 14px; opacity: 0.7; position: absolute; right: 14px; top: 50%; transform: translateY(-50%);">‚åÑ</span>
                        </button>

                        <!-- Model Selection -->
                        <div id="modelSelection">
                            <div
                                style="display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 4px;">
                                <div style="font-size: 10px; color: rgba(255,255,255,0.8);">Modelo de Inteligencia
                                    Artificial de Detecci√≥n de Rostros:</div>
                                <div class="overlay-controls" style="padding: 1px;">
                                    <button class="overlay-btn active" data-model="auto"
                                        style="margin: 0; padding: 2px 10px; font-size: 9px; min-width: auto; height: auto;">Auto</button>
                                </div>
                            </div>
                            <div class="overlay-controls" style="flex-wrap: wrap; justify-content: center;">
                                <button class="overlay-btn" data-model="ssd">SSD</button>
                                <button class="overlay-btn" data-model="tiny">Tiny</button>
                                <button class="overlay-btn" data-model="mobile">Mobile</button>
                            </div>
                        </div>

                        <!-- Model Description -->
                        <div id="modelDescription"
                            style="font-size: 9px; color: rgba(255,255,255,0.7); text-align: left; margin-top: 6px; min-height: 48px; line-height: 1.4; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 8px;">
                            Selecci√≥n autom√°tica inteligente seg√∫n tu dispositivo.
                        </div>

                        <!-- Status Info -->
                        <div class="overlay-row">
                            <div class="status-dot"></div>
                            <span id="mainStatusText">Iniciando...</span>
                        </div>

                        <!-- Dual Progress Bars -->
                        <div class="overlay-progress-container">
                            <!-- Detector -->
                            <div>
                                <div class="progress-row-label">
                                    <span>Detector</span>
                                    <span id="detStatusText">0%</span>
                                </div>
                                <div class="micro-progress-track">
                                    <div class="micro-progress-fill" id="detFill"></div>
                                </div>
                            </div>
                            <!-- Recognition -->
                            <div>
                                <div class="progress-row-label">
                                    <span>Reconocimiento</span>
                                    <span id="recStatusText">Pendiente</span>
                                </div>
                                <div class="micro-progress-track">
                                    <div class="micro-progress-fill" id="recFill"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Parameters (Moved from Sidebar) -->
                        <div class="overlay-params">
                            <div style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px;">Efecto:
                            </div>
                            <div class="overlay-controls" id="effectSelection" style="justify-content: center;">
                                <button class="overlay-btn active" data-effect="pixelate">Pixel</button>
                                <button class="overlay-btn" data-effect="blur">Blur</button>
                                <button class="overlay-btn" data-effect="solid">Solid</button>
                            </div>

                            <div
                                style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px; margin-top: 8px;">
                                Intensidad:</div>
                            <div class="overlay-slider-row">
                                <input type="range" class="overlay-slider" id="intensity" min="5" max="50" value="15"
                                    style="flex: 1;">
                                <span id="intensityVal">15</span>
                            </div>
                            <div
                                style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px; margin-top: 8px;">
                                Margen:</div>
                            <div class="overlay-slider-row">
                                <input type="range" class="overlay-slider" id="paddingSlider" min="0" max="100"
                                    value="10" style="flex: 1;">
                                <span id="paddingVal">10%</span>
                            </div>

                            <!-- Trim Controls - Dual Range Slider -->
                            <div
                                style="font-size: 10px; color: rgba(255,255,255,0.8); margin-bottom: 4px; margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                                Rango de Tiempo:</div>
                            <div style="position: relative; padding: 0 8px; margin: 8px 0;">
                                <!-- Track background -->
                                <div
                                    style="position: relative; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px;">
                                    <!-- Active range highlight -->
                                    <div id="trimRangeHighlight"
                                        style="position: absolute; height: 100%; background: var(--primary); border-radius: 2px; left: 0%; width: 100%;">
                                    </div>
                                </div>
                                <!-- Dual sliders overlapped -->
                                <input type="range" class="overlay-slider" id="trimStartSlider" min="0" max="100"
                                    value="0" step="0.1"
                                    style="position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; background: transparent;">
                                <input type="range" class="overlay-slider" id="trimEndSlider" min="0" max="100"
                                    value="100" step="0.1"
                                    style="position: absolute; top: 0; left: 0; width: 100%; pointer-events: none; background: transparent;">
                            </div>
                            <div
                                style="display: flex; justify-content: space-between; font-size: 9px; color: rgba(255,255,255,0.6); padding: 0 8px;">
                                <span id="trimStartVal">0.0s</span>
                                <span id="trimEndVal">Fin</span>
                            </div>

                            <!-- Action Buttons (New) -->
                            <div class="overlay-actions" style="display: flex; gap: 8px; margin-top: 4px;">
                                <button class="action-btn" id="processBtn" disabled
                                    style="flex: 1; background: var(--primary); color: white; padding: 6px; border-radius: 8px; font-size: 11px; font-weight: 600; border: none; cursor: pointer;">
                                    ‚ö° Procesar
                                </button>
                                <button class="action-btn" id="exportBtn" disabled
                                    style="flex: 1; background: var(--bg-hover); color: white; padding: 6px; border-radius: 8px; font-size: 11px; font-weight: 600; border: 1px solid var(--border); cursor: pointer;">
                                    üíæ Guardar
                                </button>
                            </div>

                            <!-- New Video (Moved from Sidebar) -->
                            <button id="newBtn"
                                style="width: 100%; background: transparent; border: 1px solid rgba(255,255,255,0.1); color: rgba(255,255,255,0.7); padding: 6px; border-radius: 8px; font-size: 11px; cursor: pointer; margin-top: 4px;">
                                üìÅ Abrir Otro Video
                            </button>

                            <!-- PWA Install inside settings -->
                            <button id="pwaInstallBtnSettings"
                                style="width: 100%; background: rgba(99, 102, 241, 0.1); border: 1px solid var(--primary); color: var(--primary-light); padding: 8px; border-radius: 8px; font-size: 10px; cursor: pointer; margin-top: 12px; display: none; align-items: center; justify-content: center; gap: 6px; font-weight: 700;">
                                üì≤ INSTALAR APP (S√≠n Barras)
                            </button>
                        </div>
                    </div>
                </div>

                <div class="video-controls">
                    <button class="ctrl-btn" id="rewindBtn" title="Atr√°s 1s">‚àí1s</button>
                    <button class="play-btn" id="playBtn">‚ñ∂</button>
                    <button class="ctrl-btn" id="forwardBtn" title="Adelante 1s">+1s</button>
                    <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
                    <div class="progress-track" id="progressTrack">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
            </div>
    </div>
    </main>
    </div>

    <input type="file" id="fileInput" accept="video/*">

    <div class="modal-overlay" id="modal">
        <div class="modal">
            <div class="modal-spinner"></div>
            <div class="modal-title" id="modalTitle">Procesando</div>
            <div class="modal-subtitle" id="modalSubtitle">Preparando...</div>
            <div class="modal-progress">
                <div class="modal-progress-fill" id="modalFill"></div>
            </div>
            <div class="modal-percent" id="modalPercent">0%</div>

            <!-- Success Keys -->
            <div class="modal-actions" id="modalActions"
                style="display: none; flex-direction: row; gap: 12px; margin-top: 8px;">
                <button class="upload-btn" id="btnDownload" style="flex: 1; border: none; cursor: pointer;">
                    üíæ Guardar
                </button>
                <button class="upload-btn" id="btnShare"
                    style="flex: 1; background: var(--bg-hover); border: 1px solid var(--border); cursor: pointer;">
                    üì§ Galer√≠a / Compartir
                </button>

            </div>

            <button class="modal-cancel" id="cancelBtn">Cancelar</button>
        </div>
    </div>

    <script>
        // App State
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

        const state = {
            effect: 'pixelate',
            intensity: 15,
            padding: 0.1, // 10% por defecto
            detectionMode: 'all',
            trimStart: 0,
            trimEnd: null, // null means end of video
            previewMode: 'effects', // ALWAYS effects
            processedBlob: null,
            videoBlobUrl: null,
            isPlaying: false,
            isProcessing: false,
            processingCanceled: false,
            modelReady: false,
            recognitionReady: false,
            detectorType: null,
            modelPreference: 'auto', // Use Auto by default
            videoWidth: 0,
            videoHeight: 0,
            lastKnownFaces: [],
            knownFaces: [], // { id, descriptor, name, excluded }
            trackingEnabled: true,
            highlightedPersonId: null,
            previewPersistenceCount: 0,
            isLoadingModel: false,
            perfWarningShown: false
        };

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('SW Registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('SW Registration failed:', error);
                    });
            });
        }

        // PWA Installation Handler
        let deferredPrompt;
        const installBtnMobile = document.getElementById('pwaInstallBtnMobile');
        const installBtnSettings = document.getElementById('pwaInstallBtnSettings');

        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later.
            deferredPrompt = e;
            // Update UI to notify the user they can add to home screen
            if (installBtnMobile) installBtnMobile.style.display = 'flex';
            if (installBtnSettings) installBtnSettings.style.display = 'flex';
        });

        async function handleInstallClick() {
            if (!deferredPrompt) {
                // FALLBACK for iOS: Inform user how to add manually
                if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    alert('üì≤ Para instalar FaceAnon en tu iPhone:\n\n1. Pulsa el bot√≥n "Compartir" (el cuadrado con flecha abajo).\n2. Selecciona "A√±adir a pantalla de inicio".\n\n¬°Listo! Podr√°s usarla sin barras de navegaci√≥n.');
                }
                return;
            }
            // Show the prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`User responded to the install prompt: ${outcome}`);
            // We've used the prompt, and can't use it again, throw it away
            deferredPrompt = null;
            // Hide the buttons
            if (installBtnMobile) installBtnMobile.style.display = 'none';
            if (installBtnSettings) installBtnSettings.style.display = 'none';
        }

        if (installBtnMobile) installBtnMobile.addEventListener('click', handleInstallClick);
        if (installBtnSettings) installBtnSettings.addEventListener('click', handleInstallClick);

        // Show install button for iOS users specifically (since they don't trigger beforeinstallprompt)
        if (/iPhone|iPad|iPod/.test(navigator.userAgent) && !window.navigator.standalone) {
            if (installBtnMobile) installBtnMobile.style.display = 'flex';
            if (installBtnSettings) installBtnSettings.style.display = 'flex';
        }

        // DOM Elements
        const elements = {
            uploadArea: document.getElementById('uploadArea'),
            fileInput: document.getElementById('fileInput'),
            videoContainer: document.getElementById('videoContainer'),
            renderCanvas: document.getElementById('renderCanvas'),
            renderCtx: document.getElementById('renderCanvas').getContext('2d'),
            playBtn: document.getElementById('playBtn'),
            progressFill: document.getElementById('progressFill'),
            progressTrack: document.getElementById('progressTrack'),
            timeDisplay: document.getElementById('timeDisplay'),
            intensitySlider: document.getElementById('intensity'),
            intensityVal: document.getElementById('intensityVal'),
            paddingSlider: document.getElementById('paddingSlider'),
            paddingVal: document.getElementById('paddingVal'),
            processBtn: document.getElementById('processBtn'),
            exportBtn: document.getElementById('exportBtn'),
            newBtn: document.getElementById('newBtn'),
            modal: document.getElementById('modal'),
            modalFill: document.getElementById('modalFill'),
            modalPercent: document.getElementById('modalPercent'),
            modalTitle: document.getElementById('modalTitle'),
            modalSubtitle: document.getElementById('modalSubtitle'),
            aiStatus: document.getElementById('aiStatus'),
            cancelBtn: document.getElementById('cancelBtn'),
            effectOptions: document.querySelectorAll('#effectSelection button'),
            modelBtns: document.querySelectorAll('#modelSelection button'),
            menuToggle: document.getElementById('menuToggle'),
            sidebar: document.querySelector('.sidebar'),
            peopleList: document.getElementById('peopleList'),
            rewindBtn: document.getElementById('rewindBtn'),
            forwardBtn: document.getElementById('forwardBtn')
        };

        const FACE_RECOGNITION_THRESHOLD = 0.5; // Distancia para considerar la misma persona

        // Video element (created dynamically)
        const video = document.createElement('video');
        video.muted = true;
        video.playsInline = true;
        // Optimization for mobile: "In-View" strategy.
        // We make it 1x1, nearly transparent, and fixed at top-left.
        // This forces the OS to treat it as "visible" and render frames, preventing hangs during seek/detection.
        video.style.position = 'fixed';
        video.style.top = '0';
        video.style.left = '0';
        video.style.width = '10px';
        video.style.height = '10px';
        video.style.opacity = '0.001';
        video.style.pointerEvents = 'none';
        video.style.zIndex = '-1000';
        video.style.visibility = 'visible'; // Important!

        // Critical Attributes for iOS
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.setAttribute('preload', 'auto');

        document.body.appendChild(video);

        // Processing canvas
        const processCanvas = document.createElement('canvas');
        document.body.appendChild(processCanvas);

        // Initialize
        async function init() {
            // Register Service Worker for offline support
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(reg => console.log('SW Registered!', reg))
                        .catch(err => console.log('SW Registration failed:', err));
                });
            }

            setupEventListeners();
            await loadAI();
        }

        // Load AI Model with local files priority
        // Progress Helpers
        function updateModelStatus(type, percent, text) {
            const fill = document.getElementById(`${type}Fill`);
            const status = document.getElementById(`${type}StatusText`);
            if (fill) {
                fill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
                if (percent >= 100) fill.classList.add('success');
            }
            if (status) status.textContent = text;
        }

        async function downloadWithProgress(url, onProgress) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const contentLength = +response.headers.get('Content-Length');
                const reader = response.body.getReader();
                let receivedLength = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    receivedLength += value.length;

                    if (contentLength) {
                        onProgress((receivedLength / contentLength) * 100);
                    }
                }
            } catch (e) {
                // Ignore errors here
            }
        }

        async function prefetchFiles(baseUrl, files, updateFn) {
            let completed = 0;
            const total = files.length;

            for (const file of files) {
                updateFn((completed / total) * 100, `Descargando ${file.split('_')[0]}...`);
                await downloadWithProgress(`${baseUrl}${file}`, (pct) => {
                    const totalPct = ((completed + (pct / 100)) / total) * 100;
                    updateFn(totalPct, `Cargando ${Math.round(pct)}%`);
                });
                completed++;
            }
            updateFn(100, 'Procesando...');
        }

        // Load AI Model with local files priority
        async function loadAI() {
            // 1. Load Face-API Script
            if (typeof faceapi === 'undefined') {
                try {
                    const script = document.createElement('script');
                    script.src = './js/face-api.js';
                    document.head.appendChild(script);
                    await new Promise(r => script.onload = r);
                    await new Promise(r => setTimeout(r, 500));
                } catch (e) {
                    console.error('Failed to load face-api source');
                }
            }

            if (typeof faceapi === 'undefined') {
                document.getElementById('mainStatusText').innerText = 'Error: Face-API no carg√≥';
                return;
            }

            const modelUrls = [
                './models/',
                'https://justadudewhohacks.github.io/face-api.js/models/'
            ];

            let loadedModel = null;

            if (state.isLoadingModel) return;
            state.isLoadingModel = true;

            // Desactivar botones durante la carga
            if (elements.modelBtns) elements.modelBtns.forEach(b => b.disabled = true);

            const statusEl = document.getElementById('mainStatusText');
            if (statusEl) statusEl.innerText = 'Iniciando Motores IA...';

            // --- STAGE 1: DETECTOR ---
            const modelPref = state.modelPreference;
            const useAuto = modelPref === 'auto';

            let detectorType = modelPref;
            if (useAuto) {
                detectorType = isMobile ? 'tiny' : 'ssd';
            }

            updateModelStatus('det', 0, 'Iniciando...');

            // Load based on selected model
            try {
                if (detectorType === 'mobile') {
                    // BlazeFace (Ultra Light for Mobile)
                    updateModelStatus('det', 30, 'Cargando Mobile...');
                    if (typeof blazeface !== 'undefined') {
                        window.blazeDetector = await blazeface.load();
                        loadedModel = 'mobile';
                        updateModelStatus('det', 100, 'Mobile Listo');
                    } else {
                        throw new Error('Script Mobile no cargado');
                    }
                } else if (detectorType === 'tiny') {
                    // Tiny Face Detector
                    const tinyFiles = ['tiny_face_detector_model-weights_manifest.json', 'tiny_face_detector_model-shard1'];
                    for (const modelUrl of modelUrls) {
                        try {
                            await prefetchFiles(modelUrl, tinyFiles, (pct, text) => updateModelStatus('det', pct, text));
                            await faceapi.nets.tinyFaceDetector.loadFromUri(modelUrl);
                            loadedModel = 'tiny';
                            updateModelStatus('det', 100, 'Tiny Listo');
                            break;
                        } catch (e) {
                            console.warn('Tiny fallback', e);
                        }
                    }
                } else {
                    // SSD MobileNet (default)
                    const ssdFiles = ['ssd_mobilenetv1_model-weights_manifest.json', 'ssd_mobilenetv1_model-shard1', 'ssd_mobilenetv1_model-shard2'];
                    for (const modelUrl of modelUrls) {
                        try {
                            await prefetchFiles(modelUrl, ssdFiles, (pct, text) => updateModelStatus('det', pct, text));
                            await faceapi.nets.ssdMobilenetv1.loadFromUri(modelUrl);
                            loadedModel = 'ssd';
                            updateModelStatus('det', 100, 'SSD Listo');
                            break;
                        } catch (e) {
                            console.warn('SSD fallback', e);
                        }
                    }
                }

                if (!loadedModel) {
                    updateModelStatus('det', 0, 'Fallo Cr√≠tico');
                    throw new Error('No detector loaded');
                }

                // Configure Detector
                if (loadedModel === 'ssd') {
                    // OPTIMIZED: Faster SSD with reduced false positives
                    // Higher confidence (0.5) = fewer false detections + faster processing
                    // Lower maxResults (50) = less computation overhead
                    window.faceDetector = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5, maxResults: 50 });
                } else if (loadedModel === 'tiny') {
                    // Optimized input size for mobile performance vs accuracy
                    const tSize = isMobile ? 320 : 512;
                    window.faceDetector = new faceapi.TinyFaceDetectorOptions({ inputSize: tSize, scoreThreshold: 0.3 });
                } else if (loadedModel === 'mobile') {
                    window.faceDetector = null; // Uses blazeDetector
                }
                state.detectorType = loadedModel;

                // --- STAGE 2: RECOGNITION ---
                const recogFiles = [
                    'face_landmark_68_model-weights_manifest.json', 'face_landmark_68_model-shard1',
                    'face_recognition_model-weights_manifest.json', 'face_recognition_model-shard1', 'face_recognition_model-shard2'
                ];

                updateModelStatus('rec', 0, 'Pendiente...');
                state.recognitionReady = false;

                for (const modelUrl of modelUrls) {
                    try {
                        await prefetchFiles(modelUrl, recogFiles, (pct, text) => updateModelStatus('rec', pct, text));

                        await faceapi.nets.faceLandmark68Net.loadFromUri(modelUrl);
                        await faceapi.nets.faceRecognitionNet.loadFromUri(modelUrl);

                        state.recognitionReady = true;
                        updateModelStatus('rec', 100, 'Reconocimiento Listo');
                        break;
                    } catch (e) {
                        console.warn('Recog fallback', e);
                    }
                }

                if (!state.recognitionReady) {
                    updateModelStatus('rec', 0, 'No Disponible');
                }

                // Finalize
                state.modelReady = true;
                const modelNames = {
                    'ssd': 'SSD Precision',
                    'tiny': 'Tiny Fast',
                    'mobile': 'Mobile Ultra'
                };
                const modelName = modelNames[state.detectorType] || state.detectorType || 'Cargando...';
                const statusStr = `IA Lista (${modelName})`;
                if (statusEl) statusEl.innerText = statusStr;
                updateAIStatus(true);

            } catch (err) {
                console.error('loadAI failed:', err);
                updateAIStatus(false);
                const statusEl = document.getElementById('mainStatusText');
                if (statusEl) statusEl.innerText = 'Error al cargar IA';
            } finally {
                state.isLoadingModel = false;
                if (elements.modelBtns) elements.modelBtns.forEach(b => b.disabled = false);
            }
        }

        function updateAIStatus(ready) {
            const dot = elements.aiStatus.querySelector('.status-dot');
            const span = document.getElementById('mainStatusText');
            const progress = document.getElementById('aiProgress');

            if (ready) {
                dot.classList.add('ready');
                const modelNames = {
                    'ssd': 'SSD Precision',
                    'tiny': 'Tiny Fast',
                    'mobile': 'Mobile Ultra'
                };
                const modelName = modelNames[state.detectorType] || state.detectorType || 'Cargando...';
                span.textContent = `IA Lista (${modelName})`;
                // Hide progress bar when ready
                if (progress) progress.classList.remove('active');
                if (state.videoWidth > 0) {
                    elements.processBtn.disabled = false;
                }
            } else {
                dot.classList.remove('ready');
                span.textContent = 'IA No disp.';
                if (progress) progress.classList.remove('active');
            }
        }

        function updateLoadingProgress(percent) {
            const progressBar = document.getElementById('aiProgressFill');
            if (progressBar) {
                progressBar.classList.remove('indeterminate');
                progressBar.style.width = percent + '%';
            }
        }

        // File Handling
        function handleFileSelect(e) {
            const file = e.target.files ? e.target.files[0] : null;
            if (file) loadVideo(file);
        }

        function handleDrop(e) {
            e.preventDefault();
            if (elements.uploadArea) elements.uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) loadVideo(file);
        }

        function loadVideo(file) {
            // Validate type
            if (file.type.indexOf('video') === -1) {
                alert('Por favor selecciona un archivo de video v√°lido.');
                return;
            }

            // Show loader
            if (elements.uploadArea) elements.uploadArea.style.display = 'none';
            if (elements.videoLoader) elements.videoLoader.classList.add('active');

            // Reset App
            if (typeof resetAppState === 'function') resetAppState();

            // Load
            const url = URL.createObjectURL(file);
            video.src = url;
            video.muted = false; // Enable audio for preview
            video.volume = 1.0;
            video.load();

            video.onloadeddata = () => {
                state.videoWidth = video.videoWidth;
                state.videoHeight = video.videoHeight;

                if (elements.renderCanvas) {
                    elements.renderCanvas.width = state.videoWidth;
                    elements.renderCanvas.height = state.videoHeight;
                }
                processCanvas.width = state.videoWidth;
                processCanvas.height = state.videoHeight;

                console.log(`Video loaded: ${state.videoWidth}x${state.videoHeight}`);

                if (elements.videoContainer) elements.videoContainer.classList.add('active');

                // Force initial renders
                renderFrame();

                setTimeout(() => {
                    if (elements.videoLoader) elements.videoLoader.classList.remove('active');
                }, 600);

                if (typeof updateTimeDisplay === 'function') updateTimeDisplay();
                if (elements.processBtn) elements.processBtn.disabled = !state.modelReady;
            };

            video.onerror = () => {
                alert('Error al cargar el video.');
            };
        }

        // --- CORE PLAYBACK & PREVIEW LOOP ---
        let previewParams = {
            animationId: null
        };

        function togglePlay() {
            if (video.paused) {
                if (video.ended || video.currentTime >= video.duration) video.currentTime = 0;
                video.play().then(() => {
                    state.isPlaying = true;
                    elements.playBtn.textContent = '‚è∏';
                    startPreviewLoop();
                });
            } else {
                video.pause();
                state.isPlaying = false;
                elements.playBtn.textContent = '‚ñ∂';
                stopPreviewLoop();
            }
        }

        function startPreviewLoop() {
            if (previewParams.animationId) cancelAnimationFrame(previewParams.animationId);

            function loop() {
                if (video.paused || video.ended) {
                    state.isPlaying = false;
                    elements.playBtn.textContent = '‚ñ∂';
                    return;
                }

                // 1. Render Video Frame
                if (video.readyState >= 2) {
                    renderFrame();
                }

                // 2. Continuous Background Detection
                if (!state.isProcessing && state.modelReady) {
                    runBackgroundDetection();
                }

                // 3. Update Progress UI
                updateTimeDisplay();

                previewParams.animationId = requestAnimationFrame(loop);
            }
            previewParams.animationId = requestAnimationFrame(loop);
        }

        function stopPreviewLoop() {
            if (previewParams.animationId) {
                cancelAnimationFrame(previewParams.animationId);
                previewParams.animationId = null;
            }
        }

        function renderFrame() {
            if (!state.videoWidth) return;
            try {
                // Draw original
                elements.renderCtx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);
                // Draw effects using last known tracks
                drawCachedEffects(true);
            } catch (e) {
                console.error('Render error:', e);
            }
        }

        function updateTimeDisplay() {
            const percent = (video.currentTime / video.duration) * 100;
            elements.progressFill.style.width = `${percent}%`;
            elements.timeDisplay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return "0:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Seek function
        function seek(e) {
            if (!video.duration) return;
            const rect = elements.progressTrack.getBoundingClientRect();
            const position = (e.clientX - rect.left) / rect.width;
            video.currentTime = position * video.duration;
            updateTimeDisplay();
        }

        // Event Listeners
        function setupEventListeners() {
            console.log('Setting up event listeners...');

            // Menu Toggle
            if (elements.menuToggle && elements.sidebar) {
                elements.menuToggle.addEventListener('click', (e) => {
                    e.preventDefault();
                    elements.sidebar.classList.toggle('active');
                });
            }

            // Upload
            if (elements.uploadArea && elements.fileInput) {
                elements.uploadArea.addEventListener('click', () => elements.fileInput.click());
                elements.fileInput.addEventListener('change', handleFileSelect);
            }

            // Drag and drop
            elements.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.uploadArea.classList.add('dragover');
            });
            elements.uploadArea.addEventListener('dragleave', () => {
                elements.uploadArea.classList.remove('dragover');
            });
            elements.uploadArea.addEventListener('drop', handleDrop);

            // Playback
            elements.playBtn.addEventListener('click', togglePlay);
            elements.progressTrack.addEventListener('click', seek);
            elements.rewindBtn.addEventListener('click', () => {
                video.currentTime = Math.max(0, video.currentTime - 1);
                updateTimeDisplay();
            });
            elements.forwardBtn.addEventListener('click', () => {
                video.currentTime = Math.min(video.duration, video.currentTime + 1);
                updateTimeDisplay();
            });

            // Intensity
            elements.intensitySlider.addEventListener('input', (e) => {
                state.intensity = parseInt(e.target.value);
                elements.intensityVal.textContent = state.intensity;
            });

            // Effect selection
            elements.effectOptions.forEach(option => {
                option.addEventListener('click', () => {
                    elements.effectOptions.forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    state.effect = option.dataset.effect;
                    renderFrame();
                });
            });



            // Model preference with descriptions
            const modelDescriptions = {
                'auto': '<b>MODO INTELIGENTE:</b> El sistema analiza tu hardware y elige el mejor balance entre velocidad y precisi√≥n autom√°ticamente.',
                'ssd': '<b>MODELO SSD (PRO):</b><br>‚Ä¢ <b>Sirve para:</b> M√°xima precisi√≥n legal. Caras lejanas, perfiles y condiciones de poca luz.<br>‚Ä¢ <b>No sirve para:</b> M√≥viles antiguos (mucho calor/lentitud).<br>‚Ä¢ <b>Sugerencia:</b> √ösalo para el procesado final antes de descargar.',
                'tiny': '<b>MODELO TINY (R√ÅPIDO):</b><br>‚Ä¢ <b>Sirve para:</b> Uso diario √°gil. Caras a media distancia y seguimiento estable.<br>‚Ä¢ <b>No sirve para:</b> Vigilancia masiva con caras muy peque√±as al fondo.<br>‚Ä¢ <b>Sugerencia:</b> La mejor opci√≥n para editar r√°pido en m√≥viles modernos.',
                'mobile': '<b>MODELO MOBILE (LIGERO):</b><br>‚Ä¢ <b>Sirve para:</b> Ahorro de bater√≠a y fluidez total en hardware limitado o antiguo.<br>‚Ä¢ <b>No sirve para:</b> Escenas con sujetos lejanos o movimientos muy bruscos.<br>‚Ä¢ <b>Sugerencia:</b> √ösalo si solo necesitas tapar caras en planos cercanos.'
            };

            elements.modelBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    elements.modelBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.modelPreference = btn.dataset.model;

                    // Update description
                    const descEl = document.getElementById('modelDescription');
                    if (descEl) descEl.innerHTML = modelDescriptions[state.modelPreference] || '';

                    // Forzar recarga de IA con la nueva preferencia
                    state.modelReady = false;
                    updateAIStatus(false);
                    try {
                        await loadAI();
                    } catch (e) {
                        console.error('Error al cambiar de modelo:', e);
                        state.isLoadingModel = false;
                        elements.modelBtns.forEach(b => b.disabled = false);
                    }
                });
            });

            // Padding slider
            elements.paddingSlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                state.padding = val / 100;
                elements.paddingVal.textContent = val + '%';
                renderFrame();
            });



            // Preview toggle removed - always effects
            // const previewOriginal = document.getElementById('previewOriginal');
            // const previewEffects = document.getElementById('previewEffects');

            // Process video
            elements.processBtn.addEventListener('click', processVideo);

            // Export
            elements.exportBtn.addEventListener('click', exportVideo);

            // New video
            // Nuevo Video button - open file selector
            elements.newBtn.addEventListener('click', () => {
                elements.fileInput.click();
            });

            // Cancel processing / Close Modal
            elements.cancelBtn.addEventListener('click', () => {
                if (state.isProcessing) {
                    console.log('User requested cancellation');
                    state.processingCanceled = true;
                    // Force immediate stop of video and hidden elements
                    video.pause();
                    elements.modal.classList.remove('active');
                    state.isProcessing = false;
                } else {
                    // Close modal if finished
                    elements.modal.classList.remove('active');
                    // Reset text for next time
                    elements.cancelBtn.textContent = 'Cancelar';
                }
            });

            // Overlay Toggle
            const overlayToggle = document.getElementById('overlayToggle');
            if (overlayToggle) {
                overlayToggle.addEventListener('click', () => {
                    const overlay = document.getElementById('aiStatus');
                    overlay.classList.toggle('collapsed');
                    const isCollapsed = overlay.classList.contains('collapsed');
                    const toggleIcon = document.getElementById('toggleIcon');
                    const toggleText = document.getElementById('overlayToggleText');

                    if (toggleIcon) toggleIcon.textContent = isCollapsed ? '‚åÉ' : '‚åÑ';
                    // Text remains static: '‚öôÔ∏è Controles'
                });
            }

            // Trim Controls with Dual Range Slider
            const trimStartSlider = document.getElementById('trimStartSlider');
            const trimEndSlider = document.getElementById('trimEndSlider');
            const trimStartVal = document.getElementById('trimStartVal');
            const trimEndVal = document.getElementById('trimEndVal');
            const trimRangeHighlight = document.getElementById('trimRangeHighlight');

            function updateRangeHighlight() {
                if (!trimStartSlider || !trimEndSlider || !trimRangeHighlight) return;
                const max = parseFloat(trimStartSlider.max);
                const startPercent = (parseFloat(trimStartSlider.value) / max) * 100;
                const endPercent = (parseFloat(trimEndSlider.value) / max) * 100;

                trimRangeHighlight.style.left = startPercent + '%';
                trimRangeHighlight.style.width = (endPercent - startPercent) + '%';
            }

            if (trimStartSlider && trimEndSlider) {
                // Update slider max values when video loads
                video.addEventListener('loadedmetadata', () => {
                    const duration = video.duration;
                    trimStartSlider.max = duration;
                    trimEndSlider.max = duration;
                    trimEndSlider.value = duration;
                    trimEndVal.textContent = duration.toFixed(1) + 's';
                    updateRangeHighlight();
                });

                trimStartSlider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.trimStart = val;
                    trimStartVal.textContent = val.toFixed(1) + 's';

                    // Ensure start doesn't exceed end
                    if (state.trimStart >= state.trimEnd) {
                        state.trimStart = Math.max(0, state.trimEnd - 0.1);
                        trimStartSlider.value = state.trimStart;
                        trimStartVal.textContent = state.trimStart.toFixed(1) + 's';
                    }

                    updateRangeHighlight();
                });

                trimEndSlider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    state.trimEnd = val;
                    trimEndVal.textContent = val.toFixed(1) + 's';

                    // Ensure end doesn't go below start
                    if (state.trimEnd <= state.trimStart) {
                        state.trimEnd = Math.min(video.duration, state.trimStart + 0.1);
                        trimEndSlider.value = state.trimEnd;
                        trimEndVal.textContent = state.trimEnd.toFixed(1) + 's';
                    }

                    updateRangeHighlight();
                });
            }

            // Reset Trim when loading new video (handled in resetAppState)

            video.addEventListener('timeupdate', updateTimeDisplay);

            // Video ended - Stop detection loop
            video.addEventListener('ended', () => {
                state.isPlaying = false;
                elements.playBtn.textContent = '‚ñ∂';
                stopPreviewLoop();
                console.log('Video ended: Stopped detection loop');
            });

            // Universal Seek Update: Update effect/detection whenever time changes (manual seek)
            video.addEventListener('seeked', () => {
                resetTracking(); // Reset tracking history on seek
                if (video.paused && state.modelReady && !state.isProcessing) {
                    renderFrame();
                }
            });

            // Mobile Menu
            if (elements.menuToggle) {
                elements.menuToggle.addEventListener('click', () => {
                    elements.sidebar.classList.toggle('active');
                    elements.menuToggle.textContent = elements.sidebar.classList.contains('active') ? '‚úï' : '‚ò∞';
                });
            }

            // Cerrar sidebar en m√≥vil tras seleccionar
            const closeSidebarOnMobile = () => {
                if (window.innerWidth < 768) {
                    elements.sidebar.classList.remove('active');
                    elements.menuToggle.textContent = '‚ò∞';
                }
            };

            elements.effectOptions.forEach(opt => opt.addEventListener('click', closeSidebarOnMobile));
            elements.modelBtns.forEach(opt => opt.addEventListener('click', closeSidebarOnMobile));
        }

        // File handling
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) loadVideo(file);
        }

        function handleDrop(e) {
            e.preventDefault();
            elements.uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideo(file);
            }
        }

        function loadVideo(file) {
            // RESET APP STATE when loading new video
            resetAppState();

            // Show loading state
            elements.uploadArea.style.display = 'none';
            elements.videoContainer.classList.add('active');
            document.body.classList.add('video-active');
            const loader = document.getElementById('videoLoader');
            if (loader) loader.classList.add('active');

            if (state.videoBlobUrl) {
                URL.revokeObjectURL(state.videoBlobUrl);
            }

            // Small delay to allow UI to update and show loader if file is large
            setTimeout(() => {
                state.videoBlobUrl = URL.createObjectURL(file);
                video.src = state.videoBlobUrl;
            }, 50);

            video.onloadedmetadata = () => {
                state.videoWidth = video.videoWidth;
                state.videoHeight = video.videoHeight;

                // Setup canvases
                elements.renderCanvas.width = state.videoWidth;
                elements.renderCanvas.height = state.videoHeight;
                processCanvas.width = state.videoWidth;
                processCanvas.height = state.videoHeight;

                console.log('Video cargado:', state.videoWidth, 'x', state.videoHeight);

                // Hide loader with delay
                if (loader) {
                    setTimeout(() => {
                        loader.classList.remove('active');
                    }, 500);
                }

                // Show video container (redundant but safe)
                elements.uploadArea.style.display = 'none';
                elements.videoContainer.classList.add('active');

                // Force canvas visibility
                elements.renderCanvas.style.visibility = 'visible';
                elements.renderCanvas.style.display = 'block';

                // Update UI
                updateTimeDisplay();
                renderFrame();

                // Enable process button if AI is ready
                if (state.modelReady) {
                    elements.processBtn.disabled = false;
                }
            };
        }

        function resetTracking() {
            state.lastKnownFaces = [];
            state.smoothedBoxes = {};
            state.previewPersistenceCount = 0;
            lastDetectionTime = 0; // Ensure next detection runs immediately
            isDetecting = false; // Force unlock detection in case it got stuck
        }

        // Reset app state when loading new video
        function resetAppState() {
            // Stop playback
            if (!video.paused) {
                video.pause();
                stopPreviewLoop();
            }

            // Reset state
            state.isPlaying = false;
            state.isProcessing = false;
            state.processingCanceled = false;
            state.processedBlob = null;
            state.lastKnownFaces = [];
            state.knownFaces = [];
            state.smoothedBoxes = {};
            state.highlightedPersonId = null;
            state.previewPersistenceCount = 0;
            state.highlightedPersonId = null;
            state.previewPersistenceCount = 0;
            state.previewMode = 'effects'; // Always reset to effects

            // Reset Trim
            state.trimStart = 0;
            state.trimEnd = null;
            if (document.getElementById('btnTrimStart')) {
                document.getElementById('btnTrimStart').textContent = 'In: 0.0s';
                document.getElementById('btnTrimStart').classList.remove('active');
                document.getElementById('btnTrimEnd').textContent = 'Out: Fin';
                document.getElementById('btnTrimEnd').classList.remove('active');
            }

            // Reset UI
            elements.playBtn.textContent = '‚ñ∂';
            elements.processBtn.disabled = true;
            elements.exportBtn.disabled = true;

            // Clear people list
            if (elements.peopleList) {
                elements.peopleList.innerHTML = '<p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">Reproduce el v√≠deo para listar personas...</p>';
            }

            // Reset preview buttons (Removed)
            /*
            const previewOriginal = document.getElementById('previewOriginal');
            const previewEffects = document.getElementById('previewEffects');
            if (previewOriginal && previewEffects) {
                previewOriginal.classList.add('active');
                previewEffects.classList.remove('active');
            }
            */

            document.body.classList.remove('video-active');
            console.log('App state reset for new video');
        }

        let isDetecting = false;
        let lastDetectionTime = 0;
        let detectStartTime = 0;
        const DETECTION_INTERVAL = isMobile ? 60 : 30;




        async function runBackgroundDetection() {
            // Watchdog: If detection takes > 2s, force reset
            if (isDetecting && (Date.now() - detectStartTime > 2000)) {
                console.warn('Watchdog: Force resetting stuck detection');
                isDetecting = false;
            }

            if (isDetecting || !state.modelReady) {
                if (!state.modelReady) {
                    // console.warn('Detection skipped: Model not ready');
                }
                return;
            }

            // Intelligent Throttle: Ensures UI thread has time to render video smoothly
            const now = Date.now();
            if (now - lastDetectionTime < DETECTION_INTERVAL) {
                return;
            }
            lastDetectionTime = now;
            detectStartTime = now; // For watchdog

            isDetecting = true;
            try {
                console.log('Running face detection...');

                // Use full detection if recognition is ready, otherwise basic
                let detections;

                // Handle Mobile / BlazeFace separately
                if (state.detectorType === 'mobile' && window.blazeDetector) {
                    const predictions = await window.blazeDetector.estimateFaces(video, false);
                    detections = predictions.map(pred => ({
                        detection: {
                            box: {
                                x: pred.topLeft[0],
                                y: pred.topLeft[1],
                                width: pred.bottomRight[0] - pred.topLeft[0],
                                height: pred.bottomRight[1] - pred.topLeft[1]
                            },
                            score: pred.probability ? pred.probability[0] : 0.9
                        },
                        identity: null
                    }));
                } else if (!state.recognitionReady) {
                    // Basic detection (faster, no recognition)
                    detections = await faceapi.detectAllFaces(video, window.faceDetector);
                    // Convert to format expected by rest of code
                    detections = detections.map(d => ({
                        detection: d,
                        identity: null
                    }));
                } else {
                    // Full detection with recognition
                    detections = await faceapi.detectAllFaces(video, window.faceDetector)
                        .withFaceLandmarks()
                        .withFaceDescriptors();
                    detections = await identifyFaces(detections);
                }

                console.log(`Detected ${detections.length} faces`);

                // Aplicar suavizado de cajas
                const refined = detections.map(d => {
                    const smoothed = smoothBoundingBox(d);
                    return { ...d, smoothedBox: smoothed };
                });

                if (refined.length > 0) {
                    state.lastKnownFaces = filterFaces(refined);
                    // Much longer persistence on mobile/desktop to prevent gaps
                    state.previewPersistenceCount = isMobile ? 60 : 45;
                } else if (state.previewPersistenceCount > 0) {
                    state.previewPersistenceCount--;
                    // Keep using cached faces - this prevents frame gaps
                } else {
                    // Only clear faces after persistence expires
                    state.lastKnownFaces = [];
                }
            } catch (e) {
                console.error('Background detection error:', e);
            } finally {
                const duration = Date.now() - detectStartTime;
                isDetecting = false;

                // PERFORMANCE MONITORING
                if (!state.isProcessing && !state.perfWarningShown && duration > (isMobile ? 1200 : 800)) {
                    if (state.detectorType === 'ssd' || (state.detectorType === 'tiny' && isMobile)) {
                        showPerformanceWarning();
                        state.perfWarningShown = true;
                    }
                }
            }
        }

        function showPerformanceWarning() {
            const warning = document.createElement('div');
            warning.className = 'perf-warning';
            const msg = isMobile ? '‚ö†Ô∏è Sistema lento: Prueba el modelo "Mobile" para mayor fluidez.' : '‚ö†Ô∏è Rendimiento bajo: Prueba el modelo "Tiny" o "Mobile" para ir m√°s r√°pido.';
            warning.innerHTML = msg;
            document.body.appendChild(warning);
            setTimeout(() => {
                warning.style.opacity = '0';
                warning.style.transition = 'opacity 0.8s ease';
                setTimeout(() => warning.remove(), 800);
            }, 6000);
        }

        // EMA Smoothing logic to eliminate jitter for exact tracking
        // ADAPTIVE Smoothing logic for exact tracking
        function smoothBoundingBox(detection) {
            const rawBox = detection.detection.box;
            const personId = detection.identity ? (detection.identity.id || 'unknown') : 'unknown';

            if (!state.smoothedBoxes) state.smoothedBoxes = {};
            const prev = state.smoothedBoxes[personId] || rawBox;

            // Compute velocity/distance to adapt smoothing
            const dist = Math.sqrt(Math.pow(rawBox.x - prev.x, 2) + Math.pow(rawBox.y - prev.y, 2));

            // Dynamic Factor: 
            // - If moving fast (>15px): use high factor (0.95) for zero-lag tracking
            // - If still: use low factor (0.4) for rock-solid stability
            let factor = 0.4;
            if (dist > 15) factor = 0.95;
            else if (dist > 5) factor = 0.7;

            // Apply smoothing for all 4 corners for exact fit
            const smoothed = {
                x: prev.x + (rawBox.x - prev.x) * factor,
                y: prev.y + (rawBox.y - prev.y) * factor,
                width: prev.width + (rawBox.width - prev.width) * factor,
                height: prev.height + (rawBox.height - prev.height) * factor
            };

            state.smoothedBoxes[personId] = smoothed;
            return smoothed;
        }

        function drawTrackingBorders() {
            drawCachedEffects(false);
        }

        function drawCachedEffects(showEffects = true) {
            if (state.lastKnownFaces.length === 0) return;

            const scaleX = state.videoWidth / video.videoWidth;
            const scaleY = state.videoHeight / video.videoHeight;
            const padding = state.padding;

            state.lastKnownFaces.forEach(face => {
                // Priorizar la caja suavizada para un tracking "exacto" y fluido
                const box = face.smoothedBox || (face.detection ? face.detection.box : null);
                if (!box) return;

                const x = Math.max(0, (box.x - (box.width * padding)) * scaleX);
                const y = Math.max(0, (box.y - (box.height * padding)) * scaleY);
                const w = Math.min(state.videoWidth - x, (box.width * (1 + padding * 2)) * scaleX);
                const h = Math.min(state.videoHeight - y, (box.height * (1 + padding * 2)) * scaleY);

                // 1. Aplicar efecto si NO est√° excluido y estamos en modo efectos
                if (showEffects && !(face.identity && face.identity.excluded)) {
                    if (state.effect === 'pixelate') {
                        pixelateArea(elements.renderCtx, x, y, w, h);
                    } else if (state.effect === 'blur') {
                        blurArea(elements.renderCtx, x, y, w, h);
                    } else {
                        solidArea(elements.renderCtx, x, y, w, h);
                    }
                }

                // 2. Dibujar indicadores visuales de detecci√≥n
                const ctx = elements.renderCtx;

                // Borde blanco sutil para todos los detectados (Feedback de que la IA los ve)
                ctx.save();
                if (isMobile && !showEffects) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                }
                ctx.strokeRect(x, y, w, h);
                ctx.restore();

                // 3. Dibujar borde rojo fuerte si est√° destacado (hover/click)
                if (face.identity && face.identity.id === state.highlightedPersonId) {
                    ctx.save();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x, y, w, h);

                    // Peque√±a etiqueta
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.fillText(face.identity.name, x, y - 5);
                    ctx.restore();
                }
            });
        }

        // Match detected faces with known identities
        async function identifyFaces(detections) {
            const results = [];

            for (const detection of detections) {
                let bestMatch = null;
                let minDistance = FACE_RECOGNITION_THRESHOLD;

                if (detection.descriptor) {
                    state.knownFaces.forEach(known => {
                        const distance = faceapi.euclideanDistance(detection.descriptor, known.descriptor);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMatch = known;
                        }
                    });
                }

                // Fallback Espacial Estricto: si no hay match por biometr√≠a, buscamos por posici√≥n previa cercana
                if (!bestMatch) {
                    const box = detection.detection.box;
                    // Lowered tolerance to 10% of width for extreme precision
                    let minSpatialDist = video.videoWidth * 0.1;
                    state.knownFaces.forEach(known => {
                        if (known.lastPos) {
                            const dist = Math.sqrt(Math.pow(box.x - known.lastPos.x, 2) + Math.pow(box.y - known.lastPos.y, 2));
                            if (dist < minSpatialDist) {
                                minSpatialDist = dist;
                                bestMatch = known;
                            }
                        }
                    });
                }

                if (!bestMatch && detection.descriptor) {
                    // New identity found
                    const newId = `Persona ${state.knownFaces.length + 1}`;
                    const newPerson = {
                        id: Date.now() + Math.random(),
                        name: newId,
                        descriptor: detection.descriptor,
                        excluded: false,
                        lastPos: detection.detection.box
                    };
                    state.knownFaces.push(newPerson);
                    bestMatch = newPerson;
                    renderPeopleList();
                }

                if (bestMatch) {
                    bestMatch.lastPos = detection.detection.box;
                    // Actualizar descriptor si el nuevo es de mejor calidad? (Omitido por ahora para estabilidad)
                }

                results.push({
                    detection: detection.detection,
                    descriptor: detection.descriptor,
                    identity: bestMatch
                });
            }
            return results;
        }

        // Render People List
        function renderPeopleList() {
            if (!elements.peopleList) return;

            if (state.knownFaces.length === 0) {
                elements.peopleList.innerHTML = '<p style="font-size: 11px; color: var(--text-muted); text-align: center; padding: 10px;">Reproduce el v√≠deo para listar personas...</p>';
                return;
            }

            elements.peopleList.innerHTML = state.knownFaces.map(person => `
                <div class="person-item ${person.excluded ? 'excluded' : ''} ${state.highlightedPersonId === person.id ? 'active' : ''}" 
                     data-id="${person.id}">
                    <div class="person-avatar" style="background-image: url('${person.avatar || ''}')">
                        ${!person.avatar ? 'üë§' : ''}
                    </div>
                    <div class="person-info">
                        <div class="person-name">Persona ${person.id.toString().substr(-4)}</div>
                        <div class="person-status">${person.excluded ? 'Ignorado' : 'Detectado'}</div>
                    </div>
                    <div class="person-actions">
                        <button class="action-btn toggle-btn" title="${person.excluded ? 'Incluir' : 'Excluir'}">
                            ${person.excluded ? 'üëÅ' : 'üö´'}
                        </button>
                    </div>
                </div>
            `).join('');

            // Add listeners
            document.querySelectorAll('.person-item').forEach(item => {
                item.addEventListener('mouseenter', () => state.highlightedPersonId = parseFloat(item.dataset.id));
                item.addEventListener('mouseleave', () => state.highlightedPersonId = null);

                const toggleBtn = item.querySelector('.toggle-btn');
                toggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseFloat(item.dataset.id);
                    const person = state.knownFaces.find(p => p.id === id);
                    if (person) {
                        person.excluded = !person.excluded;
                        renderPeopleList();
                    }
                });
            });
        }





        const fxCanvas = document.createElement('canvas');
        const fxCtx = fxCanvas.getContext('2d');

        function pixelateArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;
            const size = Math.max(1, Math.floor(w / state.intensity));

            fxCanvas.width = size;
            fxCanvas.height = size;
            fxCtx.imageSmoothingEnabled = false;

            // Draw downscaled to FX canvas
            fxCtx.drawImage(ctx.canvas, x, y, w, h, 0, 0, size, size);

            // Draw back upscaled
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(fxCanvas, 0, 0, size, size, x, y, w, h);
        }

        function blurArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;

            // Optimization: Use a larger capture area to avoid edge bleeding
            const bleed = Math.round(state.intensity * 2);
            const cx = Math.max(0, x - bleed);
            const cy = Math.max(0, y - bleed);
            const cw = Math.min(ctx.canvas.width - cx, w + bleed * 2);
            const ch = Math.min(ctx.canvas.height - cy, h + bleed * 2);

            fxCanvas.width = cw;
            fxCanvas.height = ch;

            // 1. Capture original (No filter yet)
            fxCtx.drawImage(ctx.canvas, cx, cy, cw, ch, 0, 0, cw, ch);

            // 2. Draw back to main with filter active
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.clip(); // Keep blur inside the box

            ctx.filter = `blur(${state.intensity}px)`;
            ctx.drawImage(fxCanvas, cx, cy);
            ctx.restore();
        }

        function solidArea(ctx, x, y, w, h) {
            if (w <= 0 || h <= 0) return;
            ctx.fillStyle = '#000000';
            ctx.fillRect(x, y, w, h);
        }

        //
        //
        //

        //
        class VideoExportManager {
            constructor(videoElement, state, uiElements) {
                this.video = videoElement;
                this.state = state;
                this.ui = uiElements;
                this.recorder = null;
                this.stream = null;
                this.audioCtx = null;
                this.audioSource = null;
                this.chunks = [];
                this.isProcessing = false;
                this.canceled = false;
            }

            async start() {
                if (this.isProcessing) return;
                this.isProcessing = true;
                this.canceled = false;
                this.chunks = [];

                try {
                    console.log('üé¨ Starting Video Export (v2.0)...');

                    // 1. Setup UI
                    this.video.pause();
                    this.ui.modal.classList.add('active');
                    this.ui.processBtn.disabled = true;
                    this.ui.exportBtn.disabled = true;

                    // 2. Setup Resources (Canvas & Audio)
                    const { canvas, ctx, stream } = await this.setupRecordingStream();
                    this.stream = stream;

                    // 3. Setup Recorder
                    await this.setupRecorder(stream);

                    // 4. Processing Loop (The Core)
                    await this.processFrames(canvas, ctx);

                    // 5. Finalize
                    await this.stopRecording();
                    this.showSuccess();

                } catch (error) {
                    if (this.canceled) {
                        console.log('Process canceled by user');
                        this.resetUI('Proceso cancelado');
                    } else {
                        console.error('Export Fatal Error:', error);
                        alert(`Error cr√≠tico durante el procesamiento: ${error.message}`);
                        this.resetUI('Error en procesamiento');
                    }
                } finally {
                    this.cleanup();
                }
            }

            cancel() {
                this.canceled = true;
                if (this.recorder && this.recorder.state === 'recording') {
                    this.recorder.stop();
                }
            }

            async setupRecordingStream() {
                // Determine dimensions
                const width = this.state.videoWidth;
                const height = this.state.videoHeight;

                // Create offline processing canvas
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: false });

                // Create Canvas Stream (Video Only)
                const stream = canvas.captureStream(30);

                // Audio Setup - PRIORITIZE captureStream for better sync
                let audioTrack = null;

                // 1. Try Native Stream Capture (Best Sync)
                try {
                    const vidStream = this.video.captureStream ? this.video.captureStream() :
                        (this.video.mozCaptureStream ? this.video.mozCaptureStream() : null);

                    if (vidStream && vidStream.getAudioTracks().length > 0) {
                        audioTrack = vidStream.getAudioTracks()[0];
                        console.log('‚úì Audio obtained via captureStream (Native Sync)');
                    }
                } catch (e) {
                    console.warn('Native captureStream failed:', e);
                }

                // 2. Fallback: AudioContext (If native failed)
                if (!audioTrack) {
                    try {
                        console.log('Using AudioContext fallback for audio...');
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        if (AudioContext) {
                            if (!this.audioCtx) this.audioCtx = new AudioContext();
                            if (this.audioCtx.state === 'suspended') await this.audioCtx.resume();

                            // Singleton Source
                            if (!this.audioSource) {
                                this.audioSource = this.audioCtx.createMediaElementSource(this.video);
                            }

                            // Create destination
                            if (!this.audioDest) {
                                this.audioDest = this.audioCtx.createMediaStreamDestination();
                            }

                            // Clean connections
                            try { this.audioSource.disconnect(); } catch (e) { }

                            // Connect: Source -> Dest (Recording)
                            this.audioSource.connect(this.audioDest);

                            // Connect: Source -> Hardware (Monitor)
                            this.audioSource.connect(this.audioCtx.destination);

                            if (this.audioDest.stream.getAudioTracks().length > 0) {
                                audioTrack = this.audioDest.stream.getAudioTracks()[0];
                                console.log('‚úì Audio Graph Constructed via WebAudio');
                            }
                        }
                    } catch (e) {
                        console.warn('AudioContext Setup Failed:', e);
                    }
                }

                // Add Audio Track
                if (audioTrack) {
                    stream.addTrack(audioTrack);
                } else {
                    console.warn('‚ö†Ô∏è Critical: No Audio Track available.');
                }

                return { canvas, ctx, stream };
            }

            async setupRecorder(stream) {
                let options = { mimeType: 'video/webm;codecs=vp9,opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'video/webm' }; // Fallback
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'video/mp4' }; // Safari fallback
                }

                console.log(`Using Recorder MimeType: ${options.mimeType}`);

                // Adaptive bitrate: 2.5Mbps for Mobile, 8Mbps for Desktop
                const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const bitrate = isMobileDevice ? 5000000 : 8000000;

                this.recorder = new MediaRecorder(stream, {
                    ...options,
                    videoBitsPerSecond: bitrate
                });

                this.recorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) {
                        this.chunks.push(e.data);
                    }
                };

                // Start recording manually later
                // this.recorder.start(500); 
            }


            async processFrames(canvas, ctx) {
                return new Promise(async (resolve, reject) => {
                    const totalDuration = this.video.duration;
                    const startTime = this.state.trimStart || 0;
                    let endTime = this.state.trimEnd;

                    if (endTime === null || endTime === undefined || endTime > totalDuration || endTime <= startTime) {
                        endTime = totalDuration;
                    }

                    // Setup Playback & Recording Sequence
                    this.video.currentTime = startTime;

                    // Promise to wait for seek to complete
                    await new Promise(r => {
                        if (Math.abs(this.video.currentTime - startTime) < 0.1) {
                            r();
                        } else {
                            const onSeek = () => {
                                this.video.removeEventListener('seeked', onSeek);
                                r();
                            };
                            this.video.addEventListener('seeked', onSeek);
                        }
                    });

                    this.video.volume = 1.0;
                    this.video.muted = false; // Enabled for both Recording Stream AND User Preview

                    // Ensure AudioContext is running
                    if (this.audioCtx && this.audioCtx.state === 'suspended') {
                        await this.audioCtx.resume();
                    }

                    try {
                        await this.video.play();
                        // CRITICAL: Start Recorder AFTER playing to avoid recording initial silence/latency
                        if (this.recorder && this.recorder.state === 'inactive') {
                            this.recorder.start(500);
                            console.log('‚è∫ Recorder started (Synced after play)');
                        }
                    } catch (e) {
                        console.error('Play failed:', e);
                    }


                    let activeTracks = [];
                    let nextTrackId = 1;
                    let isDetecting = false;
                    let animationFrameId;

                    const processLoop = async () => {
                        if (this.canceled) {
                            this.video.pause();
                            reject(new Error('Canceled'));
                            return;
                        }

                        const currentTime = this.video.currentTime;

                        // Check End Condition
                        if (currentTime >= endTime || this.video.ended || this.video.paused) {
                            // If paused unexpectedly, try to resume unless finished
                            if (this.video.paused && currentTime < endTime && !this.video.ended && !this.canceled) {
                                this.video.play().catch(console.error);
                            } else {
                                this.video.pause();
                                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                                resolve();
                                return;
                            }
                        }

                        // 1. Draw Current Frame
                        ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);

                        // 2. Async Detection (Non-blocking)
                        if (!isDetecting && (window.faceDetector || (this.state.detectorType === 'mobile' && window.blazeDetector))) {
                            isDetecting = true;
                            this.detectFaces(canvas).then(faces => {
                                activeTracks = this.updateTracks(activeTracks, faces, nextTrackId);
                                if (activeTracks.length > 0) nextTrackId = Math.max(...activeTracks.map(t => t.id)) + 1;
                                isDetecting = false;
                            }).catch(err => {
                                console.warn('Detection skipped:', err);
                                isDetecting = false;
                            });
                        }

                        // 3. Render Effects (using current Track State)
                        this.renderEffects(ctx, activeTracks);

                        // 4. Update UI
                        const pct = Math.round(((currentTime - startTime) / (endTime - startTime)) * 100);
                        this.ui.modalFill.style.width = `${pct}%`;
                        this.ui.modalPercent.textContent = `${pct}%`;
                        this.ui.modalSubtitle.textContent = `Grabando: ${formatTime(currentTime)} / ${formatTime(endTime)}`;

                        // Loop
                        animationFrameId = requestAnimationFrame(processLoop);
                    };

                    processLoop();
                });
            }

            seekVideo(time) {
                return Promise.resolve();
            }

            async detectFaces(input) {
                // Simplified detection router
                if (this.state.detectorType === 'mobile' && window.blazeDetector) {
                    const preds = await window.blazeDetector.estimateFaces(input, false, false, false);
                    return preds.map(p => ({
                        box: { x: p.topLeft[0], y: p.topLeft[1], width: p.bottomRight[0] - p.topLeft[0], height: p.bottomRight[1] - p.topLeft[1] }
                    }));
                } else if (window.faceDetector) {
                    const detections = await faceapi.detectAllFaces(input, window.faceDetector);
                    return detections.map(d => ({ box: d.box }));
                }
                return [];
            }

            updateTracks(tracks, newDetections, nextId) {
                // Simplified tracker for reliability
                const matched = new Set();
                const updatedTracks = tracks.map(track => {
                    // Find best IoU match
                    let bestMatch = null;
                    let maxIoU = 0.3;

                    newDetections.forEach((det, idx) => {
                        if (matched.has(idx)) return;
                        const iou = getIoU(track.box, det.box);
                        if (iou > maxIoU) {
                            maxIoU = iou;
                            bestMatch = { det, idx };
                        }
                    });

                    if (bestMatch) {
                        matched.add(bestMatch.idx);
                        // Smooth update
                        return {
                            ...track,
                            box: {
                                x: track.box.x * 0.7 + bestMatch.det.box.x * 0.3,
                                y: track.box.y * 0.7 + bestMatch.det.box.y * 0.3,
                                width: track.box.width * 0.7 + bestMatch.det.box.width * 0.3,
                                height: track.box.height * 0.7 + bestMatch.det.box.height * 0.3
                            },
                            lastSeen: 0
                        };
                    } else {
                        return { ...track, lastSeen: track.lastSeen + 1 };
                    }
                });

                // Add new tracks
                newDetections.forEach((det, idx) => {
                    if (!matched.has(idx)) {
                        updatedTracks.push({
                            id: nextId + idx,
                            box: det.box,
                            lastSeen: 0
                        });
                    }
                });

                // Filter dead tracks
                return updatedTracks.filter(t => t.lastSeen < 30); // 1s persistence
            }

            renderEffects(ctx, tracks) {
                const padding = this.state.padding;
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;

                tracks.forEach(track => {
                    const box = track.box;
                    const x = Math.max(0, box.x - (box.width * padding));
                    const y = Math.max(0, box.y - (box.height * padding));
                    const w = Math.min(width - x, box.width * (1 + padding * 2));
                    const h = Math.min(height - y, box.height * (1 + padding * 2));

                    if (w > 0 && h > 0) {
                        if (this.state.effect === 'pixelate') pixelateArea(ctx, x, y, w, h);
                        else if (this.state.effect === 'blur') blurArea(ctx, x, y, w, h);
                        else solidArea(ctx, x, y, w, h);
                    }
                });
            }

            updateProgress(currentTime, startTime, endTime, facesCount) {
                const duration = endTime - startTime;
                const progress = currentTime - startTime;
                const pct = Math.round((progress / duration) * 100);

                this.ui.modalFill.style.width = `${pct}%`;
                this.ui.modalPercent.textContent = `${pct}%`;
                this.ui.modalSubtitle.textContent = `Procesando: ${formatTime(currentTime)} / ${formatTime(endTime)} (${facesCount} caras)`;
            }

            stopRecording() {
                return new Promise((resolve) => {
                    this.ui.modalSubtitle.textContent = 'Finalizando codificaci√≥n...';
                    console.log('Stopping recorder...');

                    // Handler for stop event
                    this.recorder.onstop = () => {
                        console.log('Recorder stopped. Generating blob...');
                        const blob = new Blob(this.chunks, { type: this.recorder.mimeType });
                        this.state.processedBlob = blob;
                        resolve();
                    };

                    // Validate state and stop
                    if (this.recorder.state === 'recording') {
                        this.recorder.requestData(); // Flush last chunk
                        this.recorder.stop();
                    } else {
                        // Already stopped? resolve immediately
                        resolve();
                    }
                });
            }

            showSuccess() {
                // Trigger global success function if exists, or handle here
                if (typeof showExportSuccess === 'function') {
                    showExportSuccess();
                } else {
                    alert('Video procesado correctamente!');
                    this.ui.modal.classList.remove('active');
                }
            }

            resetUI(msg) {
                this.ui.modalSubtitle.textContent = msg;
                setTimeout(() => {
                    this.ui.modal.classList.remove('active');
                    this.ui.processBtn.disabled = false;
                }, 2000);
            }

            cleanup() {
                this.isProcessing = false;
                this.state.isProcessing = false;

                // Cleanup streams
                if (this.stream) {
                    this.stream.getTracks().forEach(t => t.stop());
                }

                // Restore Video
                this.video.muted = false;
                this.video.volume = 1.0;

                // Re-enable global checks
                window.videoProcessorInstance = null;
            }
        }

        // Global Processor Instance
        let videoProcessor = null;

        async function processVideo() {
            if (state.isProcessing) return;

            // Validate ready state
            if (!state.modelReady) {
                alert('Espere a que carguen los modelos de IA');
                return;
            }

            // Init new processor
            videoProcessor = new VideoExportManager(video, state, elements);

            // Hook Cancel Button
            elements.cancelBtn.onclick = () => {
                if (videoProcessor) videoProcessor.cancel();
            };

            // Start
            await videoProcessor.start();
        }






        // Helper: Intersection over Union
        function getIoU(boxA, boxB) {
            const xA = Math.max(boxA.x, boxB.x);
            const yA = Math.max(boxA.y, boxB.y);
            const xB = Math.min(boxA.x + boxA.width, boxB.x + boxB.width);
            const yB = Math.min(boxA.y + boxA.height, boxB.y + boxB.height);

            const interW = Math.max(0, xB - xA);
            const interH = Math.max(0, yB - yA);
            const interArea = interW * interH;
            const boxAArea = boxA.width * boxA.height;
            const boxBArea = boxB.width * boxB.height;
            return interArea / (boxAArea + boxBArea - interArea);
        }

        // Helper to check if PWA is already installed
        function isPwaInstalled() {
            return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
        }

        // Export Success UI
        function showExportSuccess() {
            try {
                if (!state.processedBlob) {
                    throw new Error('No video blob available');
                }
                elements.modalTitle.textContent = '¬°Video Listo!';
                const isMobileOS = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                elements.modalSubtitle.textContent = isMobileOS ?
                    'En m√≥viles, usa "Galer√≠a" para guardar en tu carrete:' :
                    'Selecciona una opci√≥n para guardar tu video:';


                const fillParent = elements.modalFill.parentElement;
                if (fillParent) fillParent.style.display = 'none';
                if (elements.modalPercent) elements.modalPercent.style.display = 'none';

                const spinner = document.querySelector('.modal-spinner');
                if (spinner) spinner.style.display = 'none';

                elements.cancelBtn.textContent = 'Cerrar';

                const actions = document.getElementById('modalActions');
                if (actions) actions.style.display = 'flex';

                const blobType = state.processedBlob.type || 'video/webm';
                const ext = blobType.includes('mp4') ? 'mp4' : 'webm';

                // Bind Download
                const dlBtn = document.getElementById('btnDownload');
                if (dlBtn) {
                    dlBtn.onclick = () => {
                        const url = URL.createObjectURL(state.processedBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `faceanon_pro_${Date.now()}.${ext}`;
                        a.click();
                        setTimeout(() => URL.revokeObjectURL(url), 10000);
                    };
                }

                // Bind Share
                const shareBtn = document.getElementById('btnShare');
                if (shareBtn) {
                    shareBtn.onclick = async () => {
                        if (navigator.share) {
                            const fileName = `faceanon_${Date.now()}.${ext}`;
                            const file = new File([state.processedBlob], fileName, { type: blobType });
                            try {
                                await navigator.share({
                                    files: [file],
                                    title: 'FaceAnon Pro',
                                    text: 'Video procesado con FaceAnon'
                                });
                            } catch (e) {
                                console.warn('Share error:', e);
                            }
                        } else {
                            alert('La funci√≥n de compartir no est√° disponible en este navegador.');
                        }

                    };
                }

                elements.processBtn.disabled = false;
                elements.exportBtn.disabled = false;

                // Reset Audio/Video for user
                video.muted = false;
                video.volume = 1.0;

            } catch (e) {
                console.error('Error showing export success UI:', e);
                alert('El video se gener√≥ correctamente, pero hubo un error mostrando la interfaz de guardado.');
            }
        }


        // Export video
        function exportVideo() {
            if (!state.processedBlob) {
                alert('Primero procesa un video');
                return;
            }
            const url = URL.createObjectURL(state.processedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `faceanon_${Date.now()}.webm`;
            a.click();
        }



        // Start app
        init();
    </script>
</body>

</html>