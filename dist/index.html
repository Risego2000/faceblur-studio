<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FaceBlur Studio - Editor Profesional de Anonimización</title>
    
    <!-- ======================================== -->
    <!-- ICONOS - Usando el icono personalizado del usuario -->
    <!-- ======================================== -->
    
    <!-- Icono PNG (principal - imagen personalizada del usuario) -->
    <link rel="icon" type="image/png" href="icon.png" sizes="512x512">
    <link rel="icon" type="image/png" href="icon.png" sizes="192x192">
    <link rel="icon" type="image/png" href="icon.png" sizes="64x64">
    <link rel="icon" type="image/png" href="icon.png" sizes="32x32">
    <link rel="icon" type="image/png" href="icon.png" sizes="16x16">
    <link rel="shortcut icon" href="icon.png">
    
    <!-- Icono SVG como fallback moderno -->
    <link rel="icon" type="image/svg+xml" href="icon.svg" sizes="any">
    
    <!-- Apple Touch Icon para iOS/iPad/iPhone -->
    <link rel="apple-touch-icon" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon.png">
    
    <!-- Splash screen para iOS -->
    <link rel="apple-touch-startup-image" href="splash.png">
    
    <!-- Microsoft Windows / Surface / Phone -->
    <meta name="msapplication-TileImage" content="icon.png">
    <meta name="msapplication-TileColor" content="#0f172a">
    <meta name="theme-color" content="#0f172a">
    <meta name="msapplication-square70x70logo" content="icon.png">
    <meta name="msapplication-square150x150logo" content="icon.png">
    <meta name="msapplication-square310x310logo" content="icon.png">
    <meta name="msapplication-wide310x150logo" content="icon.png">
    
    <!-- ======================================== -->
    <!-- MANIFEST PARA APLICACIÓN WEB PROGRESIVA (PWA) -->
    <!-- ======================================== -->
    <link rel="manifest" href="manifest.json">
    
    <!-- ======================================== -->
    <!-- METADATA PARA REDES SOCIALES Y SEO -->
    <!-- ======================================== -->
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://sz0maozxsq6h.space.minimax.io">
    <meta property="og:title" content="FaceBlur Studio - Editor Profesional de Anonimización">
    <meta property="og:description" content="Protege la identidad de las personas con tecnología de detección facial avanzada. Anonimiza rostros en videos de forma rápida y profesional.">
    <meta property="og:image" content="og-image.png">
    <meta property="og:site_name" content="FaceBlur Studio">
    <meta property="og:locale" content="es_ES">
    
    <!-- Twitter / X -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@faceblurstudio">
    <meta name="twitter:url" content="https://sz0maozxsq6h.space.minimax.io">
    <meta name="twitter:title" content="FaceBlur Studio">
    <meta name="twitter:description" content="Editor profesional de anonimización de rostros">
    <meta name="twitter:image" content="og-image.png">
    
    <!-- Pinterest -->
    <meta name="pinterest" content="nopin" description="Lo sentimos, no permitimos guardar imágenes de FaceBlur Studio">
    
    <!-- ======================================== -->
    <!-- SEO Y DESCRIPCIÓN -->
    <!-- ======================================== -->
    
    <meta name="description" content="FaceBlur Studio es una aplicación profesional para anonimizar rostros en videos. Protege la privacidad con tecnología de detección facial avanzada. Pixelación y desenfoque profesional.">
    <meta name="keywords" content="anonimizar rostros, privacidad video, editor facial, blur video, pixelar cara, protección identidad, face blur, video privacy, anonymize faces">
    <meta name="subject" content="Software de edición de video para anonimización">
    <meta name="rating" content="General">
    <meta name="robots" content="index, follow">
    <meta name="revisit-after" content="7 days">
    <meta name="language" content="Spanish">
    <meta name="format-detection" content="telephone=no">
    
    <!-- ======================================== -->
    <!-- AUTOR Y COPYRIGHT -->
    <!-- ======================================== -->
    
    <meta name="author" content="FaceBlur Studio">
    <meta name="copyright" content="2024 FaceBlur Studio - Todos los derechos reservados">
    <meta name="designer" content="FaceBlur Studio Team">
    
    <!-- ======================================== -->
    <!-- RECURSOS LOCALES - PWA OFFLINE -->
    <!-- ======================================== -->
    
    <!-- Font Awesome local -->
    <link rel="stylesheet" href="./css/fontawesome.min.css">
    
    <!-- Fuentes locales -->
    <link rel="stylesheet" href="./css/fonts.css">
    
    <!-- Service Worker para funcionamiento offline -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('./sw.js')
                    .then(function(registration) {
                        console.log('[SW] Service Worker registrado:', registration.scope);
                    })
                    .catch(function(error) {
                        console.warn('[SW] Error al registrar Service Worker:', error);
                    });
            });
        }
    </script>
    
    <style>
        /* CSS Variables - Professional Color Palette */
        :root {
            /* Primary Colors */
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --primary-gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            
            /* Neutral Colors */
            --bg-dark: #0a0a0f;
            --bg-card: #14141f;
            --bg-elevated: #1a1a2e;
            --bg-hover: #252542;
            --border: #2a2a45;
            --border-light: #363660;
            
            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            
            /* Status Colors */
            --success: #22c55e;
            --success-bg: rgba(34, 197, 94, 0.1);
            --warning: #f59e0b;
            --warning-bg: rgba(245, 158, 11, 0.1);
            --error: #ef4444;
            --error-bg: rgba(239, 68, 68, 0.1);
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            
            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 30px rgba(99, 102, 241, 0.3);
            
            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.25s ease;
            --transition-slow: 0.4s ease;
        }

        /* Reset and Base Styles */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }

        /* Selection */
        ::selection {
            background: var(--primary);
            color: white;
        }

        /* Header */
        header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: var(--spacing-md) var(--spacing-xl);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: rgba(20, 20, 31, 0.95);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }

        .logo-icon {
            width: 44px;
            height: 44px;
            background: var(--primary-gradient);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            box-shadow: var(--shadow-glow);
            transition: transform var(--transition-normal);
        }

        .logo-icon:hover {
            transform: scale(1.05);
        }

        .logo-icon-img {
            width: 44px;
            height: 44px;
            border-radius: var(--radius-md);
            object-fit: cover;
            box-shadow: var(--shadow-glow);
            transition: transform var(--transition-normal);
        }

        .logo-icon-img:hover {
            transform: scale(1.05);
        }

        .logo-text {
            display: flex;
            flex-direction: column;
        }

        .logo-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.5px;
        }

        .logo-subtitle {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 400;
        }

        .header-center {
            display: flex;
            align-items: center;
            gap: var(--spacing-lg);
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--bg-elevated);
            border-radius: var(--radius-xl);
            border: 1px solid var(--border);
            transition: all var(--transition-normal);
        }

        .header-status.ready {
            background: var(--success-bg);
            border-color: var(--success);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            animation: pulse 2s infinite;
            transition: all var(--transition-normal);
        }

        .header-status.ready .status-dot {
            background: var(--success);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        .status-text {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .header-status.ready .status-text {
            color: var(--success);
        }

        .header-actions {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        /* Hamburger Menu Button */
        .hamburger-btn {
            display: none;
            width: 44px;
            height: 44px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            transition: all var(--transition-fast);
            align-items: center;
            justify-content: center;
        }

        .hamburger-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary);
            color: var(--text-primary);
        }

        .hamburger-btn.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        /* Mobile Menu Overlay */
        .mobile-menu-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            z-index: 200;
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .mobile-menu-overlay.active {
            display: flex;
            opacity: 1;
        }

        .mobile-menu-content {
            width: 100%;
            max-width: 320px;
            background: var(--bg-card);
            height: 100%;
            transform: translateX(-100%);
            transition: transform var(--transition-normal);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .mobile-menu-overlay.active .mobile-menu-content {
            transform: translateX(0);
        }

        .mobile-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--border);
            background: var(--bg-elevated);
        }

        .mobile-menu-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .mobile-menu-close {
            width: 36px;
            height: 36px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-muted);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .mobile-menu-close:hover {
            border-color: var(--error);
            color: var(--error);
            background: var(--error-bg);
        }

        .mobile-menu-body {
            padding: var(--spacing-md);
            overflow-y: auto;
            flex: 1;
        }

        .header-btn {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .header-btn:hover {
            background: var(--bg-hover);
            border-color: var(--primary);
            color: var(--text-primary);
            transform: translateY(-1px);
        }

        .header-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .header-btn i {
            font-size: 14px;
        }

        /* Main Layout */
        .app {
            display: flex;
            flex-direction: row;
            min-height: calc(100vh - 73px);
            width: 100%;
            overflow: hidden;
        }

        /* Sidebar Base Styles */
        .sidebar {
            background: var(--bg-card);
            padding: var(--spacing-md);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Left Controls Sidebar */
        .controls-sidebar {
            width: 280px;
            flex-shrink: 0;
            border-right: 1px solid var(--border);
            height: calc(100vh - 73px);
            position: sticky;
            top: 73px;
        }



        /* Workspace - Center (Main Video Area) */
        .workspace {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-lg);
            background: var(--bg-dark);
            min-width: 0;
            overflow: auto;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .sidebar-section.process-section {
            margin-top: auto;
            flex-shrink: 0;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xs);
        }

        .section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            font-weight: 600;
        }

        .section-badge {
            font-size: 9px;
            padding: 1px 5px;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            font-weight: 600;
        }

        /* Cards */
        .card {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            transition: all var(--transition-normal);
        }

        .card:hover {
            border-color: var(--border-light);
        }

        /* Effect Options */
        .effect-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-xs);
        }

        .effect-option {
            position: relative;
            padding: var(--spacing-sm);
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: var(--radius-md);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition-fast);
            overflow: hidden;
        }

        .effect-option::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .effect-option:hover {
            border-color: var(--primary-light);
            transform: translateY(-1px);
        }

        .effect-option.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .effect-option.active::before {
            opacity: 0.05;
        }

        .effect-option.active .effect-icon,
        .effect-option.active .effect-name {
            position: relative;
            z-index: 1;
        }

        .effect-icon {
            font-size: 20px;
            margin-bottom: 2px;
            display: block;
            transition: transform var(--transition-normal);
        }

        .effect-option:hover .effect-icon {
            transform: scale(1.05);
        }

        .effect-name {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }

        .effect-option.active .effect-name {
            color: var(--primary-light);
        }

        /* Slider */
        .slider-wrapper {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-xs);
        }

        .slider-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .slider-value {
            font-size: 12px;
            font-weight: 700;
            color: var(--primary-light);
            font-family: 'SF Mono', 'Monaco', monospace;
            background: rgba(99, 102, 241, 0.1);
            padding: 1px 6px;
            border-radius: var(--radius-sm);
        }

        .slider {
            width: 100%;
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary-gradient);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: transform var(--transition-fast);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--primary-gradient);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow-md);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 2px;
        }

        .slider-labels span {
            font-size: 9px;
            color: var(--text-muted);
        }

        /* Detection Modes */
        .mode-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .mode-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .mode-option:hover {
            border-color: var(--border-light);
            background: var(--bg-hover);
        }

        .mode-option.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.08);
        }

        .mode-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-elevated);
            border-radius: var(--radius-sm);
            font-size: 12px;
            color: var(--text-muted);
            transition: all var(--transition-fast);
        }

        .mode-option.active .mode-icon {
            background: var(--primary);
            color: white;
        }

        .mode-info {
            flex: 1;
        }

        .mode-name {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1px;
        }

        .mode-desc {
            font-size: 10px;
            color: var(--text-muted);
        }

        .mode-check {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary);
            border-radius: 50%;
            color: white;
            font-size: 10px;
            opacity: 0;
            transform: scale(0.5);
            transition: all var(--transition-fast);
        }

        .mode-option.active .mode-check {
            opacity: 1;
            transform: scale(1);
        }

        /* Preset Options */
        .preset-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .preset-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .preset-option:hover {
            border-color: var(--border-light);
            background: var(--bg-hover);
        }

        .preset-option.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.08);
        }

        .preset-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-elevated);
            border-radius: var(--radius-sm);
            font-size: 12px;
            color: var(--text-muted);
            transition: all var(--transition-fast);
        }

        .preset-option.active .preset-icon {
            background: var(--primary);
            color: white;
        }

        .preset-info {
            flex: 1;
        }

        .preset-name {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1px;
        }

        .preset-desc {
            font-size: 10px;
            color: var(--text-muted);
        }

        .preset-check {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--primary);
            border-radius: 50%;
            color: white;
            font-size: 10px;
            opacity: 0;
            transform: scale(0.5);
            transition: all var(--transition-fast);
        }

        .preset-option.active .preset-check {
            opacity: 1;
            transform: scale(1);
        }


        /* Preview Toggle */
        .preview-toggle {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-xs);
        }

        .preview-btn {
            position: relative;
            padding: var(--spacing-sm);
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            overflow: hidden;
        }

        .preview-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .preview-btn:hover {
            border-color: var(--primary-light);
            color: var(--text-secondary);
        }

        .preview-btn.active {
            border-color: var(--primary);
            color: var(--text-primary);
        }

        .preview-btn.active::before {
            opacity: 0.08;
        }

        .preview-btn.active .preview-icon {
            color: var(--primary-light);
        }

        .preview-btn i {
            display: block;
            font-size: 16px;
            margin-bottom: 2px;
            transition: transform var(--transition-normal);
        }

        .preview-btn:hover i {
            transform: scale(1.05);
        }

        /* Bottom Control Panel - Removed in reversion */
        /*
        .bottom-panel {
            background: var(--bg-card);
            border-top: 1px solid var(--border);
            padding: var(--spacing-md) var(--spacing-lg);
            width: 100%;
            flex-shrink: 0;
        }

        .bottom-panel-inner {
            display: flex;
            align-items: center;
            gap: var(--spacing-lg);
            flex-wrap: wrap;
            max-width: 1600px;
            margin: 0 auto;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            flex-wrap: wrap;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .control-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .effect-buttons-inline {
            display: flex;
            gap: 4px;
        }

        .effect-btn-inline {
            padding: 6px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .effect-btn-inline:hover {
            border-color: var(--primary-light);
        }

        .effect-btn-inline.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.15);
            color: var(--primary-light);
        }

        .slider-inline {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .slider-inline .slider {
            width: 80px;
            height: 4px;
        }

        .slider-inline .slider::-webkit-slider-thumb {
            width: 12px;
            height: 12px;
        }

        .slider-inline-value {
            font-size: 10px;
            font-weight: 600;
            color: var(--primary-light);
            font-family: 'SF Mono', 'Monaco', monospace;
            min-width: 40px;
            text-align: right;
        }

        .select-inline {
            padding: 6px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            font-size: 10px;
            font-weight: 500;
            cursor: pointer;
            min-width: 100px;
        }

        .select-inline:hover {
            border-color: var(--primary-light);
        }

        .action-buttons-row {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .btn-action {
            padding: 10px 16px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-action.primary {
            background: var(--primary-gradient);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-action.primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);
        }

        .btn-action.secondary {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .btn-action.secondary:hover {
            border-color: var(--primary);
            color: var(--text-primary);
        }

        .btn-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        */

        /* Process Button */
        .process-section {
            margin-top: auto;
            flex-shrink: 0;
        }

        .btn {
            position: relative;
            padding: 12px 16px;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-sm);
            transition: all var(--transition-normal);
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .btn-primary {
            width: 100%;
            background: var(--primary-gradient);
            color: white;
            box-shadow: var(--shadow-md), var(--shadow-glow);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.3);
        }

        .btn-primary:hover:not(:disabled)::before {
            opacity: 1;
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary i {
            position: relative;
            z-index: 1;
        }

        .btn-text {
            position: relative;
            z-index: 1;
        }

        .process-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-xs);
            margin-top: var(--spacing-xs);
            font-size: 10px;
            color: var(--text-muted);
        }

        .process-info i {
            font-size: 9px;
            color: var(--primary);
        }

        /* Workspace */
        .workspace {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-xl);
            background: var(--bg-dark);
            width: 100%;
            overflow: auto;
        }

        /* Upload Area */
        .upload-area {
            position: relative;
            width: 100%;
            max-width: 480px;
            padding: var(--spacing-xl) var(--spacing-lg);
            border: 2px dashed var(--border);
            border-radius: var(--radius-xl);
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-normal);
            background: var(--bg-card);
        }

        .upload-area::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: var(--radius-xl);
            background: var(--primary-gradient);
            opacity: 0;
            z-index: -1;
            transition: opacity var(--transition-normal);
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: var(--primary);
        }

        .upload-area:hover::before,
        .upload-area.dragover::before {
            opacity: 0.15;
        }

        .upload-icon-wrapper {
            position: relative;
            width: 100px;
            height: 100px;
            margin: 0 auto var(--spacing-lg);
            background: var(--bg-elevated);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-icon-wrapper::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            background: var(--primary-gradient);
            opacity: 0.3;
        }

        .upload-icon {
            font-size: 40px;
            position: relative;
            z-index: 1;
        }

        .upload-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
        }

        .upload-subtitle {
            color: var(--text-muted);
            font-size: 14px;
            margin-bottom: var(--spacing-lg);
        }

        .upload-btn {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: 14px 28px;
            background: var(--primary-gradient);
            color: white;
            border-radius: var(--radius-md);
            font-weight: 600;
            font-size: 14px;
            transition: all var(--transition-normal);
            box-shadow: var(--shadow-md), var(--shadow-glow);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(99, 102, 241, 0.4);
        }

        .upload-formats {
            display: flex;
            justify-content: center;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-lg);
            flex-wrap: wrap;
        }

        .format-badge {
            padding: 4px 10px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 11px;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* Video Container */
        #videoContainer {
            display: none;
            width: 100%;
            max-width: 100%;
            padding: 0;
        }

        #videoContainer.active {
            display: block;
        }

        .video-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            overflow: hidden;
            width: 100%;
            max-width: 100%;
            box-shadow: var(--shadow-lg);
        }

        .video-canvas-wrapper {
            position: relative;
            width: 100%;
            background: linear-gradient(180deg, #000 0%, #0a0a0f 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
            overflow: hidden;
        }

        .video-canvas-wrapper::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        #renderCanvas {
            width: 100%;
            height: auto;
            max-width: 100%;
            max-height: 65vh;
            display: block;
            object-fit: contain;
            visibility: visible !important;
            position: relative;
            z-index: 1;
        }

        .video-overlay {
            position: absolute;
            top: var(--spacing-md);
            right: var(--spacing-md);
            display: flex;
            gap: var(--spacing-sm);
            z-index: 10;
        }

        .overlay-badge {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: var(--radius-md);
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .overlay-badge.active {
            color: var(--success);
            background: rgba(34, 197, 94, 0.15);
        }

        .overlay-badge i {
            font-size: 10px;
        }

        /* Video Controls */
        .video-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            border-top: 1px solid var(--border);
        }

        .play-btn {
            width: 48px;
            height: 48px;
            background: var(--primary-gradient);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            box-shadow: var(--shadow-md), var(--shadow-glow);
            transition: all var(--transition-fast);
        }

        .play-btn:hover {
            transform: scale(1.1);
        }

        .time-display {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 12px;
            color: var(--text-muted);
            min-width: 100px;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .time-display i {
            font-size: 10px;
            color: var(--text-muted);
        }

        .progress-track {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .progress-track:hover {
            height: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-gradient);
            width: 0%;
            border-radius: 3px;
            position: relative;
            transition: width 0.1s linear;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            box-shadow: var(--shadow-md);
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .progress-track:hover .progress-fill::after {
            opacity: 1;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .volume-btn {
            width: 36px;
            height: 36px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 14px;
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .volume-btn:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.1);
        }

        /* ======================================== */
        /* RESPONSIVE DESIGN - Mobile First */
        /* ======================================== */

        /* Base Mobile Styles (0px - 767px) */
        @media screen and (max-width: 767px) {
            /* Header adjustments */
            header {
                padding: var(--spacing-sm) var(--spacing-md);
                flex-wrap: wrap;
                gap: var(--spacing-sm);
            }

            .logo {
                gap: var(--spacing-sm);
            }

            .logo-icon,
            .logo-icon-img {
                width: 36px;
                height: 36px;
            }

            .logo-icon {
                font-size: 18px;
            }

            .logo-title {
                font-size: 15px;
            }

            .logo-subtitle {
                font-size: 10px;
            }

            .header-center {
                display: none;
            }

            .hamburger-btn {
                display: flex;
            }

            .header-actions {
                gap: var(--spacing-xs);
            }

            .header-btn span {
                display: none;
            }

            .header-btn i {
                font-size: 16px;
            }

            /* Main layout - Stack vertically on mobile */
            .app {
                flex-direction: column;
                min-height: calc(100vh - 60px);
            }

            /* Sidebar becomes full-width panel at bottom */
            .controls-sidebar {
                width: 100%;
                height: auto;
                max-height: 45vh;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                border-right: none;
                border-top: 1px solid var(--border);
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
                z-index: 50;
                padding: var(--spacing-sm);
                display: flex;
                flex-direction: column;
            }

            .controls-sidebar.collapsed {
                max-height: 60px;
            }

            .controls-sidebar.collapsed .sidebar-section:not(:first-child) {
                display: none;
            }

            .sidebar-toggle {
                display: flex;
            }

            /* Workspace adjustments */
            .workspace {
                padding: var(--spacing-sm);
                flex: 1;
                margin-bottom: 45vh;
            }

            /* Video canvas - full width on mobile */
            #videoContainer.active {
                display: block;
                width: 100%;
            }

            .video-card {
                border-radius: var(--radius-md);
                border: none;
            }

            .video-canvas-wrapper {
                min-height: 250px;
                border-radius: var(--radius-md);
            }

            #renderCanvas {
                max-height: 50vh;
            }

            .video-controls {
                padding: var(--spacing-sm);
                gap: var(--spacing-sm);
            }

            .play-btn {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .time-display {
                min-width: 80px;
                font-size: 11px;
            }

            .volume-control {
                display: none;
            }

            /* Upload area - smaller on mobile */
            .upload-area {
                padding: var(--spacing-lg);
                max-width: 100%;
            }

            .upload-icon-wrapper {
                width: 70px;
                height: 70px;
            }

            .upload-icon {
                font-size: 28px;
            }

            .upload-title {
                font-size: 18px;
            }

            .upload-subtitle {
                font-size: 13px;
            }

            .upload-btn {
                padding: 12px 24px;
                font-size: 13px;
            }

            /* Card adjustments */
            .card {
                padding: var(--spacing-sm);
                border-radius: var(--radius-md);
            }

            /* Section titles */
            .section-title {
                font-size: 9px;
            }

            /* Effect grid - single column on very small screens */
            .effect-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 4px;
            }

            .effect-option {
                padding: var(--spacing-xs) var(--spacing-sm);
            }

            .effect-icon {
                font-size: 16px;
            }

            .effect-name {
                font-size: 10px;
            }

            /* Slider wrapper */
            .slider-wrapper {
                padding: var(--spacing-xs);
            }

            .slider-label {
                font-size: 11px;
            }

            .slider-value {
                font-size: 11px;
                padding: 1px 4px;
            }

            .slider::-webkit-slider-thumb {
                width: 14px;
                height: 14px;
            }

            /* Mode and preset options */
            .mode-option,
            .preset-option {
                padding: var(--spacing-xs) var(--spacing-sm);
            }

            .mode-icon,
            .preset-icon {
                width: 24px;
                height: 24px;
                font-size: 10px;
            }

            .mode-name,
            .preset-name {
                font-size: 11px;
            }

            .mode-desc,
            .preset-desc {
                font-size: 9px;
            }

            /* Preview toggle */
            .preview-toggle {
                grid-template-columns: 1fr 1fr;
            }

            .preview-btn {
                padding: var(--spacing-xs);
                font-size: 10px;
            }

            .preview-btn i {
                font-size: 14px;
                margin-bottom: 1px;
            }

            /* Process button */
            .process-section {
                margin-top: var(--spacing-sm);
            }

            .btn {
                padding: 10px 12px;
                font-size: 12px;
            }

            /* Face counter */
            .face-counter {
                padding: 4px 10px;
                font-size: 10px;
            }

            .face-counter i {
                font-size: 9px;
            }

            /* Modal - full screen on mobile */
            .modal-overlay {
                padding: var(--spacing-md);
                align-items: flex-end;
            }

            .modal {
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                padding: var(--spacing-lg) var(--spacing-md);
                max-width: 100%;
            }

            .modal-spinner {
                width: 48px;
                height: 48px;
            }

            .modal-title {
                font-size: 18px;
            }

            .modal-subtitle {
                font-size: 13px;
            }

            .modal-percent {
                font-size: 24px;
            }

            .modal-info {
                flex-direction: column;
                gap: var(--spacing-sm);
            }

            /* Overlay badges */
            .video-overlay {
                top: var(--spacing-sm);
                right: var(--spacing-sm);
                gap: 4px;
            }

            .overlay-badge {
                padding: 4px 8px;
                font-size: 10px;
            }

            /* Mobile menu */
            .mobile-menu-content {
                max-width: 280px;
            }

            .mobile-menu-body {
                padding: var(--spacing-sm);
            }

            .mobile-menu-section {
                margin-bottom: var(--spacing-md);
            }

            .mobile-menu-section-title {
                font-size: 11px;
                padding: var(--spacing-xs) var(--spacing-sm);
            }

            .mobile-menu-actions {
                padding: var(--spacing-sm);
            }

            /* Notification */
            .notification {
                bottom: 100px;
                left: var(--spacing-md);
                right: var(--spacing-md);
                transform: none;
                font-size: 13px;
            }

            /* Install overlay */
            .install-overlay {
                border-radius: var(--radius-xl) var(--radius-xl) 0 0;
                padding: var(--spacing-lg) var(--spacing-md);
            }

            .install-btn {
                width: 100%;
            }
        }

        /* Tablet Styles (768px - 1023px) */
        @media screen and (min-width: 768px) and (max-width: 1023px) {
            header {
                padding: var(--spacing-md) var(--spacing-lg);
            }

            .logo-title {
                font-size: 17px;
            }

            .logo-subtitle {
                font-size: 11px;
            }

            .header-center {
                gap: var(--spacing-md);
            }

            .status-text {
                font-size: 12px;
            }

            /* Sidebar width reduced on tablet */
            .controls-sidebar {
                width: 240px;
            }

            /* Workspace */
            .workspace {
                padding: var(--spacing-md);
            }

            .upload-area {
                max-width: 420px;
            }

            /* Video */
            #renderCanvas {
                max-height: 60vh;
            }

            /* Cards */
            .card {
                padding: var(--spacing-sm);
            }

            /* Effect grid */
            .effect-grid {
                gap: var(--spacing-xs);
            }

            /* Modal */
            .modal {
                max-width: 380px;
                padding: var(--spacing-xl) var(--spacing-lg);
            }
        }

        /* Desktop Styles (1024px - 1279px) */
        @media screen and (min-width: 1024px) and (max-width: 1279px) {
            .controls-sidebar {
                width: 260px;
            }

            .workspace {
                padding: var(--spacing-lg);
            }

            #renderCanvas {
                max-height: 65vh;
            }
        }

        /* Large Desktop (1280px and above) */
        @media screen and (min-width: 1280px) {
            .controls-sidebar {
                width: 300px;
            }

            .workspace {
                padding: var(--spacing-xl);
            }

            #renderCanvas {
                max-height: 70vh;
            }
        }

        /* Landscape orientation adjustments */
        @media screen and (max-width: 1023px) and (orientation: landscape) {
            .controls-sidebar {
                max-height: 35vh;
            }

            .workspace {
                margin-bottom: 35vh;
            }

            #renderCanvas {
                max-height: 60vh;
            }
        }

        /* High DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .logo-icon,
            .logo-icon-img {
                image-rendering: -webkit-optimize-contrast;
            }

            .slider::-webkit-slider-thumb {
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            }
        }

        /* Reduce motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Dark mode preference */
        @media (prefers-color-scheme: dark) {
            :root {
                /* Already dark by default, but can add adjustments here */
            }
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: var(--spacing-xl);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius-xl);
            padding: var(--spacing-xl) var(--spacing-lg);
            text-align: center;
            max-width: 420px;
            width: 100%;
            box-shadow: var(--shadow-lg);
        }

        .modal-spinner {
            width: 56px;
            height: 56px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto var(--spacing-lg);
            position: relative;
        }

        .modal-spinner::before {
            content: '';
            position: absolute;
            inset: 4px;
            background: var(--bg-card);
            border-radius: 50%;
        }

        .modal-spinner::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-top-color: var(--primary-light);
            animation: spin 1.5s linear infinite reverse;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
        }

        .modal-subtitle {
            color: var(--text-muted);
            font-size: 14px;
            margin-bottom: var(--spacing-lg);
        }

        .modal-progress {
            height: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: var(--spacing-md);
            position: relative;
        }

        .modal-progress::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 8px,
                rgba(99, 102, 241, 0.1) 8px,
                rgba(99, 102, 241, 0.1) 16px
            );
        }

        .modal-progress-fill {
            height: 100%;
            background: var(--primary-gradient);
            width: 0%;
            border-radius: 4px;
            transition: width 0.3s ease;
            position: relative;
        }

        .modal-progress-fill::after {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 100px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3));
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .modal-percent {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 14px;
            font-weight: 700;
            color: var(--primary-light);
            margin-bottom: var(--spacing-md);
        }

        .modal-info {
            display: flex;
            justify-content: center;
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .modal-info-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .modal-info-label {
            font-size: 10px;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.5px;
        }

        .modal-info-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .modal-cancel {
            margin-top: var(--spacing-md);
            padding: 10px 24px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .modal-cancel:hover {
            border-color: var(--error);
            color: var(--error);
            background: var(--error-bg);
        }

        #fileInput {
            display: none;
        }

        /* ========================================
           RESPONSIVE DESIGN - COMPLETE
           Mobile-First with Progressive Enhancement
           ======================================== */

        /* Large Desktop (>= 1400px) */
        @media (min-width: 1400px) {
            .controls-sidebar {
                width: 300px;
            }
        }

        /* Desktop (1200px - 1399px) */
        @media (min-width: 1200px) and (max-width: 1399px) {
            .controls-sidebar {
                width: 280px;
            }
        }

        /* Tablet Landscape & Small Desktop (992px - 1199px) */
        @media (min-width: 992px) and (max-width: 1199px) {
            .app {
                flex-direction: column;
            }

            .controls-sidebar {
                width: 100%;
                height: auto;
                border-right: none;
                border-top: 1px solid var(--border);
                padding: var(--spacing-sm) var(--spacing-md);
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                gap: var(--spacing-sm);
                position: relative;
                top: 0;
            }

            .sidebar-section {
                flex: 1;
                min-width: 180px;
                max-width: none;
            }

            .process-section {
                margin-top: 0;
                flex-shrink: 0;
            }

            .workspace {
                padding: var(--spacing-md);
            }

            .header-center {
                gap: var(--spacing-md);
            }
        }

        /* Tablet Portrait (768px - 991px) */
        @media (min-width: 768px) and (max-width: 991px) {
            header {
                padding: var(--spacing-sm) var(--spacing-md);
            }

            .logo-title {
                font-size: 16px;
            }

            .logo-subtitle {
                font-size: 10px;
            }

            .app {
                flex-direction: column;
            }

            .controls-sidebar {
                width: 100%;
                height: auto;
                border-right: none;
                border-top: 1px solid var(--border);
                padding: var(--spacing-sm);
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                gap: var(--spacing-xs);
                position: relative;
                top: 0;
            }

            .sidebar-section {
                flex: 1;
                min-width: 140px;
                max-width: none;
                padding: var(--spacing-xs);
            }

            .process-section {
                margin-top: 0;
                flex-shrink: 0;
                min-width: 100%;
            }

            .workspace {
                padding: var(--spacing-sm);
                min-height: 50vh;
            }

            .video-canvas-wrapper {
                min-height: 300px;
            }

            #renderCanvas {
                max-height: 55vh;
            }

            .video-controls {
                padding: var(--spacing-sm) var(--spacing-md);
                flex-wrap: wrap;
            }

            .play-btn {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .time-display {
                min-width: 80px;
                font-size: 11px;
            }
        }

        /* Mobile Landscape (576px - 767px) */
        @media (min-width: 576px) and (max-width: 767px) {
            /* Hide hamburger, show simplified sidebar */
            .hamburger-btn {
                display: flex;
            }

            .controls-sidebar {
                display: none;
            }

            header {
                padding: var(--spacing-sm);
            }

            .logo-text {
                display: none;
            }

            .header-status {
                padding: var(--spacing-xs) var(--spacing-sm);
            }

            .status-text {
                font-size: 11px;
            }

            .app {
                flex-direction: column;
            }

            .workspace {
                padding: var(--spacing-sm);
                min-height: 45vh;
            }

            .upload-area {
                max-width: 100%;
                padding: var(--spacing-lg);
            }

            .upload-icon-wrapper {
                width: 80px;
                height: 80px;
            }

            .upload-icon {
                font-size: 32px;
            }

            .upload-title {
                font-size: 18px;
            }

            .video-card {
                border-radius: var(--radius-md);
            }

            .video-canvas-wrapper {
                min-height: 280px;
            }

            #renderCanvas {
                max-height: 50vh;
            }

            .video-controls {
                padding: var(--spacing-sm);
                gap: var(--spacing-sm);
            }

            .play-btn {
                width: 44px;
                height: 44px;
                font-size: 14px;
            }

            .time-display {
                min-width: 70px;
                font-size: 10px;
            }

            .progress-track {
                flex: 1;
                min-width: 100px;
            }

            .volume-control {
                display: none;
            }

            /* Mobile-friendly sliders */
            .slider {
                height: 6px;
            }

            .slider::-webkit-slider-thumb {
                width: 20px;
                height: 20px;
            }

            .slider::-moz-range-thumb {
                width: 20px;
                height: 20px;
            }

            /* Effect grid adjustments */
            .effect-grid {
                gap: var(--spacing-xs);
            }

            .effect-option {
                padding: var(--spacing-xs);
            }

            .effect-icon {
                font-size: 18px;
            }

            .effect-name {
                font-size: 10px;
            }

            /* Modal responsive */
            .modal {
                padding: var(--spacing-lg) var(--spacing-md);
                max-width: 90%;
            }

            .modal-spinner {
                width: 48px;
                height: 48px;
            }

            .modal-title {
                font-size: 18px;
            }

            .modal-info {
                gap: var(--spacing-md);
            }
        }

        /* Mobile Portrait (< 576px) - Full Mobile Experience */
        @media (max-width: 575px) {
            /* Enable hamburger menu */
            .hamburger-btn {
                display: flex;
            }

            /* Hide default sidebar completely */
            .controls-sidebar {
                display: none;
            }

            /* Compact header */
            header {
                padding: var(--spacing-xs) var(--spacing-sm);
                height: 60px;
            }

            .logo-icon,
            .logo-icon-img {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }

            .logo-text {
                display: none;
            }

            .header-center {
                display: none;
            }

            .header-actions {
                gap: var(--spacing-xs);
            }

            .header-btn {
                padding: var(--spacing-xs);
                font-size: 11px;
            }

            .header-btn i {
                font-size: 12px;
            }

            .header-btn span {
                display: none;
            }

            /* Main app layout */
            .app {
                flex-direction: column;
                min-height: calc(100vh - 60px);
            }

            .workspace {
                padding: var(--spacing-xs);
                flex: 1;
                display: flex;
                align-items: flex-start;
                justify-content: flex-start;
                min-height: auto;
            }

            /* Upload area */
            .upload-area {
                max-width: 100%;
                padding: var(--spacing-md);
                border-radius: var(--radius-lg);
            }

            .upload-icon-wrapper {
                width: 64px;
                height: 64px;
                margin-bottom: var(--spacing-md);
            }

            .upload-icon {
                font-size: 28px;
            }

            .upload-title {
                font-size: 16px;
                margin-bottom: var(--spacing-xs);
            }

            .upload-subtitle {
                font-size: 12px;
                margin-bottom: var(--spacing-md);
            }

            .upload-btn {
                padding: 12px 20px;
                font-size: 13px;
            }

            .upload-formats {
                margin-top: var(--spacing-md);
            }

            /* Video container */
            #videoContainer {
                width: 100%;
                padding: 0;
            }

            .video-card {
                border-radius: var(--radius-sm);
                border: none;
                box-shadow: var(--shadow-md);
            }

            .video-canvas-wrapper {
                min-height: 240px;
                border-radius: var(--radius-sm) var(--radius-sm) 0 0;
            }

            #renderCanvas {
                max-height: 45vh;
                width: 100%;
                object-fit: contain;
            }

            /* Video overlay badges */
            .video-overlay {
                top: var(--spacing-xs);
                right: var(--spacing-xs);
                gap: var(--spacing-xs);
            }

            .overlay-badge {
                padding: 4px 8px;
                font-size: 10px;
            }

            /* Video controls - Full touch-friendly */
            .video-controls {
                padding: var(--spacing-sm);
                gap: var(--spacing-sm);
                flex-wrap: wrap;
                background: rgba(0, 0, 0, 0.9);
            }

            .play-btn {
                width: 48px;
                height: 48px;
                font-size: 16px;
                box-shadow: var(--shadow-md);
            }

            .time-display {
                min-width: 60px;
                font-size: 10px;
                flex: 0 0 auto;
            }

            .progress-track {
                order: 10;
                width: 100%;
                height: 8px;
                margin-top: var(--spacing-xs);
            }

            .progress-track:hover {
                height: 8px;
            }

            .volume-control {
                display: none;
            }

            /* Touch-friendly interactive elements */
            .effect-option {
                padding: var(--spacing-sm);
                min-height: 60px;
            }

            .effect-icon {
                font-size: 20px;
                margin-bottom: 4px;
            }

            .effect-name {
                font-size: 10px;
            }

            .mode-option {
                padding: var(--spacing-sm);
            }

            .mode-icon {
                width: 32px;
                height: 32px;
            }

            .mode-name {
                font-size: 12px;
            }

            .mode-desc {
                font-size: 9px;
            }

            .preset-option {
                padding: var(--spacing-sm);
            }

            .preset-icon {
                width: 32px;
                height: 32px;
            }

            .preset-name {
                font-size: 12px;
            }

            .preset-desc {
                font-size: 9px;
            }

            /* Enhanced sliders for touch */
            .slider {
                -webkit-tap-highlight-color: transparent;
                height: 8px;
                background: var(--border);
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                background: var(--primary-gradient);
                cursor: pointer;
                box-shadow: var(--shadow-md);
                transition: transform var(--transition-fast);
            }

            .slider::-webkit-slider-thumb:active {
                transform: scale(1.2);
            }

            .slider::-moz-range-thumb {
                width: 24px;
                height: 24px;
                border-radius: 50%;
                background: var(--primary-gradient);
                cursor: pointer;
                border: none;
                box-shadow: var(--shadow-md);
            }

            .slider-labels {
                margin-top: 4px;
            }

            .slider-labels span {
                font-size: 10px;
            }

            /* Preview toggle */
            .preview-toggle {
                grid-template-columns: 1fr 1fr;
                gap: var(--spacing-xs);
            }

            .preview-btn {
                padding: var(--spacing-sm);
                font-size: 11px;
            }

            .preview-btn i {
                font-size: 18px;
                margin-bottom: 4px;
            }

            /* Process button - Full width on mobile */
            .btn {
                padding: 14px 16px;
                font-size: 14px;
                min-height: 52px;
            }

            .btn-primary {
                width: 100%;
            }

            /* Modal improvements for mobile */
            .modal-overlay {
                padding: var(--spacing-md);
                align-items: flex-end;
            }

            .modal {
                width: 100%;
                max-width: 100%;
                padding: var(--spacing-lg) var(--spacing-md);
                border-radius: var(--radius-lg) var(--radius-lg) 0 0;
                max-height: 85vh;
                overflow-y: auto;
            }

            .modal-spinner {
                width: 56px;
                height: 56px;
            }

            .modal-title {
                font-size: 18px;
            }

            .modal-subtitle {
                font-size: 13px;
            }

            .modal-info {
                flex-direction: column;
                gap: var(--spacing-sm);
            }

            .modal-progress {
                height: 10px;
                border-radius: 5px;
            }

            .modal-percent {
                font-size: 16px;
            }

            .modal-cancel {
                width: 100%;
                padding: 12px;
                margin-top: var(--spacing-md);
            }

            /* Notifications */
            .notification {
                left: var(--spacing-sm);
                right: var(--spacing-sm);
                bottom: var(--spacing-md);
                transform: none;
            }

            /* Install overlay */
            #installOverlay .modal {
                max-height: 90vh;
            }

            #installBtn {
                padding: var(--spacing-xs) var(--spacing-sm);
                font-size: 11px;
            }

            #installBtn i {
                margin-right: 4px;
            }
        }

        /* Extra small devices optimization */
        @media (max-width: 380px) {
            .logo-icon,
            .logo-icon-img {
                width: 32px;
                height: 32px;
            }

            .hamburger-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .header-btn {
                padding: var(--spacing-xs);
            }

            .effect-grid {
                grid-template-columns: 1fr 1fr;
            }

            .effect-option {
                min-height: 55px;
            }

            .effect-icon {
                font-size: 18px;
            }

            .video-canvas-wrapper {
                min-height: 200px;
            }

            #renderCanvas {
                max-height: 40vh;
            }

            .play-btn {
                width: 44px;
                height: 44px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            /* Ensure touch targets are large enough */
            .effect-option,
            .mode-option,
            .preset-option,
            .preview-btn,
            .btn {
                min-height: 44px;
            }

            /* Remove hover effects on touch devices */
            .effect-option:hover,
            .mode-option:hover,
            .preset-option:hover,
            .preview-btn:hover,
            .header-btn:hover {
                transform: none;
            }

            /* Larger touch feedback */
            .effect-option:active,
            .mode-option:active,
            .preset-option:active,
            .preview-btn:active,
            .header-btn:active {
                transform: scale(0.98);
            }

            /* Disable text selection on touch */
            .effect-option,
            .mode-option,
            .preset-option,
            .preview-btn,
            .btn,
            .header-btn {
                -webkit-user-select: none;
                user-select: none;
            }
        }

        /* Landscape orientation on mobile */
        @media (max-width: 767px) and (orientation: landscape) {
            header {
                height: 56px;
            }

            .app {
                min-height: calc(100vh - 56px);
                flex-direction: row;
            }

            .workspace {
                flex: 1;
                padding: var(--spacing-sm);
            }

            .video-canvas-wrapper {
                min-height: auto;
                max-height: calc(100vh - 56px - 80px);
            }

            #renderCanvas {
                max-height: calc(100vh - 56px - 80px);
                max-width: 100%;
            }

            /* In landscape, show sidebar as bottom panel */
            .controls-sidebar {
                display: none;
            }

            /* Use hamburger in landscape too */
            .hamburger-btn {
                display: flex;
            }

            .logo-text {
                display: none;
            }

            .header-center {
                display: none;
            }
        }

        /* High DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .slider::-webkit-slider-thumb {
                box-shadow: var(--shadow-sm);
            }

            .play-btn,
            .btn-primary {
                box-shadow: var(--shadow-sm), var(--shadow-glow);
            }
        }

        /* Reduce motion for accessibility */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Dark mode support (for future enhancement) */
        @media (prefers-color-scheme: dark) {
            /* Already dark by default, but ready for light mode support */
        }

        /* Loading Animation */
        .loading-dots {
            display: inline-flex;
            gap: 4px;
        }

        .loading-dots span {
            width: 6px;
            height: 6px;
            background: var(--primary);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
        .loading-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Tooltip */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 10px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 11px;
            white-space: nowrap;
            color: var(--text-secondary);
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-fast);
            z-index: 100;
            margin-bottom: 8px;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Face counter badge */
        .face-counter {
            position: absolute;
            bottom: var(--spacing-md);
            left: var(--spacing-md);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            z-index: 10;
        }

        .face-counter-icon {
            width: 28px;
            height: 28px;
            background: var(--primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .face-counter-info {
            display: flex;
            flex-direction: column;
        }

        .face-counter-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .face-counter-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* PWA Install Button */
        .install-btn {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 16px 24px;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: var(--radius-lg);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: var(--shadow-lg), var(--shadow-glow);
            z-index: 1000;
            transition: all var(--transition-normal);
            animation: slideInUp 0.5s ease;
        }

        .install-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(99, 102, 241, 0.4);
        }

        .install-btn.hidden {
            display: none;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* MediaPipe Configuration Panel */
        .config-section {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            margin-bottom: var(--spacing-sm);
        }

        .config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            cursor: pointer;
        }

        .config-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .config-toggle {
            font-size: 12px;
            color: var(--primary);
            transition: transform var(--transition-fast);
        }

        .config-toggle.open {
            transform: rotate(180deg);
        }

        .config-content {
            display: none;
        }

        .config-content.open {
            display: block;
        }

        .config-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--border);
        }

        .config-row:last-child {
            border-bottom: none;
        }

        .config-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .config-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--primary-light);
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .config-select {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            font-size: 11px;
            padding: 4px 8px;
            cursor: pointer;
            min-width: 80px;
        }

        .config-select:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Video Playback Controls */
        .playback-controls {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid var(--border);
        }

        .playback-btn {
            width: 40px;
            height: 40px;
            background: var(--primary-gradient);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: transform var(--transition-fast);
        }

        .playback-btn:hover {
            transform: scale(1.1);
        }

        .playback-time {
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 11px;
            color: var(--text-muted);
            min-width: 90px;
        }

        .playback-progress {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .playback-progress-fill {
            height: 100%;
            background: var(--primary-gradient);
            width: 0%;
            border-radius: 2px;
            position: relative;
            transition: width 0.1s linear;
        }

        .playback-volume {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .volume-slider {
            width: 60px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            -webkit-appearance: none;
            appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Installation Progress Overlay */
        .install-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            flex-direction: column;
            gap: 24px;
        }

        .install-overlay.active {
            display: flex;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider-round {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-dark);
            transition: 0.3s;
            border-radius: 20px;
        }

        .slider-round:before {
            position: absolute;
            content: '';
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider-round {
            background-color: var(--primary);
        }

        input:checked + .slider-round:before {
            transform: translateX(16px);
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .install-overlay-content {
            text-align: center;
            color: var(--text-primary);
        }

        .install-icon {
            width: 80px;
            height: 80px;
            background: var(--primary-gradient);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 24px;
            font-size: 36px;
            animation: pulse 2s infinite;
        }

        .install-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .install-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
            max-width: 300px;
            margin: 0 auto;
        }

        .install-progress-container {
            width: 300px;
            margin-top: 24px;
        }

        .install-progress {
            height: 8px;
            background: var(--bg-elevated);
            border-radius: 4px;
            overflow: hidden;
        }

        .install-progress-fill {
            height: 100%;
            background: var(--primary-gradient);
            width: 0%;
            transition: width 0.3s ease;
        }

        .install-percent {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary-light);
            margin-top: 12px;
            font-family: 'SF Mono', 'Monaco', monospace;
        }

        .install-status {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 8px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <img src="icon.png" alt="FaceBlur Studio Logo" class="logo-icon-img">
            <div class="logo-text">
                <span class="logo-title">FaceBlur Studio</span>
                <span class="logo-subtitle">Editor Profesional de Anonimización</span>
            </div>
        </div>
        
        <div class="header-center">
            <div class="header-status" id="aiStatus">
                <div class="status-dot"></div>
                <span class="status-text">Cargando IA...</span>
            </div>
        </div>

        <div class="header-actions">
            <button class="hamburger-btn" id="hamburgerBtn" aria-label="Abrir menú">
                <i class="fas fa-bars"></i>
            </button>
            <button class="install-btn hidden" id="installBtn">
                <i class="fas fa-download"></i>
                <span>Instalar</span>
            </button>
        </div>
    </header>

    <!-- Mobile Menu Overlay -->
    <div class="mobile-menu-overlay" id="mobileMenuOverlay">
        <div class="mobile-menu-content">
            <div class="mobile-menu-header">
                <span class="mobile-menu-title">Configuración</span>
                <button class="mobile-menu-close" id="mobileMenuClose" aria-label="Cerrar menú">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="mobile-menu-body">
                <!-- Controls will be cloned here dynamically -->
            </div>
        </div>
    </div>

    <div class="app">
        <!-- Panel izquierdo: Controles -->
        <aside class="sidebar controls-sidebar">
            <div class="sidebar-section">
                <div class="section-header">
                    <span class="section-title">Efecto de Ocultación</span>
                </div>
                <div class="effect-grid">
                    <div class="effect-option active" data-effect="pixelate">
                        <span class="effect-icon">▦</span>
                        <span class="effect-name">Pixelado</span>
                    </div>
                    <div class="effect-option" data-effect="blur">
                        <span class="effect-icon">◐</span>
                        <span class="effect-name">Desenfoque</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-header">
                    <span class="section-title">Parámetros del Efecto</span>
                </div>
                
                <!-- Intensidad -->
                <div class="slider-wrapper" style="margin-bottom: 12px;">
                    <div class="slider-header">
                        <span class="slider-label"><i class="fas fa-eye-slash"></i> Intensidad</span>
                        <span class="slider-value" id="intensityVal">15</span>
                    </div>
                    <input type="range" class="slider" id="intensity" min="5" max="50" value="15">
                    <div class="slider-labels">
                        <span>Sutil</span>
                        <span>Moderado</span>
                        <span>Fuerte</span>
                    </div>
                </div>
                
                <!-- Tamaño -->
                <div class="slider-wrapper" style="margin-bottom: 12px;">
                    <div class="slider-header">
                        <span class="slider-label"><i class="fas fa-expand"></i> Tamaño</span>
                        <span class="slider-value" id="sizeVal">100%</span>
                    </div>
                    <input type="range" class="slider" id="effectSize" min="50" max="200" value="100">
                    <div class="slider-labels">
                        <span>Pequeño</span>
                        <span>Normal</span>
                        <span>Grande</span>
                    </div>
                </div>
                
                <!-- Suavidad de bordes -->
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <span class="slider-label"><i class="fas fa-adjust"></i> Suavidad</span>
                        <span class="slider-value" id="borderVal">0px</span>
                    </div>
                    <input type="range" class="slider" id="borderSmooth" min="0" max="20" value="0">
                    <div class="slider-labels">
                        <span>Duro</span>
                        <span>Normal</span>
                        <span>Suave</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-header">
                    <span class="section-title">Modo de Detección</span>
                </div>
                <div class="mode-list" id="detectionModes">
                    <div class="mode-option active" data-mode="all">
                        <div class="mode-icon">
                            <i class="fas fa-users"></i>
                        </div>
                        <div class="mode-info">
                            <div class="mode-name">Todos los rostros</div>
                            <div class="mode-desc">Detecta y oculta todos los rostros</div>
                        </div>
                        <div class="mode-check">
                            <i class="fas fa-check"></i>
                        </div>
                    </div>
                    <div class="mode-option" data-mode="single">
                        <div class="mode-icon">
                            <i class="fas fa-user"></i>
                        </div>
                        <div class="mode-info">
                            <div class="mode-name">Solo un rostro</div>
                            <div class="mode-desc">Oculta el primer rostro detectado</div>
                        </div>
                        <div class="mode-check">
                            <i class="fas fa-check"></i>
                        </div>
                    </div>
                    <div class="mode-option" data-mode="center">
                        <div class="mode-icon">
                            <i class="fas fa-crosshairs"></i>
                        </div>
                        <div class="mode-info">
                            <div class="mode-name">Rostro centrado</div>
                            <div class="mode-desc">Oculta el rostro más centrado</div>
                        </div>
                        <div class="mode-check">
                            <i class="fas fa-check"></i>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="section-header">
                    <span class="section-title">Vista Previa</span>
                </div>
                <div class="preview-toggle">
                    <button class="preview-btn active" id="previewOriginal">
                        <i class="fas fa-eye"></i>
                        Original
                    </button>
                    <button class="preview-btn" id="previewEffects">
                        <i class="fas fa-magic"></i>
                        Con Efectos
                    </button>
                </div>
            </div>

            <!-- Configuración de MediaPipe Face Mesh - Presets -->
            <div class="sidebar-section">
                <div class="section-header">
                    <span class="section-title">Configuración IA</span>
                    <span class="section-badge" id="activePresetBadge">Equilibrado</span>
                </div>
                
                <div class="preset-list" id="aiPresets">
                    <!-- Preset: Rápido -->
                    <div class="preset-option" data-preset="fast">
                        <div class="preset-icon">
                            <i class="fas fa-bolt"></i>
                        </div>
                        <div class="preset-info">
                            <div class="preset-name">Rápido</div>
                            <div class="preset-desc">Velocidad optimizada</div>
                        </div>
                        <div class="preset-check">
                            <i class="fas fa-check"></i>
                        </div>
                    </div>
                    
                    <!-- Preset: Equilibrado -->
                    <div class="preset-option active" data-preset="balanced">
                        <div class="preset-icon">
                            <i class="fas fa-balance-scale"></i>
                        </div>
                        <div class="preset-info">
                            <div class="preset-name">Equilibrado</div>
                            <div class="preset-desc">Velocidad y precisión</div>
                        </div>
                        <div class="preset-check">
                            <i class="fas fa-check"></i>
                        </div>
                    </div>
                    
                    <!-- Preset: Preciso -->
                    <div class="preset-option" data-preset="precise">
                        <div class="preset-icon">
                            <i class="fas fa-crosshairs"></i>
                        </div>
                        <div class="preset-info">
                            <div class="preset-name">Preciso</div>
                            <div class="preset-desc">Máxima precisión</div>
                        </div>
                        <div class="preset-check">
                            <i class="fas fa-check"></i>
                        </div>
                    </div>
                    
                    <!-- Preset: Ultra -->
                    <div class="preset-option" data-preset="ultra">
                        <div class="preset-icon">
                            <i class="fas fa-bullseye"></i>
                        </div>
                        <div class="preset-info">
                            <div class="preset-name">Ultra</div>
                            <div class="preset-desc">Tracking avanzado</div>
                        </div>
                        <div class="preset-check">
                            <i class="fas fa-check"></i>
                        </div>
                    </div>
                </div>
                
                <div class="preset-details" id="presetDetails" style="margin-top: 12px; padding: 10px; background: var(--bg-dark); border-radius: var(--radius-md); border: 1px solid var(--border);">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">
                        <span>Modelo:</span>
                        <span id="presetModel">Completo</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">
                        <span>Confianza:</span>
                        <span id="presetConfidence">70%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--text-muted);">
                        <span>Rendimiento:</span>
                        <span id="presetPerformance">Medio</span>
                    </div>
                </div>
            </div>

            <div class="sidebar-section process-section">
                <button class="btn btn-primary" id="processBtn" disabled>
                    <i class="fas fa-bolt"></i>
                    <span class="btn-text">Procesar Video</span>
                </button>
                <div class="process-info">
                    <i class="fas fa-info-circle"></i>
                    <span>Procesamiento frame a frame para máxima precisión</span>
                </div>
            </div>
        </aside>

        <!-- Panel central: Workspace -->
        <main class="workspace">
            <!-- Área de carga de video -->
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon-wrapper">
                    <span class="upload-icon">📹</span>
                </div>
                <div class="upload-title">Subir Video</div>
                <div class="upload-subtitle">Selecciona un video para comenzar a anonimizar rostros</div>
                <div class="upload-btn">
                    <i class="fas fa-folder-open"></i>
                    Elegir Archivo
                </div>
                <div class="upload-formats">
                    <span class="format-badge">MP4</span>
                    <span class="format-badge">WebM</span>
                    <span class="format-badge">MOV</span>
                    <span class="format-badge">AVI</span>
                </div>
            </div>

            <!-- Contenedor de video -->
            <div id="videoContainer">
                <div class="video-card">
                    <div class="video-canvas-wrapper">
                        <canvas id="renderCanvas"></canvas>
                        <div class="video-overlay">
                            <div class="overlay-badge" id="previewModeBadge">
                                <i class="fas fa-eye"></i>
                                <span>Vista Previa</span>
                            </div>
                        </div>
                        <div class="face-counter" id="faceCounter" style="display: none;">
                            <div class="face-counter-icon">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="face-counter-info">
                                <span class="face-counter-label">Rostros detectados</span>
                                <span class="face-counter-value" id="faceCountValue">0</span>
                            </div>
                        </div>
                    </div>
                    <div class="video-controls">
                        <button class="play-btn" id="playBtn">
                            <i class="fas fa-play"></i>
                        </button>
                        <div class="time-display" id="timeDisplay">
                            <i class="fas fa-clock"></i>
                            <span>0:00 / 0:00</span>
                        </div>
                        <div class="progress-track" id="progressTrack">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="volume-control">
                            <button class="volume-btn" id="volumeBtn">
                                <i class="fas fa-volume-mute"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

    <input type="file" id="fileInput" accept="video/*">

    <div class="modal-overlay" id="modal">
        <div class="modal">
            <div class="modal-spinner"></div>
            <div class="modal-title" id="modalTitle">Procesando Video</div>
            <div class="modal-subtitle" id="modalSubtitle">
                <span class="loading-dots">
                    <span></span><span></span><span></span>
                </span>
                Preparando...
            </div>
            <div class="modal-progress">
                <div class="modal-progress-fill" id="modalFill"></div>
            </div>
            <div class="modal-percent" id="modalPercent">0%</div>
            <div class="modal-info">
                <div class="modal-info-item">
                    <span class="modal-info-label">Frames</span>
                    <span class="modal-info-value" id="modalFrames">0 / 0</span>
                </div>
                <div class="modal-info-item">
                    <span class="modal-info-label">Tiempo</span>
                    <span class="modal-info-value" id="modalTime">0:00</span>
                </div>
            </div>
            <button class="modal-cancel" id="cancelBtn">Cancelar Procesamiento</button>
        </div>
    </div>

    <!-- Botón de instalación PWA -->
    <button class="install-btn hidden" id="installBtn">
        <i class="fas fa-download"></i>
        <span>Instalar App</span>
    </button>

    <!-- Overlay de instalación -->
    <div class="install-overlay" id="installOverlay">
        <div class="install-overlay-content">
            <div class="install-icon">
                <i class="fas fa-rocket"></i>
            </div>
            <div class="install-title">Instalando FaceBlur Studio</div>
            <div class="install-subtitle">Descargando todos los recursos para uso sin conexión...</div>
            <div class="install-progress-container">
                <div class="install-progress">
                    <div class="install-progress-fill" id="installProgressFill"></div>
                </div>
                <div class="install-percent" id="installPercent">0%</div>
                <div class="install-status" id="installStatus">Inicializando...</div>
            </div>
        </div>
    </div>

    <!-- MediaPipe Face Mesh Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <!-- MediaPipe Tasks Vision API (más moderna y estable) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/tasks-vision.min.js" crossorigin="anonymous"></script>
    <script>
        // App State
        const state = {
            effect: 'pixelate',
            intensity: 15,
            effectSize: 100,      // Porcentaje del tamaño del efecto (50-200)
            borderSmooth: 0,      // Suavidad de bordes en píxeles (0-20)
            detectionMode: 'all',
            previewMode: 'original',
            processedBlob: null,
            videoBlobUrl: null,
            isPlaying: false,
            isProcessing: false,
            processingCanceled: false,
            modelReady: false,
            videoWidth: 0,
            videoHeight: 0,
            faceCount: 0,
            // MediaPipe Face Mesh state
            useMediaPipe: false,   // Usando MediaPipe Face Mesh
            modelName: 'MediaPipe Face Mesh',
            modelVersion: '1.0',
            landmarksPerFace: 468  // Puntos faciales por rostro
        };

        // Face tracking variables
        let trackedFaces = [];
        let nextFaceId = 0;

        // DOM Elements
        const elements = {
            uploadArea: document.getElementById('uploadArea'),
            fileInput: document.getElementById('fileInput'),
            videoContainer: document.getElementById('videoContainer'),
            renderCanvas: document.getElementById('renderCanvas'),
            playBtn: document.getElementById('playBtn'),
            progressFill: document.getElementById('progressFill'),
            progressTrack: document.getElementById('progressTrack'),
            timeDisplay: document.getElementById('timeDisplay'),
            intensitySlider: document.getElementById('intensity'),
            intensityVal: document.getElementById('intensityVal'),
            effectSizeSlider: document.getElementById('effectSize'),
            sizeVal: document.getElementById('sizeVal'),
            borderSmoothSlider: document.getElementById('borderSmooth'),
            borderVal: document.getElementById('borderVal'),
            processBtn: document.getElementById('processBtn'),
            exportBtn: null, // Botón eliminado de la UI
            newBtn: null, // Botón eliminado de la UI
            modal: document.getElementById('modal'),
            modalFill: document.getElementById('modalFill'),
            modalPercent: document.getElementById('modalPercent'),
            modalTitle: document.getElementById('modalTitle'),
            modalSubtitle: document.getElementById('modalSubtitle'),
            aiStatus: document.getElementById('aiStatus'),
            cancelBtn: document.getElementById('cancelBtn'),
            effectOptions: document.querySelectorAll('.effect-option'),
            detectionModes: document.querySelectorAll('#detectionModes .mode-option'),
            previewOriginal: document.getElementById('previewOriginal'),
            previewEffects: document.getElementById('previewEffects'),
            faceCounter: document.getElementById('faceCounter'),
            faceCountValue: document.getElementById('faceCountValue'),
            previewModeBadge: document.getElementById('previewModeBadge'),
            modalFrames: document.getElementById('modalFrames'),
            modalTime: document.getElementById('modalTime'),
            volumeBtn: document.getElementById('volumeBtn'),
            
            // Safe getter for renderCtx
            get renderCtx() {
                return this.renderCanvas ? this.renderCanvas.getContext('2d') : null;
            }
        };

        // Video element
        const video = document.createElement('video');
        video.muted = true;
        video.playsInline = true;
        video.style.display = 'none';
        document.body.appendChild(video);

        // Processing canvas
        const processCanvas = document.createElement('canvas');
        document.body.appendChild(processCanvas);

        // Initialize
        async function init() {
            setupEventListeners();
            setupMobileFeatures();
            await loadAI();
        }

        // Mobile-specific features
        function setupMobileFeatures() {
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            const mobileMenuOverlay = document.querySelector('.mobile-menu-overlay');
            const mobileMenuClose = document.querySelector('.mobile-menu-close');
            const sidebarToggle = document.querySelector('.sidebar-toggle');
            const controlsSidebar = document.querySelector('.controls-sidebar');

            // Mobile menu toggle
            if (hamburgerBtn && mobileMenuOverlay) {
                hamburgerBtn.addEventListener('click', function() {
                    this.classList.toggle('active');
                    mobileMenuOverlay.classList.toggle('active');
                    document.body.style.overflow = mobileMenuOverlay.classList.contains('active') ? 'hidden' : '';
                });

                // Close menu when clicking close button
                if (mobileMenuClose) {
                    mobileMenuClose.addEventListener('click', function() {
                        hamburgerBtn.classList.remove('active');
                        mobileMenuOverlay.classList.remove('active');
                        document.body.style.overflow = '';
                    });
                }

                // Close menu when clicking overlay
                mobileMenuOverlay.addEventListener('click', function(e) {
                    if (e.target === mobileMenuOverlay) {
                        hamburgerBtn.classList.remove('active');
                        this.classList.remove('active');
                        document.body.style.overflow = '';
                    }
                });
            }

            // Sidebar collapse on mobile
            if (sidebarToggle && controlsSidebar) {
                sidebarToggle.addEventListener('click', function() {
                    controlsSidebar.classList.toggle('collapsed');
                    this.classList.toggle('rotated');
                });
            }

            // Handle window resize for responsive video
            window.addEventListener('resize', handleResize);
            
            // Initial resize check
            handleResize();
        }

        // Handle window resize
        function handleResize() {
            const isMobile = window.innerWidth <= 767;
            
            // Adjust video canvas on mobile
            if (isMobile && video && video.videoWidth > 0) {
                const renderCanvas = document.getElementById('renderCanvas');
                if (renderCanvas) {
                    const maxHeight = window.innerHeight * 0.5;
                    const maxWidth = window.innerWidth - 32;
                    
                    // Maintain aspect ratio while fitting mobile screen
                    const aspectRatio = video.videoWidth / video.videoHeight;
                    const calculatedHeight = maxWidth / aspectRatio;
                    
                    renderCanvas.style.maxHeight = Math.min(maxHeight, calculatedHeight) + 'px';
                    renderCanvas.style.maxWidth = maxWidth + 'px';
                }
            }
        }

        // Load AI Model - MediaPipe Face Mesh with Optimal Parameters
        async function loadAI() {
            console.log('Inicializando MediaPipe Face Mesh con parámetros de alta precisión...');

            // Verificar que FilesetResolver esté disponible (Tasks Vision API)
            if (typeof FilesetResolver === 'undefined') {
                console.error('MediaPipe Tasks Vision no está cargado');
                updateAIStatus(false);
                showNotification('Error: No se puede cargar la detección facial.', 'error');
                return;
            }

            try {
                // Usar MediaPipe Tasks Vision API (más moderna y estable)
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
                );
                
                // Configurar según el preset activo
                const preset = AI_PRESETS[activePreset] || AI_PRESETS.balanced;
                
                // Crear el detector de rostros
                window.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/facelandmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: preset.refineLandmarks,
                    runningMode: "VIDEO",
                    numFaces: 10
                });
                
                // Configurar parámetros de detección
                window.faceMeshParams = {
                    modelSelection: preset.modelSelection,
                    refineLandmarks: preset.refineLandmarks,
                    minDetectionConfidence: preset.minDetectionConfidence,
                    minTrackingConfidence: preset.minTrackingConfidence,
                    maxNumFaces: 10
                };
                
                // Función de detección adaptada para Tasks API
                window.detectFaces = async function(videoElement) {
                    if (!window.faceLandmarker || !videoElement.videoWidth) return [];
                    
                    try {
                        const startTimeMs = performance.now();
                        const results = window.faceLandmarker.detectForVideo(videoElement, startTimeMs);
                        
                        if (!results || !results.faceLandmarks || results.faceLandmarks.length === 0) {
                            return [];
                        }
                        
                        // Convertir landmarks a bounding boxes
                        return results.faceLandmarks.map((landmarks, index) => {
                            // Calcular bounding box desde landmarks
                            let minX = 1, minY = 1, maxX = 0, maxY = 0;
                            landmarks.forEach(point => {
                                minX = Math.min(minX, point.x);
                                minY = Math.min(minY, point.y);
                                maxX = Math.max(maxX, point.x);
                                maxY = Math.max(maxY, point.y);
                            });
                            
                            const box = {
                                x: minX * videoElement.videoWidth,
                                y: minY * videoElement.videoHeight,
                                width: (maxX - minX) * videoElement.videoWidth,
                                height: (maxY - minY) * videoElement.videoHeight
                            };
                            
                            return {
                                box: box,
                                score: results.faceLandmarks.length > 0 ? 0.9 : 0.5
                            };
                        });
                    } catch (error) {
                        console.warn('Detection error:', error.message);
                        return [];
                    }
                };
                
                state.modelReady = true;
                state.useMediaPipeTasks = true;
                state.modelName = 'MediaPipe FaceLandmarker (Tasks API)';
                state.modelVersion = '2.0';
                updateAIStatus(true);
                
                console.log('✅ MediaPipe Tasks Vision cargado correctamente');
                console.log('   - Preset:', preset.name);
                console.log('   - Landmarks:', preset.refineLandmarks ? '468 + iris' : '468');
                
            } catch (error) {
                console.error('Error inicializando MediaPipe Tasks:', error);
                updateAIStatus(false);
                showNotification('Error cargando modelos de IA.', 'error');
            }
        }

        // ========================================
        // PARÁMETROS DE CONFIGURACIÓN DE DETECCIÓN
        // ========================================

        // Parámetros actuales de MediaPipe
        window.faceMeshParams = {
            modelSelection: 1,        // 0=corto, 1=completo
            maxNumFaces: 10,          // hasta 10 rostros
            refineLandmarks: true,    // 468 puntos + iris
            minDetectionConfidence: 0.5,  // sensibilidad detección
            minTrackingConfidence: 0.5    // sensibilidad tracking
        };

        // Función para actualizar parámetros en tiempo real
        function updateFaceMeshParams(newParams) {
            // La API de Tasks se inicializa con todos los parámetros de una vez
            // No es necesario actualizar opciones en tiempo real
            // Los presets recrean el modelo con nuevos parámetros
            
            console.log('Parámetros MediaPipe Tasks configurados:', window.faceMeshParams);
        }

        // ========================================
        // ROBUST MEDIA PIPE DETECTION
        // Siempre retorna detecciones válidas
        // ========================================

        // Buffer persistente de la última detección válida
        window.lastValidDetections = [];
        window.lastDetectionTimestamp = 0;

        // La función detectFaces ya está definida en loadAI() usando Tasks API
        // No necesitamos redefinirla aquí

        // Función para calcular bounding box desde landmarks
        function getBoundingBoxFromLandmarks(landmarks, width, height, padding = 0.2) {
            let minX = 1.0, maxX = 0.0;
            let minY = 1.0, maxY = 0.0;

            // Iterar sobre todos los landmarks para encontrar extremos
            for (const landmark of landmarks) {
                if (landmark.x < minX) minX = landmark.x;
                if (landmark.x > maxX) maxX = landmark.x;
                if (landmark.y < minY) minY = landmark.y;
                if (landmark.y > maxY) maxY = landmark.y;
            }

            // Calcular dimensiones con padding
            const boxWidth = (maxX - minX) * width;
            const boxHeight = (maxY - minY) * height;
            const paddingX = boxWidth * padding;
            const paddingY = boxHeight * padding;

            // Aplicar padding y convertir a coordenadas de píxeles
            const x = Math.max(0, (minX * width) - paddingX);
            const y = Math.max(0, (minY * height) - paddingY);
            const w = Math.min(width - x, boxWidth + (paddingX * 2));
            const h = Math.min(height - y, boxHeight + (paddingY * 2));

            return { x, y, width: w, height: h };
        }

        function updateAIStatus(ready) {
            if (ready) {
                elements.aiStatus.classList.add('ready');
                elements.aiStatus.querySelector('.status-dot').style.animation = 'none';
                
                // Mostrar información del modelo MediaPipe Tasks
                if (state.useMediaPipeTasks) {
                    elements.aiStatus.querySelector('.status-text').textContent = `MediaPipe Tasks (${state.landmarksPerFace || 478} puntos)`;
                    elements.aiStatus.title = 'Detección facial con MediaPipe Tasks Vision API';
                } else {
                    elements.aiStatus.querySelector('.status-text').textContent = 'IA Lista';
                }
                
                if (state.videoWidth > 0) {
                    elements.processBtn.disabled = false;
                }
            } else {
                elements.aiStatus.classList.remove('ready');
                elements.aiStatus.querySelector('.status-dot').style.animation = 'pulse 2s infinite';
                elements.aiStatus.querySelector('.status-text').textContent = 'IA No disponible';
                elements.aiStatus.title = '';
            }
        }

        function setupEventListeners() {
            elements.uploadArea.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', handleFileSelect);

            elements.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.uploadArea.classList.add('dragover');
            });
            elements.uploadArea.addEventListener('dragleave', () => {
                elements.uploadArea.classList.remove('dragover');
            });
            elements.uploadArea.addEventListener('drop', handleDrop);

            elements.playBtn.addEventListener('click', togglePlay);
            elements.progressTrack.addEventListener('click', seek);

            elements.intensitySlider.addEventListener('input', (e) => {
                state.intensity = parseInt(e.target.value);
                elements.intensityVal.textContent = state.intensity;
            });

            // Slider de tamaño
            const effectSizeSlider = document.getElementById('effectSize');
            const sizeVal = document.getElementById('sizeVal');
            if (effectSizeSlider) {
                effectSizeSlider.addEventListener('input', (e) => {
                    state.effectSize = parseInt(e.target.value);
                    sizeVal.textContent = state.effectSize + '%';
                    renderFrame();
                });
            }

            // Slider de suavidad de bordes
            const borderSmoothSlider = document.getElementById('borderSmooth');
            const borderVal = document.getElementById('borderVal');
            if (borderSmoothSlider) {
                borderSmoothSlider.addEventListener('input', (e) => {
                    state.borderSmooth = parseInt(e.target.value);
                    borderVal.textContent = state.borderSmooth + 'px';
                    renderFrame();
                });
            }

            elements.effectOptions.forEach(option => {
                option.addEventListener('click', () => {
                    elements.effectOptions.forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    state.effect = option.dataset.effect;
                    renderFrame();
                });
            });

            // New inline effect buttons
            const effectPixelate = document.getElementById('effectPixelate');
            const effectBlur = document.getElementById('effectBlur');
            
            if (effectPixelate && effectBlur) {
                effectPixelate.addEventListener('click', () => {
                    effectPixelate.classList.add('active');
                    effectBlur.classList.remove('active');
                    state.effect = 'pixelate';
                    renderFrame();
                });
                
                effectBlur.addEventListener('click', () => {
                    effectBlur.classList.add('active');
                    effectPixelate.classList.remove('active');
                    state.effect = 'blur';
                    renderFrame();
                });
            }

            // Detection mode options
            elements.detectionModes.forEach(option => {
                option.addEventListener('click', () => {
                    elements.detectionModes.forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    state.detectionMode = option.dataset.mode;
                    renderFrame();
                });
            });

            // Preview mode buttons
            if (elements.previewOriginal && elements.previewEffects) {
                elements.previewOriginal.addEventListener('click', () => {
                    elements.previewOriginal.classList.add('active');
                    elements.previewEffects.classList.remove('active');
                    state.previewMode = 'original';
                    document.getElementById('previewModeBadge').classList.remove('active');
                    document.getElementById('faceCounter').style.display = 'none';
                    renderFrame();
                });
                
                elements.previewEffects.addEventListener('click', () => {
                    if (!state.modelReady) return;
                    elements.previewEffects.classList.add('active');
                    elements.previewOriginal.classList.remove('active');
                    state.previewMode = 'effects';
                    document.getElementById('previewModeBadge').classList.add('active');
                    renderFrame();
                });
            }

            elements.processBtn.addEventListener('click', processVideo);
            
            // Botones eliminados de la UI
            if (elements.exportBtn) {
                elements.exportBtn.addEventListener('click', exportVideo);
            }
            if (elements.newBtn) {
                elements.newBtn.addEventListener('click', resetApp);
            }
            
            elements.cancelBtn.addEventListener('click', () => {
                state.processingCanceled = true;
            });

            video.addEventListener('timeupdate', updateProgress);
            video.addEventListener('ended', () => {
                state.isPlaying = false;
                elements.playBtn.innerHTML = '<i class="fas fa-play"></i>';
                stopPreviewLoop();
            });

            elements.volumeBtn.addEventListener('click', toggleMute);

            // Mobile Menu Functionality
            setupMobileMenu();
        }

        // ========================================
        // MOBILE MENU FUNCTIONALITY
        // ========================================

        function setupMobileMenu() {
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');
            const mobileMenuClose = document.getElementById('mobileMenuClose');
            const mobileMenuBody = document.querySelector('.mobile-menu-body');
            const controlsSidebar = document.querySelector('.controls-sidebar');

            if (!hamburgerBtn || !mobileMenuOverlay || !mobileMenuClose) {
                return; // Elements not found
            }

            // Clone sidebar content to mobile menu
            if (controlsSidebar && mobileMenuBody) {
                // Create a copy of sidebar sections for mobile
                const sidebarClone = controlsSidebar.cloneNode(true);
                
                // Remove the process section from clone (we'll add it separately at bottom)
                const processSection = sidebarClone.querySelector('.process-section');
                
                // Clear and populate mobile menu body
                mobileMenuBody.innerHTML = '';
                
                // Add all sections except process
                Array.from(sidebarClone.children).forEach(section => {
                    if (!section.classList.contains('process-section')) {
                        mobileMenuBody.appendChild(section.cloneNode(true));
                    }
                });

                // Add process section at the bottom
                if (processSection) {
                    mobileMenuBody.appendChild(processSection.cloneNode(true));
                }

                // Re-attach event listeners to cloned elements
                attachMobileMenuListeners(mobileMenuBody);
            }

            // Open menu
            hamburgerBtn.addEventListener('click', () => {
                mobileMenuOverlay.classList.add('active');
                hamburgerBtn.classList.add('active');
                document.body.style.overflow = 'hidden';
            });

            // Close menu
            mobileMenuClose.addEventListener('click', closeMobileMenu);
            
            // Close when clicking overlay
            mobileMenuOverlay.addEventListener('click', (e) => {
                if (e.target === mobileMenuOverlay) {
                    closeMobileMenu();
                }
            });

            // Close on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && mobileMenuOverlay.classList.contains('active')) {
                    closeMobileMenu();
                }
            });

            function closeMobileMenu() {
                mobileMenuOverlay.classList.remove('active');
                hamburgerBtn.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        function attachMobileMenuListeners(container) {
            // Effect options
            container.querySelectorAll('.effect-option').forEach(option => {
                option.addEventListener('click', function() {
                    const effect = this.dataset.effect;
                    // Update original sidebar
                    document.querySelectorAll('.controls-sidebar .effect-option').forEach(o => {
                        o.classList.remove('active');
                        if (o.dataset.effect === effect) {
                            o.classList.add('active');
                        }
                    });
                    // Update state
                    state.effect = effect;
                    renderFrame();
                });
            });

            // Detection mode options
            container.querySelectorAll('.mode-option').forEach(option => {
                option.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    // Update original sidebar
                    document.querySelectorAll('.controls-sidebar .mode-option').forEach(o => {
                        o.classList.remove('active');
                        if (o.dataset.mode === mode) {
                            o.classList.add('active');
                        }
                    });
                    // Update state
                    state.detectionMode = mode;
                    renderFrame();
                });
            });

            // Preset options
            container.querySelectorAll('.preset-option').forEach(option => {
                option.addEventListener('click', function() {
                    const preset = this.dataset.preset;
                    // Update original sidebar
                    document.querySelectorAll('.controls-sidebar .preset-option').forEach(o => {
                        o.classList.remove('active');
                        if (o.dataset.preset === preset) {
                            o.classList.add('active');
                        }
                    });
                    // Apply preset
                    if (typeof applyPreset === 'function') {
                        applyPreset(preset);
                    }
                });
            });

            // Sliders
            const intensitySlider = container.querySelector('#intensity');
            const intensityVal = container.querySelector('#intensityVal');
            if (intensitySlider && intensityVal) {
                intensitySlider.addEventListener('input', (e) => {
                    const originalSlider = document.getElementById('intensity');
                    const originalVal = document.getElementById('intensityVal');
                    state.intensity = parseInt(e.target.value);
                    intensityVal.textContent = state.intensity;
                    if (originalSlider) originalSlider.value = state.intensity;
                    if (originalVal) originalVal.textContent = state.intensity;
                    renderFrame();
                });
            }

            const effectSizeSlider = container.querySelector('#effectSize');
            const sizeVal = container.querySelector('#sizeVal');
            if (effectSizeSlider && sizeVal) {
                effectSizeSlider.addEventListener('input', (e) => {
                    const originalSlider = document.getElementById('effectSize');
                    const originalVal = document.getElementById('sizeVal');
                    state.effectSize = parseInt(e.target.value);
                    sizeVal.textContent = state.effectSize + '%';
                    if (originalSlider) originalSlider.value = state.effectSize;
                    if (originalVal) originalVal.textContent = state.effectSize + '%';
                    renderFrame();
                });
            }

            const borderSmoothSlider = container.querySelector('#borderSmooth');
            const borderVal = container.querySelector('#borderVal');
            if (borderSmoothSlider && borderVal) {
                borderSmoothSlider.addEventListener('input', (e) => {
                    const originalSlider = document.getElementById('borderSmooth');
                    const originalVal = document.getElementById('borderVal');
                    state.borderSmooth = parseInt(e.target.value);
                    borderVal.textContent = state.borderSmooth + 'px';
                    if (originalSlider) originalSlider.value = state.borderSmooth;
                    if (originalVal) originalVal.textContent = state.borderSmooth + 'px';
                    renderFrame();
                });
            }

            // Preview buttons
            const previewOriginal = container.querySelector('#previewOriginal');
            const previewEffects = container.querySelector('#previewEffects');
            if (previewOriginal && previewEffects) {
                previewOriginal.addEventListener('click', () => {
                    const originalOriginal = document.getElementById('previewOriginal');
                    const originalEffects = document.getElementById('previewEffects');
                    previewOriginal.classList.add('active');
                    previewEffects.classList.remove('active');
                    if (originalOriginal) originalOriginal.classList.add('active');
                    if (originalEffects) originalEffects.classList.remove('active');
                    state.previewMode = 'original';
                    document.getElementById('previewModeBadge').classList.remove('active');
                    document.getElementById('faceCounter').style.display = 'none';
                    renderFrame();
                });

                previewEffects.addEventListener('click', () => {
                    if (!state.modelReady) return;
                    const originalOriginal = document.getElementById('previewOriginal');
                    const originalEffects = document.getElementById('previewEffects');
                    previewEffects.classList.add('active');
                    previewOriginal.classList.remove('active');
                    if (originalEffects) originalEffects.classList.add('active');
                    if (originalOriginal) originalOriginal.classList.remove('active');
                    state.previewMode = 'effects';
                    document.getElementById('previewModeBadge').classList.add('active');
                    renderFrame();
                });
            }

            // Process button
            const processBtn = container.querySelector('#processBtn');
            if (processBtn) {
                processBtn.addEventListener('click', () => {
                    // Trigger original process button
                    document.getElementById('processBtn').click();
                    // Close menu
                    const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');
                    if (mobileMenuOverlay) {
                        mobileMenuOverlay.classList.remove('active');
                        document.body.style.overflow = '';
                    }
                });
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) loadVideo(file);
        }

        function handleDrop(e) {
            e.preventDefault();
            elements.uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('video/')) {
                loadVideo(file);
            }
        }

        function loadVideo(file) {
            // Reset video state
            video.pause();
            video.currentTime = 0;
            video.removeAttribute('src');
            
            try {
                // Create blob URL
                if (state.videoBlobUrl) {
                    URL.revokeObjectURL(state.videoBlobUrl);
                }
                state.videoBlobUrl = URL.createObjectURL(file);
                
                // Set video properties
                video.muted = true;
                video.playsInline = true;
                video.preload = 'auto';
                video.src = state.videoBlobUrl;
                
                // Event handlers
                video.onloadedmetadata = function() {
                    state.videoWidth = video.videoWidth;
                    state.videoHeight = video.videoHeight;

                    elements.renderCanvas.width = state.videoWidth;
                    elements.renderCanvas.height = state.videoHeight;
                    processCanvas.width = state.videoWidth;
                    processCanvas.height = state.videoHeight;

                    elements.uploadArea.style.display = 'none';
                    elements.videoContainer.classList.add('active');

                    elements.renderCanvas.style.visibility = 'visible';
                    elements.renderCanvas.style.display = 'block';

                    updateTimeDisplay();
                    
                    // Draw first frame
                    if (elements.renderCtx) {
                        elements.renderCtx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);
                    }

                    if (state.modelReady) {
                        elements.processBtn.disabled = false;
                    }
                };
                
                video.onloadeddata = function() {
                    // Video data is loaded, safe to play
                    video.play().catch(function(err) {
                        console.warn('Auto-play prevented:', err);
                    });
                };
                
                video.onerror = function() {
                    console.error('Video error code:', video.error ? video.error.code : 'unknown');
                    var errorMsg = 'Error al cargar el video.';
                    if (video.error) {
                        switch(video.error.code) {
                            case 1: errorMsg = 'El video fue interrumpido.'; break;
                            case 2: errorMsg = 'Error de red al descargar el video.'; break;
                            case 3: errorMsg = 'Error al decodificar el video.'; break;
                            case 4: errorMsg = 'El video no es compatible.'; break;
                        }
                    }
                    alert(errorMsg + ' Por favor intenta con otro archivo.');
                };
                
                // Start loading
                video.load();
                
            } catch (err) {
                console.error('Error in loadVideo:', err);
                alert('Error al procesar el video: ' + err.message);
            }
        }

        function togglePlay() {
            if (video.paused) {
                video.play();
                state.isPlaying = true;
                elements.playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                startPreviewLoop();
            } else {
                video.pause();
                state.isPlaying = false;
                elements.playBtn.innerHTML = '<i class="fas fa-play"></i>';
                stopPreviewLoop();
            }
        }

        function toggleMute() {
            video.muted = !video.muted;
            if (video.muted) {
                elements.volumeBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
            } else {
                elements.volumeBtn.innerHTML = '<i class="fas fa-volume-up"></i>';
            }
        }

        function updateProgress() {
            const progress = (video.currentTime / video.duration) * 100;
            elements.progressFill.style.width = progress + '%';
            updateTimeDisplay();
        }

        function updateTimeDisplay() {
            const current = formatTime(video.currentTime);
            const total = formatTime(video.duration || 0);
            elements.timeDisplay.querySelector('span').textContent = `${current} / ${total}`;
        }

        function seek(e) {
            const rect = elements.progressTrack.getBoundingClientRect();
            const position = (e.clientX - rect.left) / rect.width;
            video.currentTime = position * video.duration;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        let previewRequestId = null;
        let lastPreviewDetection = 0;
        const PREVIEW_DETECTION_INTERVAL = 30; // ms entre detecciones en preview

        function startPreviewLoop() {
            // Limpiar tracking al iniciar nuevo preview
            trackedFaces = [];
            lastFrameHadFaces = false;
            sceneChangeThreshold = 3;

            function loop() {
                if (!state.isPlaying) return;
                renderFrame();
                previewRequestId = requestAnimationFrame(loop);
            }
            loop();
        }

        function stopPreviewLoop() {
            if (previewRequestId) {
                cancelAnimationFrame(previewRequestId);
                previewRequestId = null;
            }
            cachedDetections = [];
            trackedFaces = [];
            lastPreviewDetection = 0;
        }

        function renderFrame() {
            if (!state.videoWidth || !elements.renderCtx) return;

            try {
                // Always redraw the video frame first
                elements.renderCtx.drawImage(video, 0, 0, state.videoWidth, state.videoHeight);

                if (state.previewMode === 'effects' && state.modelReady && !state.isProcessing) {
                    // Detection throttling for preview performance
                    const now = Date.now();
                    const shouldDetect = (now - lastPreviewDetection) > PREVIEW_DETECTION_INTERVAL;

                    if (shouldDetect) {
                        lastPreviewDetection = now;

                        // Usar detección completa con tracking
                        detectFacesExhaustively(video).then(detections => {
                            cachedDetections = detections;
                            applyCachedDetections();
                        }).catch(err => {
                            console.warn('Preview detection error:', err);
                        });
                    } else {
                        // Solo aplicar detecciones caché
                        applyCachedDetections();
                    }
                }
            } catch (e) {
                console.warn('Render error:', e.message);
            }
        }

        // Synchronous tracking prediction update on every frame
        function updateFaceTrackingPrediction() {
            trackedFaces.forEach(face => {
                // Predict next position based on velocity
                face.box.x += face.velocity.x;
                face.box.y += face.velocity.y;
                face.missCount = (face.missCount || 0) + 1;
                face.age = (face.age || 0) + 1;
                
                // Decay confidence over time without detection
                if (face.missCount > 0) {
                    face.confidence *= 0.92;
                }
            });
            
            // Remove faces that have been missing too long
            trackedFaces = trackedFaces.filter(face => face.missCount < 8);
        }

        // Async detection that updates tracking when complete
        let detectionInProgress = false;
        function runDetectionAsync(videoElement) {
            // Don't run detection if video is not ready or model not loaded
            if (detectionInProgress || !state.modelReady) return;
            if (!videoElement.videoWidth || !videoElement.videoHeight) return;
            if (videoElement.readyState < 2) return; // Wait for enough data
            
            detectionInProgress = true;
            
            // Usar la función unificada de detección
            detectFaces(videoElement)
                .then(detections => {
                    const videoWidth = videoElement.videoWidth;
                    const videoHeight = videoElement.videoHeight;
                    const minFaceSize = Math.min(videoWidth, videoHeight) * 0.05;
                    
                    const newDetections = [];
                    
                    for (const det of detections) {
                        const box = det.box;
                        
                        if (box.width >= minFaceSize && box.height >= minFaceSize) {
                            const aspectRatio = box.width / box.height;
                            if (aspectRatio >= 0.55 && aspectRatio <= 1.8 && det.score >= 0.5) {
                                newDetections.push({ box: box, score: det.score });
                            }
                        }
                    }
                    
                    // Match new detections to tracked faces
                    const usedDetections = new Set();
                    
                    for (const detection of newDetections) {
                        let bestMatch = null;
                        let bestIoU = 0;
                        
                        for (const tracked of trackedFaces) {
                            const iou = calculateIoU(detection.box, tracked.box);
                            if (iou > 0.25 && iou > bestIoU) {
                                bestIoU = iou;
                                bestMatch = tracked;
                            }
                        }
                        
                        if (bestMatch) {
                            const oldBox = { ...bestMatch.box };
                            bestMatch.velocity.x = (detection.box.x - oldBox.x) * 0.7;
                            bestMatch.velocity.y = (detection.box.y - oldBox.y) * 0.7;
                            bestMatch.box.x = oldBox.x + (detection.box.x - oldBox.x) * 0.7;
                            bestMatch.box.y = oldBox.y + (detection.box.y - oldBox.y) * 0.7;
                            bestMatch.box.width = oldBox.width + (detection.box.width - oldBox.width) * 0.7;
                            bestMatch.box.height = oldBox.height + (detection.box.height - oldBox.height) * 0.7;
                            bestMatch.lastSeen = Date.now();
                            bestMatch.missCount = 0;
                            bestMatch.confidence = detection.score;
                            bestMatch.age = 0;
                            usedDetections.add(detection);
                        }
                    }
                    
                    // Add new tracked faces for unmatched detections
                    for (const detection of newDetections) {
                        if (!usedDetections.has(detection)) {
                            trackedFaces.push({
                                id: nextFaceId++,
                                box: { ...detection.box },
                                velocity: { x: 0, y: 0 },
                                lastSeen: Date.now(),
                                confidence: detection.score,
                                missCount: 0,
                                age: 0
                            });
                        }
                    }
                })
                .catch(err => {
                    // Silently handle detection errors - video playback should continue
                    console.debug('Detection skipped:', err.message);
                })
                .finally(() => {
                    detectionInProgress = false;
                });
        }

        // ========================================
        // ROBUST FACE DETECTION & TRACKING
        // Funciona desde el primer frame y en cambios de cámara
        // ========================================

        // Contador de frames consecutivos sin detección
        let consecutiveMissedFrames = 0;
        const MAX_MISSED_FRAMES = 5;

        // Detección robusta con retry y tracking persistente
        async function detectFacesExhaustively(videoElement) {
            if (!state.modelReady || !videoElement) return [];

            const videoWidth = videoElement.videoWidth;
            const videoHeight = videoElement.videoHeight;

            if (!videoWidth || !videoHeight) return [];

            try {
                // Intentar detección directa de MediaPipe
                let rawDetections = await detectFaces(videoElement);

                // Si falla el primer intento, reintentar hasta 3 veces
                let retryCount = 0;
                while (rawDetections.length === 0 && retryCount < 3 && trackedFaces.length === 0) {
                    await new Promise(r => setTimeout(r, 10)); // Esperar 10ms
                    rawDetections = await detectFaces(videoElement);
                    retryCount++;
                }

                // Procesar detecciones con filtros mínimos
                const validDetections = [];

                for (const det of rawDetections) {
                    const box = det.box;
                    if (!box) continue;

                    // Solo filtro absoluto: dimensiones mínimas
                    if (box.width < 8 || box.height < 8) continue;

                    validDetections.push({
                        box: {
                            x: Math.max(0, box.x),
                            y: Math.max(0, box.y),
                            width: Math.min(box.width, videoWidth - box.x),
                            height: Math.min(box.height, videoHeight - box.y)
                        },
                        score: det.score || 0.95
                    });
                }

                // Si hay detecciones válidas
                if (validDetections.length > 0) {
                    consecutiveMissedFrames = 0;

                    // Si no hay tracking, crear uno nuevo
                    if (trackedFaces.length === 0) {
                        trackedFaces = validDetections.map((det) => ({
                            id: nextFaceId++,
                            box: { ...det.box },
                            velocity: { x: 0, y: 0 },
                            lastSeen: Date.now(),
                            confidence: det.score,
                            missedFrames: 0,
                            initialBox: { ...det.box } // Guardar posición inicial
                        }));
                    } else {
                        // Matching con tracking existente
                        for (const detection of validDetections) {
                            let bestMatch = null;
                            let bestIoU = 0;

                            for (const tracked of trackedFaces) {
                                const iou = calculateIoU(detection.box, tracked.box);
                                if (iou > bestIoU && iou > 0.01) {
                                    bestIoU = iou;
                                    bestMatch = tracked;
                                }
                            }

                            if (bestMatch) {
                                // Actualizar tracking
                                const oldBox = bestMatch.box;
                                bestMatch.box = { ...detection.box };
                                bestMatch.velocity.x = (detection.box.x - oldBox.x) * 0.8;
                                bestMatch.velocity.y = (detection.box.y - oldBox.y) * 0.8;
                                bestMatch.lastSeen = Date.now();
                                bestMatch.confidence = detection.score;
                                bestMatch.missedFrames = 0;
                            } else {
                                // Nueva cara
                                trackedFaces.push({
                                    id: nextFaceId++,
                                    box: { ...detection.box },
                                    velocity: { x: 0, y: 0 },
                                    lastSeen: Date.now(),
                                    confidence: detection.score,
                                    missedFrames: 0,
                                    initialBox: { ...detection.box }
                                });
                            }
                        }
                    }

                    return validDetections;
                }

                // No hay detecciones - usar tracking con predicción
                if (trackedFaces.length > 0) {
                    consecutiveMissedFrames++;

                    // Predicción de movimiento para frames perdidos
                    trackedFaces.forEach(face => {
                        // Predicción basada en velocidad
                        face.box.x += face.velocity.x;
                        face.box.y += face.velocity.y;

                        // Mantener cara dentro del frame
                        face.box.x = Math.max(0, Math.min(videoWidth - face.box.width, face.box.x));
                        face.box.y = Math.max(0, Math.min(videoHeight - face.box.height, face.box.y));

                        // Reducir velocidad gradualmente
                        face.velocity.x *= 0.9;
                        face.velocity.y *= 0.9;

                        face.missedFrames = (face.missedFrames || 0) + 1;
                    });

                    // Eliminar solo después de muchos frames perdidos
                    trackedFaces = trackedFaces.filter(face => {
                        if (face.missedFrames > MAX_MISSED_FRAMES) return false;
                        // Mantener confianza
                        face.confidence = Math.max(0.7, face.confidence * 0.95);
                        return true;
                    });

                    // Retornar predicciones
                    return trackedFaces.map(face => ({
                        box: { ...face.box },
                        score: face.confidence
                    }));
                }

                // No hay detecciones ni tracking - retornar vacío
                return [];

            } catch (e) {
                console.warn('Detection error:', e.message);

                // En caso de error, usar tracking si existe
                if (trackedFaces.length > 0) {
                    trackedFaces.forEach(face => {
                        face.box.x += face.velocity.x;
                        face.box.y += face.velocity.y;
                    });
                    return trackedFaces.map(face => ({
                        box: { ...face.box },
                        score: face.confidence
                    }));
                }

                return [];
            }
        }

        // Calculate IoU for overlap detection
        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

            if (x2 <= x1 || y2 <= y1) return 0;

            const intersection = (x2 - x1) * (y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;

            return union > 0 ? intersection / union : 0;
        }

        // Strict Non-Maximum Suppression
        function applyNonMaxSuppression(detections, iouThreshold = 0.4) {
            if (detections.length <= 1) return detections;
            
            const sorted = [...detections].sort((a, b) => b.score - a.score);
            const selected = [];
            const used = new Set();
            
            for (const det of sorted) {
                if (used.has(det)) continue;
                
                selected.push(det);
                
                for (const other of sorted) {
                    if (used.has(other) || other === det) continue;
                    
                    const iou = calculateIoU(det.box, other.box);
                    if (iou > iouThreshold) {
                        used.add(other);
                    }
                }
            }
            
            return selected;
        }

        // Calculate IoU for overlap detection
        function calculateIoU(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
            
            if (x2 <= x1 || y2 <= y1) return 0;
            
            const intersection = (x2 - x1) * (y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;
            
            return intersection / union;
        }

        // Merge detections that are close to each other (likely same face)
        function mergeDuplicateDetections(detections) {
            if (detections.length <= 1) return detections;
            
            const merged = [];
            const used = new Set();
            
            for (let i = 0; i < detections.length; i++) {
                if (used.has(i)) continue;
                
                const det = detections[i];
                const box1 = det.box;
                let combinedScore = det.score;
                let count = 1;
                
                for (let j = i + 1; j < detections.length; j++) {
                    if (used.has(j)) continue;
                    
                    const box2 = detections[j].box;
                    
                    // Check if boxes overlap significantly
                    const overlap = calculateOverlap(box1, box2);
                    if (overlap > 0.5) {
                        // Merge boxes
                        box1.x = Math.min(box1.x, box2.x);
                        box1.y = Math.min(box1.y, box2.y);
                        box1.width = Math.max(box1.x + box1.width, box2.x + box2.width) - box1.x;
                        box1.height = Math.max(box1.y + box1.height, box2.y + box2.height) - box1.y;
                        
                        combinedScore = Math.max(combinedScore, detections[j].score);
                        used.add(j);
                        count++;
                    }
                }
                
                merged.push({
                    box: box1,
                    score: combinedScore
                });
                used.add(i);
            }
            
            return merged;
        }

        // Simple box overlap calculation
        function calculateOverlap(box1, box2) {
            const x1 = Math.max(box1.x, box2.x);
            const y1 = Math.max(box1.y, box2.y);
            const x2 = Math.min(box1.x + box1.width, box2.x + box2.width);
            const y2 = Math.min(box1.y + box1.height, box2.y + box2.height);
            
            if (x2 <= x1 || y2 <= y1) return 0;
            
            const intersection = (x2 - x1) * (y2 - y1);
            const area1 = box1.width * box1.height;
            const area2 = box2.width * box2.height;
            const union = area1 + area2 - intersection;
            
            return intersection / union;
        }

        function applyCachedDetections() {
            if (cachedDetections.length === 0) {
                elements.faceCounter.style.display = 'none';
                return;
            }

            state.faceCount = cachedDetections.length;
            elements.faceCounter.style.display = 'flex';
            elements.faceCountValue.textContent = cachedDetections.length;

            let facesToProcess = filterFaces(cachedDetections);
            if (facesToProcess.length === 0) return;

            const scaleX = state.videoWidth / video.videoWidth;
            const scaleY = state.videoHeight / video.videoHeight;

            facesToProcess.forEach(detection => {
                const box = detection.box;
                
                let x = box.x * scaleX;
                let y = box.y * scaleY;
                let w = box.width * scaleX;
                let h = box.height * scaleY;

                if (w > 0 && h > 0) {
                    const centerX = x + w / 2;
                    const centerY = y + h / 2;
                    const sizeMultiplier = state.effectSize / 100;
                    w = w * sizeMultiplier;
                    h = h * sizeMultiplier;
                    x = centerX - w / 2;
                    y = centerY - h / 2;

                    if (state.effect === 'pixelate') {
                        pixelateArea(elements.renderCtx, x, y, w, h, state.borderSmooth);
                    } else {
                        blurArea(elements.renderCtx, x, y, w, h, state.borderSmooth);
                    }
                }
            });
        }

        async function applyEffects() {
            try {
                // Usar la función unificada de detección
                const detections = await detectFaces(video);
                
                state.faceCount = detections.length;
                
                if (detections.length === 0) {
                    elements.faceCounter.style.display = 'none';
                    return;
                }

                elements.faceCounter.style.display = 'flex';
                elements.faceCountValue.textContent = detections.length;

                let facesToProcess = filterFaces(detections);

                if (facesToProcess.length === 0) return;

                const scaleX = state.videoWidth / video.videoWidth;
                const scaleY = state.videoHeight / video.videoHeight;

                facesToProcess.forEach(detection => {
                    const box = detection.box;
                    
                    // Calcular posición y tamaño con el multiplicador
                    let x = box.x * scaleX;
                    let y = box.y * scaleY;
                    let w = box.width * scaleX;
                    let h = box.height * scaleY;

                    if (w > 0 && h > 0) {
                        // Aplicar tamaño personalizado
                        const centerX = x + w / 2;
                        const centerY = y + h / 2;
                        const sizeMultiplier = state.effectSize / 100;
                        w = w * sizeMultiplier;
                        h = h * sizeMultiplier;
                        x = centerX - w / 2;
                        y = centerY - h / 2;

                        if (state.effect === 'pixelate') {
                            pixelateArea(elements.renderCtx, x, y, w, h, state.borderSmooth);
                        } else {
                            blurArea(elements.renderCtx, x, y, w, h, state.borderSmooth);
                        }
                    }
                });

            } catch (e) {
                console.error('Detection error:', e);
            }
        }

        function filterFaces(detections) {
            if (state.detectionMode === 'single') {
                return detections.slice(0, 1);
            }
            if (state.detectionMode === 'center') {
                const centerX = video.videoWidth / 2;
                const centerY = video.videoHeight / 2;
                let closestFace = null;
                let minDistance = Infinity;

                detections.forEach(d => {
                    const faceCenterX = d.box.x + d.box.width / 2;
                    const faceCenterY = d.box.y + d.box.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(faceCenterX - centerX, 2) + 
                        Math.pow(faceCenterY - centerY, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestFace = d;
                    }
                });

                return closestFace ? [closestFace] : [];
            }
            return detections;
        }

        function pixelateArea(ctx, x, y, w, h, smoothRadius = 0) {
            if (w <= 0 || h <= 0) return;
            
            // Aplicar suavizado de bordes si está configurado
            let finalX = x;
            let finalY = y;
            let finalW = w;
            let finalH = h;
            
            if (smoothRadius > 0) {
                // Crear un rectángulo más pequeño sin los bordes
                finalX = x + smoothRadius;
                finalY = y + smoothRadius;
                finalW = w - (smoothRadius * 2);
                finalH = h - (smoothRadius * 2);
                
                if (finalW <= 0 || finalH <= 0) {
                    finalX = x;
                    finalY = y;
                    finalW = w;
                    finalH = h;
                }
            }
            
            ctx.imageSmoothingEnabled = false;
            const size = Math.max(1, Math.floor(finalW / state.intensity));
            ctx.drawImage(ctx.canvas, finalX, finalY, finalW, finalH, finalX, finalY, size, size);
            ctx.drawImage(ctx.canvas, finalX, finalY, size, size, finalX, finalY, finalW, finalH);
        }

        function blurArea(ctx, x, y, w, h, smoothRadius = 0) {
            if (w <= 0 || h <= 0) return;
            
            ctx.save();
            
            if (smoothRadius > 0) {
                // Usar desenfoque con borde suavizado
                const blurAmount = state.intensity;
                ctx.filter = `blur(${blurAmount}px)`;
                
                // Dibujar área con desenfoque
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, smoothRadius);
                ctx.clip();
                ctx.drawImage(ctx.canvas, 0, 0);
            } else {
                // Desenfoque duro original
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.clip();
                ctx.filter = `blur(${state.intensity}px)`;
                ctx.drawImage(ctx.canvas, 0, 0);
            }
            
            ctx.restore();
        }

        async function processVideo() {
            if (state.isProcessing || !state.modelReady) return;

            state.isProcessing = true;
            state.processingCanceled = false;

            video.pause();
            stopPreviewLoop();

            elements.processBtn.disabled = true;
            if (elements.exportBtn) elements.exportBtn.disabled = true;
            elements.modal.classList.add('active');
            elements.modalFill.style.width = '0%';
            elements.modalPercent.textContent = '0%';
            elements.modalTitle.textContent = 'Inicializando';
            elements.modalSubtitle.innerHTML = '<span class="loading-dots"><span></span><span></span><span></span></span> Preparando procesamiento preciso...';

            const originalWidth = state.videoWidth;
            const originalHeight = state.videoHeight;
            const duration = video.duration;
            const originalTime = video.currentTime;

            // Calcular FPS real del video con mayor precisión
            let fps = 30;
            if (video.videoFrameRate && video.videoFrameRate > 0) {
                fps = video.videoFrameRate;
            } else {
                // Estimar FPS basado en duracion y frames estimados
                const estimatedTotalFrames = Math.ceil(duration * 30);
                fps = estimatedTotalFrames / duration;
            }

            const totalFrames = Math.ceil(duration * fps);

            console.log(`Procesando video: ${duration}s, FPS: ${fps.toFixed(2)}, Total frames: ${totalFrames}`);

            const ctx = processCanvas.getContext('2d', { willReadFrequently: true });
            processCanvas.width = originalWidth;
            processCanvas.height = originalHeight;

            // Pre-cargar todos los frames en memoria
            const frames = [];
            const frameTimes = [];

            // Generar tiempos exactos para cada frame
            for (let i = 0; i < totalFrames; i++) {
                frameTimes.push((i / fps));
            }

            let startTime = Date.now();

            // Función mejorada para esperar que el video esté listo
            function waitForVideoState(minState = 2, timeout = 2000) {
                return new Promise((resolve) => {
                    if (video.readyState >= minState) {
                        resolve(true);
                        return;
                    }

                    const onCanPlay = () => {
                        cleanup();
                        resolve(true);
                    };

                    const onSeeked = () => {
                        cleanup();
                        if (video.readyState >= minState) {
                            resolve(true);
                        } else {
                            const onCanPlay2 = () => {
                                cleanup();
                                resolve(true);
                            };
                            video.addEventListener('canplay', onCanPlay2);
                        }
                    };

                    const cleanup = () => {
                        video.removeEventListener('canplay', onCanPlay);
                        video.removeEventListener('seeked', onSeeked);
                        clearTimeout(timeoutId);
                    };

                    const timeoutId = setTimeout(() => {
                        cleanup();
                        resolve(video.readyState >= minState);
                    }, timeout);

                    video.addEventListener('canplay', onCanPlay);
                    video.addEventListener('seeked', onSeeked);
                });
            }

            // Función de seek precisa
            function seekToTime(targetTime) {
                return new Promise((resolve) => {
                    const currentTime = video.currentTime;

                    // Si ya estamos en el tiempo exacto, continuar
                    if (Math.abs(currentTime - targetTime) < 0.001) {
                        resolve(true);
                        return;
                    }

                    let attempts = 0;
                    const maxAttempts = 2;

                    function doSeek() {
                        attempts++;

                        const onSeeked = () => {
                            cleanup();
                            // Verificar que llegamos al tiempo correcto
                            setTimeout(() => {
                                if (Math.abs(video.currentTime - targetTime) < 0.01) {
                                    resolve(true);
                                } else if (attempts < maxAttempts) {
                                    doSeek();
                                } else {
                                    resolve(true); // Aceptar aunque no sea exacto
                                }
                            }, 10);
                        };

                        const cleanup = () => {
                            video.removeEventListener('seeked', onSeeked);
                            clearTimeout(timeoutId);
                        };

                        const timeoutId = setTimeout(() => {
                            cleanup();
                            if (attempts < maxAttempts) {
                                doSeek();
                            } else {
                                resolve(false);
                            }
                        }, 1500);

                        video.addEventListener('seeked', onSeeked, { once: true });
                        video.currentTime = targetTime;
                    }

                    doSeek();
                });
            }

            // Procesar todos los frames con detección precisa
            for (let i = 0; i < totalFrames; i++) {
                if (state.processingCanceled) break;

                const targetTime = frameTimes[i];

                // Actualizar UI
                const progress = (i / totalFrames) * 100;
                elements.modalFill.style.width = `${progress}%`;
                elements.modalPercent.textContent = `${Math.round(progress)}%`;
                elements.modalFrames.textContent = `${i + 1} / ${totalFrames}`;

                const elapsed = Math.round((Date.now() - startTime) / 1000);
                const eta = i > 0 ? Math.round((elapsed / i) * (totalFrames - i)) : 0;
                elements.modalTime.textContent = `${formatTime(elapsed)} / ~${formatTime(eta)}`;

                elements.modalTitle.textContent = 'Procesando';
                elements.modalSubtitle.textContent = `Frame ${i + 1}/${totalFrames} - ${Math.round(targetTime * 100) / 100}s`;

                // Seek preciso al tiempo del frame
                await seekToTime(targetTime);
                await waitForVideoState(2);

                // Pequeña pausa para estabilización
                await new Promise(r => setTimeout(r, 5));

                // Capturar frame
                ctx.drawImage(video, 0, 0, originalWidth, originalHeight);

                // Detección precisa con MediaPipe
                try {
                    const detections = await detectFaces(video);

                    // Filtrar rostros según modo
                    let facesToProcess = filterFaces(detections);

                    if (facesToProcess.length > 0) {
                        const scaleX = originalWidth / video.videoWidth;
                        const scaleY = originalHeight / video.videoHeight;

                        facesToProcess.forEach(detection => {
                            const box = detection.box;
                            let x = box.x * scaleX;
                            let y = box.y * scaleY;
                            let w = box.width * scaleX;
                            let h = box.height * scaleY;

                            if (w > 0 && h > 0) {
                                // Expandir ligeramente para mejor cobertura
                                const expandRatio = 0.1;
                                x = Math.max(0, x - (w * expandRatio));
                                y = Math.max(0, y - (h * expandRatio));
                                w = Math.min(originalWidth - x, w * (1 + expandRatio * 2));
                                h = Math.min(originalHeight - y, h * (1 + expandRatio * 2));

                                // Aplicar tamaño configurado
                                const centerX = x + w / 2;
                                const centerY = y + h / 2;
                                const sizeMultiplier = state.effectSize / 100;
                                w = w * sizeMultiplier;
                                h = h * sizeMultiplier;
                                x = centerX - w / 2;
                                y = centerY - h / 2;

                                // Aplicar efecto
                                if (state.effect === 'pixelate') {
                                    pixelateArea(ctx, x, y, w, h, state.borderSmooth);
                                } else {
                                    blurArea(ctx, x, y, w, h, state.borderSmooth);
                                }
                            }
                        });
                    }
                } catch (e) {
                    console.warn(`Error en frame ${i}:`, e.message);
                }

                // Guardar frame procesado
                frames.push({
                    data: processCanvas.toDataURL('image/jpeg', 0.92),
                    time: targetTime
                });
            }

            // Restaurar tiempo original del video
            video.currentTime = originalTime;

            console.log(`Procesados ${frames.length} frames con duracion real: ${frames[frames.length-1].time}s`);

            // Crear video final
            createFinalVideo(frames, fps, duration);
        }

        function createFinalVideo(frames, fps, originalDuration) {
            if (frames.length === 0) {
                alert('Error: No se procesaron frames');
                state.isProcessing = false;
                elements.processBtn.disabled = false;
                elements.modal.classList.remove('active');
                return;
            }

            elements.modalTitle.textContent = 'Generando Video';
            elements.modalSubtitle.innerHTML = '<span class="loading-dots"><span></span><span></span><span></span></span> Compilando video fluido...';
            elements.modalFill.style.width = '100%';

            const canvas = document.createElement('canvas');
            canvas.width = state.videoWidth;
            canvas.height = state.videoHeight;
            const ctx = canvas.getContext('2d');

            // Usar el FPS calculado exactamente
            const outputFps = fps;

            // Crear stream con FPS preciso
            const stream = canvas.captureStream(outputFps);

            // Seleccionar codec óptimo
            let mimeType = 'video/webm;codecs=vp9';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'video/webm;codecs=vp8';
            }
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'video/webm';
            }

            console.log(`Generando video: ${frames.length} frames a ${outputFps.toFixed(2)}fps`);

            // Configurar MediaRecorder
            const recorder = new MediaRecorder(stream, {
                mimeType: mimeType,
                videoBitsPerSecond: 6000000, // 6 Mbps para buena calidad
                frameRate: outputFps
            });

            const chunks = [];
            recorder.ondataavailable = e => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            recorder.onstop = () => {
                // Crear blob con duracion verificada
                state.processedBlob = new Blob(chunks, { type: 'video/webm' });
                state.isProcessing = false;

                elements.processBtn.disabled = false;
                if (elements.exportBtn) elements.exportBtn.disabled = false;
                elements.modal.classList.remove('active');

                const blobSize = (state.processedBlob.size / 1024 / 1024).toFixed(2);
                const outputDuration = frames.length / outputFps;

                console.log(`Video creado: ${blobSize}MB, ${frames.length} frames, duracion: ${outputDuration.toFixed(3)}s`);

                alert(`Video procesado correctamente.\n\nFrames: ${frames.length}\nFPS: ${outputFps.toFixed(2)}\nDuracion origen: ${originalDuration.toFixed(3)}s\nDuracion salida: ${outputDuration.toFixed(3)}s\nTamaño: ${blobSize}MB\n\nHaz clic en "Exportar" para guardar.`);
            };

            // Cargar todas las imágenes primero
            const loadedFrames = [];
            let loadedCount = 0;

            frames.forEach((frame, index) => {
                const img = new Image();
                img.onload = () => {
                    loadedFrames[index] = img;
                    loadedCount++;
                    if (loadedCount === frames.length) {
                        startRecording();
                    }
                };
                img.onerror = () => {
                    console.error(`Error cargando frame ${index}`);
                    loadedFrames[index] = null;
                    loadedCount++;
                    if (loadedCount === frames.length) {
                        startRecording();
                    }
                };
                img.src = frame.data;
            });

            // Grabar video con timing preciso
            function startRecording() {
                recorder.start();

                let frameIndex = 0;
                let lastFrameTime = performance.now();
                const frameInterval = 1000 / outputFps;

                // Pre-calcular todos los tiempos de frame
                const frameTimes = loadedFrames.map((_, i) => i * frameInterval);

                function drawFrame(currentTime) {
                    if (frameIndex >= loadedFrames.length) {
                        // Asegurar que todos los frames se muestren
                        setTimeout(() => recorder.stop(), frameInterval * 2);
                        return;
                    }

                    const expectedTime = frameTimes[frameIndex];
                    const elapsed = currentTime - lastFrameTime;

                    // Renderizar frame cuando sea el momento exacto
                    if (elapsed >= frameInterval - 2) {
                        const frame = loadedFrames[frameIndex];
                        if (frame) {
                            ctx.drawImage(frame, 0, 0);
                        }
                        lastFrameTime = currentTime;
                        frameIndex++;
                    }

                    if (frameIndex < loadedFrames.length) {
                        requestAnimationFrame(drawFrame);
                    } else {
                        setTimeout(() => recorder.stop(), frameInterval * 2);
                    }
                }

                // Iniciar después de una breve pausa
                setTimeout(() => {
                    lastFrameTime = performance.now();
                    requestAnimationFrame(drawFrame);
                }, 100);
            }
        }

        function exportVideo() {
            if (!state.processedBlob) {
                alert('Primero procesa un video');
                return;
            }
            const url = URL.createObjectURL(state.processedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `faceblur_${Date.now()}.webm`;
            a.click();
        }

        function resetApp() {
            video.pause();
            stopPreviewLoop();
            
            if (state.videoBlobUrl) {
                URL.revokeObjectURL(state.videoBlobUrl);
            }

            state.videoBlobUrl = null;
            state.processedBlob = null;
            state.isPlaying = false;
            state.videoWidth = 0;
            state.videoHeight = 0;
            state.faceCount = 0;

            elements.uploadArea.style.display = 'block';
            elements.videoContainer.classList.remove('active');
            if (elements.exportBtn) elements.exportBtn.disabled = true;
            elements.processBtn.disabled = true;
            elements.fileInput.value = '';
            elements.progressFill.style.width = '0%';
            elements.timeDisplay.querySelector('span').textContent = '0:00 / 0:00';
            elements.playBtn.innerHTML = '<i class="fas fa-play"></i>';
            elements.faceCounter.style.display = 'none';
        }

        // ========================================
        // PWA INSTALACIÓN AUTOMÁTICA COMPLETA
        // ========================================
        let deferredPrompt = null;
        const installBtn = document.getElementById('installBtn');
        const installOverlay = document.getElementById('installOverlay');
        const installProgressFill = document.getElementById('installProgressFill');
        const installPercent = document.getElementById('installPercent');
        const installStatus = document.getElementById('installStatus');

        // Escuchar mensajes del Service Worker para progreso real
        navigator.serviceWorker.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'INSTALL_PROGRESS') {
                // Actualizar progreso real desde el Service Worker
                updateInstallProgress(event.data.progress, event.data.status, event.data.currentFile || '');
            }
        });

        // Mostrar botón de instalación cuando el PWA es instalable
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installBtn.classList.remove('hidden');
            console.log('✓ PWA instalable - mostrando botón de instalación');
            
            // Notificar al usuario que la app puede instalarse
            showNotification('FaceBlur Studio está lista para instalar', 'info');
        });

        // Ocultar botón después de instalación exitosa
        window.addEventListener('appinstalled', () => {
            installBtn.classList.add('hidden');
            deferredPrompt = null;
            console.log('✓ PWA instalada correctamente');
            
            // Verificar que todo esté cacheado
            if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({ type: 'GET_INSTALL_STATUS' });
            }
            
            showNotification('🎉 FaceBlur Studio instalada correctamente. ¡Ahora funciona sin conexión!', 'success');
        });

        // Manejar clic en botón de instalación
        installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) return;

            // Mostrar overlay de instalación
            installOverlay.classList.add('active');
            updateInstallProgress(0, 'Preparando instalación automática...', '');
            
            // Verificar estado del Service Worker
            if (!navigator.serviceWorker.controller) {
                updateInstallProgress(5, 'Inicializando Service Worker...', '');
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // Mostrar el prompt de instalación del sistema
            deferredPrompt.prompt();

            // Esperar respuesta del usuario
            const { outcome } = await deferredPrompt.userChoice;

            if (outcome === 'accepted') {
                console.log('✓ Usuario aceptó instalación');
                updateInstallProgress(10, 'Iniciando descarga automática de recursos...', 'Preparando...');
                
                // Forzar instalación inmediata del Service Worker
                if (navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({ type: 'SKIP_WAITING' });
                }
            } else {
                console.log('Usuario canceló instalación');
                installOverlay.classList.remove('active');
            }

            deferredPrompt = null;
        });

        // Función para actualizar progreso de instalación
        function updateInstallProgress(percent, status, currentFile = '') {
            installProgressFill.style.width = percent + '%';
            installPercent.textContent = Math.round(percent) + '%';
            
            if (currentFile) {
                installStatus.innerHTML = `${status}<br><small style="opacity: 0.7;">${currentFile}</small>`;
            } else {
                installStatus.textContent = status;
            }
        }

        // Verificar estado de instalación al cargar
        window.addEventListener('load', () => {
            if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                // Solicitar estado actual de instalación
                navigator.serviceWorker.controller.postMessage({ type: 'GET_INSTALL_STATUS' });
                
                // Escuchar estado de instalación
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'INSTALL_STATUS') {
                        const state = event.data.state;
                        if (state && state.phase === 'active') {
                            console.log('✅ App lista para uso offline');
                        }
                    }
                });
            }
        });

        // Verificar si ya está instalado
        if (window.matchMedia('(display-mode: standalone)').matches) {
            console.log('✅ App运行在独立模式');
            showNotification('✨ Modo offline activo', 'success');
        }

        // Mostrar notificación
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 24px;
                left: 50%;
                transform: translateX(-50%);
                padding: 16px 24px;
                background: ${type === 'success' ? 'var(--success)' : 'var(--primary)'};
                color: white;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 500;
                z-index: 3000;
                animation: slideInUp 0.5s ease;
            `;
            notification.innerHTML = `<i class="fas fa-${type === 'success' ? 'check-circle' : 'info-circle'}"></i> ${message}`;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.5s ease';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        init();
        
        // ========================================
        // PRESETS DE CONFIGURACIÓN DE IA
        // Configuraciones predefinidas para MediaPipe Face Mesh
        // ========================================
        
        // Definición de presets
        const AI_PRESETS = {
            fast: {
                name: 'Rápido',
                modelSelection: 0,      // Modelo corto
                refineLandmarks: false, // Sin refinamiento de iris
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5,
                performance: 'Alto',
                description: 'Velocidad optimizada para procesamiento rápido'
            },
            balanced: {
                name: 'Equilibrado',
                modelSelection: 1,      // Modelo completo
                refineLandmarks: false, // Sin refinamiento de iris
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.6,
                performance: 'Medio',
                description: 'Balance óptimo entre velocidad y precisión'
            },
            precise: {
                name: 'Preciso',
                modelSelection: 1,      // Modelo completo
                refineLandmarks: true,  // Con refinamiento de iris
                minDetectionConfidence: 0.8,
                minTrackingConfidence: 0.7,
                performance: 'Medio-Bajo',
                description: 'Máxima precisión en detección facial'
            },
            ultra: {
                name: 'Ultra',
                modelSelection: 1,      // Modelo completo
                refineLandmarks: true,  // Con refinamiento de iris
                minDetectionConfidence: 0.9,
                minTrackingConfidence: 0.85,
                performance: 'Bajo',
                description: 'Tracking avanzado para máxima calidad'
            }
        };
        
        // Preset activo actual
        let activePreset = 'balanced';
        
        // Función para aplicar un preset
        function applyPreset(presetName) {
            const preset = AI_PRESETS[presetName];
            if (!preset) return;
            
            activePreset = presetName;
            state.modelSelection = preset.modelSelection;
            state.refineLandmarks = preset.refineLandmarks;
            state.minDetectionConfidence = preset.minDetectionConfidence;
            state.minTrackingConfidence = preset.minTrackingConfidence;
            
            console.log(`[AI] Preset aplicado: ${preset.name} (${preset.description})`);
            
            // Actualizar UI
            updatePresetUI(presetName, preset);
            
            // Reinicializar MediaPipe Tasks con nueva configuración
            if (state.modelReady) {
                loadAI();
            }
        }
        
        // Actualizar la interfaz de presets
        function updatePresetUI(presetName, preset) {
            // Actualizar opciones activas
            document.querySelectorAll('.preset-option').forEach(el => {
                el.classList.remove('active');
                if (el.dataset.preset === presetName) {
                    el.classList.add('active');
                }
            });
            
            // Actualizar badge
            const badge = document.getElementById('activePresetBadge');
            if (badge) {
                badge.textContent = preset.name;
            }
            
            // Actualizar detalles
            const modelEl = document.getElementById('presetModel');
            const confidenceEl = document.getElementById('presetConfidence');
            const performanceEl = document.getElementById('presetPerformance');
            
            if (modelEl) {
                modelEl.textContent = preset.modelSelection === 1 ? 'Completo (468 pts)' : 'Corto';
            }
            if (confidenceEl) {
                confidenceEl.textContent = `${Math.round(preset.minDetectionConfidence * 100)}%`;
            }
            if (performanceEl) {
                performanceEl.textContent = preset.performance;
            }
        }
        
        // Inicializar controladores de presets
        function initPresetControllers() {
            document.querySelectorAll('.preset-option').forEach(option => {
                option.addEventListener('click', function() {
                    const presetName = this.dataset.preset;
                    if (presetName) {
                        applyPreset(presetName);
                    }
                });
            });
            
            // Aplicar preset inicial
            const initialPreset = AI_PRESETS[activePreset];
            if (initialPreset) {
                updatePresetUI(activePreset, initialPreset);
            }
            
            console.log('[AI] Controladores de presets inicializados');
        }
        
        // Inicializar presets después de que el DOM esté listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initPresetControllers);
        } else {
            initPresetControllers();
        }
    </script>
</body>
</html>
